<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="img/Tool.png" type="image/x-icon">
  <link rel="shortcut icon" href="img/Tool.png" type="image/x-icon">
  <title>小工具聚合站</title>
  <style>
    body { margin:0; padding:0; overflow:hidden; background:#000; }
    #fishCanvas{position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:-1;}
    #toolSelector {
      flex: 1;
      display: flex;
      overflow-x: auto;
      scroll-snap-type: x mandatory;
      -ms-overflow-style: none;
      scrollbar-width: none;
    }
    #toolSelector::-webkit-scrollbar { display: none; }
    #toolSelector button{margin:0 5px;padding:8px 10px;font-size:12px;cursor:pointer;border:none;border-radius:5px;background:#2b3432;color:#fff;text-shadow:0 1px 2px rgba(0,0,0,.5); flex: 0 0 18.5%; scroll-snap-align: start;transition: transform .3s ease, filter .3s ease; transform: scale(0.9); filter: brightness(0.7);} 
    #toolSelector button.focused {transform: scale(1.05); filter: brightness(0.8);}
    #toolSelector button.active{background:#537e74;}
    .tool-container{display:none;position:relative;z-index:10;padding:10px;}
    .tool-container.active{display:block;}
    #toolNav {
      position: relative;
      display: flex;
      align-items: center;
    }
    .nav-arrow {
      position: absolute;
      top: 50%;
      transform: translateY(-10%);
      width: 32px; height: 32px;
      border:none; background:rgba(0,0,0,0.6); color:#fff;
      cursor: pointer; border-radius:50%;
      z-index: 10;
    }
    #prevBtn { left: 4px; }
    #nextBtn { right: 4px; }
    .nav-arrow {
      position: relative;
      width: 36px;
      height: 36px;
      margin: 0 4px;
      background: rgba(0,0,0,0.5);
      border: none;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0,0,0,0.4);
      transition: transform .15s ease, background .15s ease, box-shadow .15s ease;
    }    
    .nav-arrow svg {
      width: 20px;
      height: 20px;
    }
    .nav-arrow:hover {
      background: rgba(41,207,168,0.8);
      transform: scale(1.1);
      box-shadow: 0 6px 12px rgba(0,0,0,0.5);
    }    
    .nav-arrow:active {
      transform: scale(0.95);
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.6);
    }

    /*系統工具容器框架 時間管理工具樣式 */
    #timeTool,#morseTool,#binaryTool{
      width:45%; max-height:70vh; background:rgba(0,0,0,.7);
      margin:0 auto; padding:15px 20px; color:#fff;
      border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,.6);
      font-family:sans-serif; overflow-y:auto;
      position:relative; display:flex; flex-direction:column;
      transform:none; margin-top:0;
    }
    #timeTool::before,#morseTool::before,#binaryTool::before{content:"";display:block;height:0;}
    #timeTool>h2,#morseTool>h2,#binaryTool>h2{
      margin:0 0 6px 0; font-size:13px; text-align:center;
      text-shadow:0 1px 3px rgba(0,0,0,.7); line-height:1.2;
    }
    #tool1Container, #tool2Container,#tool3Container{padding-top: 10px;} 
    .copy-tooltip {
      position: absolute;
      transform: translateX(-50%);
      background: #444;
      color: #fff;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 14px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      opacity: 1;
      transition: opacity 0.3s ease;
      pointer-events: none;
      z-index: 10000;
    }
    /*卷軸樣式*/
    #crossTool,
    #timeTool,
    #eventsList,
    #binaryTool,
    #binaryTool textarea,
    #morseTool,
    #morseTool textarea,
    #codeTool,
    #exchangeTool,
    #exchangeTool input,
    #exchangeTool select {
      scrollbar-width: thin;
      scrollbar-color: #0a634e rgba(255,255,255,0.08);
    }
    #crossTool::-webkit-scrollbar,
    #timeTool::-webkit-scrollbar,
    #eventsList::-webkit-scrollbar,
    #binaryTool::-webkit-scrollbar,
    #binaryTool textarea::-webkit-scrollbar,
    #morseTool::-webkit-scrollbar,
    #morseTool textarea::-webkit-scrollbar,
    #codeTool::-webkit-scrollbar,
    #exchangeTool::-webkit-scrollbar,
    #exchangeTool input::-webkit-scrollbar,
    #exchangeTool select::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    #crossTool::-webkit-scrollbar-track,
    #timeTool::-webkit-scrollbar-track,
    #eventsList::-webkit-scrollbar-track,
    #binaryTool::-webkit-scrollbar-track,
    #binaryTool textarea::-webkit-scrollbar-track,
    #morseTool::-webkit-scrollbar-track,
    #morseTool textarea::-webkit-scrollbar-track,
    #codeTool::-webkit-scrollbar-track,
    #exchangeTool::-webkit-scrollbar-track,
    #exchangeTool input::-webkit-scrollbar-track,
    #exchangeTool select::-webkit-scrollbar-track {
      background: rgba(255,255,255,0.08);
      border-radius: 4px;
    }
    #crossTool::-webkit-scrollbar-thumb,
    #timeTool::-webkit-scrollbar-thumb,
    #eventsList::-webkit-scrollbar-thumb,
    #binaryTool::-webkit-scrollbar-thumb,
    #binaryTool textarea::-webkit-scrollbar-thumb,
    #morseTool::-webkit-scrollbar-thumb,
    #morseTool textarea::-webkit-scrollbar-thumb,
    #codeTool::-webkit-scrollbar-thumb,
    #exchangeTool::-webkit-scrollbar-thumb,
    #exchangeTool input::-webkit-scrollbar-thumb,
    #exchangeTool select::-webkit-scrollbar-thumb {
      background: #29cfa8;
      border-radius: 4px;
    }
    #crossTool::-webkit-scrollbar-thumb:hover,
    #timeTool::-webkit-scrollbar-thumb:hover,
    #eventsList::-webkit-scrollbar-thumb:hover,
    #binaryTool::-webkit-scrollbar-thumb:hover,
    #binaryTool textarea::-webkit-scrollbar-thumb:hover,
    #morseTool::-webkit-scrollbar-thumb:hover,
    #morseTool textarea::-webkit-scrollbar-thumb:hover,
    #codeTool::-webkit-scrollbar-thumb:hover,
    #exchangeTool::-webkit-scrollbar-thumb:hover,
    #exchangeTool input::-webkit-scrollbar-thumb:hover,
    #exchangeTool select::-webkit-scrollbar-thumb:hover {
      background: #1b6c5a;
    }

    /* 重整鍵 */
    #resetBtn{
      position:absolute !important;
      top:6px !important;
      right:6px !important;
      background:#00683c;
      border:none;
      color:#000;
      font-weight:bold;
      border-radius:8px;
      padding:6px 10px;
      cursor:pointer;
      box-shadow:0 2px 6px rgba(0,0,0,.5);
      margin:0 !important;
    }

    /* 模式選擇按鈕 */
    #modeSelector{display:flex;gap:10px;margin-bottom:15px;}
    .mode-btn{flex:1;padding:8px 0;border:1px solid rgba(255,255,255,.3);background:rgba(255,255,255,.1);color:#fff;border-radius:6px;cursor:pointer;font-size:12px;text-shadow:0 1px 2px rgba(0,0,0,.6);box-shadow:0 2px 4px rgba(0,0,0,.4);} 
    .mode-btn.active{background:#578d80;color:#fff;font-weight:bold;font-size:13px;}

    /* 時間輸入列 */
    .time-row{margin-bottom:10px;display:none;}
    .time-row label{display:block;font-size:12px;margin-bottom:4px;text-shadow:0 1px 2px rgba(0,0,0,.5);} 
    .time-row input[type="time"]{width:45%;padding:4px;background:rgba(255,255,255,.05);border:1px solid rgba(255,255,255,.4);border-radius:4px;color:#fff;}
    .time-row input[type="time"]::-webkit-calendar-picker-indicator{filter:invert(1); opacity:1;}

    /* 控制按鈕容器 */
    #actionBtns{display:flex;gap:10px;justify-content:space-between;margin:10px 0;}
    #addEventBtn,#calculateBtn{flex:1;padding:8px 0;background:#03453b;border:none;color:#fff;font-weight:bold;border-radius:12px;cursor:pointer;box-shadow:0 2px 6px rgba(0,0,0,.5);} 
    #calculateBtn{background:#00683c;}

    #eventsList{max-height:300px;overflow-y:auto;margin-bottom:10px;}
    .event-item{display:flex;align-items:center;gap:6px;background:rgba(41,207,168,.3);padding:8px;margin:8px 0;border-radius:4px;box-shadow:0 2px 6px rgba(0,0,0,.5);flex-wrap:wrap;}
    .event-name{flex:0 0 35%;min-width:35%;padding:4px;background:transparent;border:1px solid rgba(255,255,255,.6);border-radius:3px;color:#fff;text-shadow:0 1px 1px rgba(0,0,0,.5);} 
    .event-name::placeholder{color:rgba(255,255,255,.5);} 
    .duration-group{display:flex;align-items:center;gap:4px;flex:0 0 auto;}
    .duration-group input{width:30px;padding:4px;background:transparent;border:1px solid rgba(255,255,255,.6);border-radius:3px;color:#fff;text-shadow:0 1px 1px rgba(0,0,0,.5);text-align:right;}
    .duration-group span{font-size:13px;color:#fff;text-shadow:0 1px 1px rgba(0,0,0,.5);} 
    .remove-btn{background:transparent;border:1px solid rgba(255,255,255,.6);color:#fff;padding:4px 8px;border-radius:3px;cursor:pointer;text-shadow:0 1px 1px rgba(0,0,0,.5);margin-left: auto;}  

    #result{margin-top:15px;font-weight:bold;text-align:center;text-shadow:0 1px 2px rgba(0,0,0,.7);} 

    /* 摩斯密碼工具樣式 */
    #morsePanels{display:flex;flex-direction:column;gap:14px;}
    #swapBtn,#swapBinBtn{align-self:center;padding:4px 26px;background:#216858;color:#fff;border:none;border-radius:8px;cursor:pointer;box-shadow:0 2px 6px rgba(0,0,0,.5);}
    .panel{background:rgba(41,207,168,.3);padding:12px;border-radius:6px;box-shadow:0 2px 6px rgba(0,0,0,.5);}
    .panel label{display:block;font-size:12px;margin-bottom:6px;text-shadow:0 1px 2px rgba(0,0,0,.6);}
    .panel textarea{
      width:95%;height:50px;resize:vertical;padding:8px;
      background:rgba(0,0,0,.7);border:1px solid rgba(255,255,255,.3);
      border-radius:4px;color:#fff;font-family:monospace;font-size:12px;line-height:1.4;
    }
    .panel textarea::placeholder{color:rgba(255,255,255,.45);}
    .counter{margin-top:4px;font-size:12px;color:rgba(255,255,255,.8);text-align:right;}
    #morseActions{display:flex;gap:10px;margin-bottom: 14px;justify-content:space-between;margin-top:12px;}
    #morseActions button{
      flex:1;padding:8px 0;background:#013836;border:none;color:#fff;font-weight:bold;
      border-radius:8px;cursor:pointer;box-shadow:0 2px 6px rgba(0,0,0,.5);
    }
    #morseAudioPanel input[type="range"],
    #crossTool       input[type="range"]{
      -webkit-appearance:none;
      appearance:none;
      width:100%;
      --track-h:6px;
      --thumb-sz:18px;
      --accent:#29cfa8;
      --percent:0%;
      background:linear-gradient(to right, var(--accent) var(--percent), rgba(255,255,255,.15) var(--percent));
      height:var(--track-h);
      border-radius:999px;
      outline:none;
    }
    #morseAudioPanel input[type="range"]::-webkit-slider-runnable-track,
    #crossTool       input[type="range"]::-webkit-slider-runnable-track{
      height:var(--track-h);
      background:transparent;
      border-radius:999px;
    }
    #morseAudioPanel input[type="range"]::-webkit-slider-thumb,
    #crossTool       input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none;
          width:var(--thumb-sz); height:var(--thumb-sz);
      border-radius:50%;
      background:var(--accent);
      border:2px solid rgba(0,0,0,.55);
      box-shadow:0 0 0 3px rgba(41,207,168,.2), 0 6px 14px rgba(0,0,0,.45);
      margin-top:calc((var(--track-h) - var(--thumb-sz))/2);
      transition:transform .08s ease, box-shadow .15s ease, filter .15s ease;
    }
    #morseAudioPanel input[type="range"]:hover::-webkit-slider-thumb,
    #crossTool       input[type="range"]:hover::-webkit-slider-thumb{
      transform:scale(1.06);
      box-shadow:0 0 0 4px rgba(41,207,168,.28), 0 10px 18px rgba(0,0,0,.55);
    }
    #morseAudioPanel input[type="range"]:active::-webkit-slider-thumb,
    #crossTool       input[type="range"]:active::-webkit-slider-thumb{
      transform:scale(.98);
      box-shadow:inset 0 2px 4px rgba(0,0,0,.5), 0 6px 14px rgba(0,0,0,.45);
    }
    #morseAudioPanel input[type="range"]:focus-visible,
    #crossTool       input[type="range"]:focus-visible{
      box-shadow:0 0 0 2px rgba(41,207,168,.55);
      border-radius:999px;
    }
    #morseAudioPanel input[type="range"]::-moz-range-track,
    #crossTool       input[type="range"]::-moz-range-track{
      height:var(--track-h);
      background:rgba(255,255,255,.15);
      border-radius:999px;
    }
    #morseAudioPanel input[type="range"]::-moz-range-progress,
    #crossTool       input[type="range"]::-moz-range-progress{
      height:var(--track-h);
      background:#29cfa8;
      border-radius:999px;
    }
    #morseAudioPanel input[type="range"]::-moz-range-thumb,
    #crossTool       input[type="range"]::-moz-range-thumb{
      width:var(--thumb-sz); height:var(--thumb-sz);
      border-radius:50%;
      background:#29cfa8;
      border:2px solid rgba(0,0,0,.55);
      box-shadow:0 0 0 3px rgba(41,207,168,.2), 0 6px 14px rgba(0,0,0,.45);
      transition:transform .08s ease, box-shadow .15s ease, filter .15s ease;
    }
    #morseAudioPanel input[type="range"]:hover::-moz-range-thumb,
    #crossTool       input[type="range"]:hover::-moz-range-thumb{ transform:scale(1.06); }
    #morseAudioPanel input[type="range"]:active::-moz-range-thumb,
    #crossTool       input[type="range"]:active::-moz-range-thumb{ transform:scale(.98); }
    #audioActions {
      display: flex;
      gap: 10px;
      margin-top: 20px;
    }
    .audio-row{display:flex;align-items:center;gap:10px;margin:8px 0;}
    .audio-row label{min-width:86px;font-size:12px;color:#fff;opacity:.9;}
    .audio-row input[type="range"]{flex:1;}
    .audio-row output{min-width:72px;text-align:right;color:#29cfa8;font-weight:bold;}
    #audioActions #morsePlayBtn{
      background: linear-gradient(180deg, #1a5e6e, #234c68);
      border-color: rgba(41,207,168,.6);
      text-shadow: 0 1px 2px rgba(0,0,0,.6);
      border-radius:8px;
      padding:4px 10px;
      color:#fff;
    }
    #audioActions #morsePlayBtn::before{
      content: '▶';
      font-size: 14px;
      line-height: 1;
      opacity: .95;
    }
    #audioActions #morseStopBtn{
      background: linear-gradient(180deg, #555, #2f2f2f);
      border-color: rgba(255,255,255,.15);
      border-radius:8px;
      padding:4px 10px;
      color:#fff;
    }
    #audioActions #morseStopBtn::before{
      content: '■';
      font-size: 12px;
     line-height: 1;
      opacity: .9;
    }
    /* 二進制轉換工具樣式 */
    #binaryTool textarea{width:95%;height:50px;resize:vertical;padding:8px;background:rgba(0,0,0,.7);border:1px solid rgba(255,255,255,.4);border-radius:4px;color:#fff;font-family:monospace;font-size:14px;line-height:1.4;}
    #binaryTool textarea::placeholder{color:rgba(255,255,255,.45);}
    #binaryPanels{display:flex;flex-direction:column;gap:14px;}
    #binaryActions{display:flex;gap:10px;justify-content:space-between;margin-top:12px;}
    #binaryActions button{flex:1;padding:8px 0;background:#013836;border:none;color:#fff;font-weight:bold;border-radius:8px;cursor:pointer;box-shadow:0 2px 6px rgba(0,0,0,.5);}

    /* 匯率轉換工具樣式 */
    #exchangeTool {
      width: 45%;
      margin: 0 auto;
      padding: 15px 20px;
      background: rgba(0,0,0,0.7);
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.6);
      color: #fff;
      display: flex;
      flex-direction: column;
      font-family: sans-serif;
    }
    #exchangeTool::before{ content:""; display:block; height:0; }
    #exchangeTool > h2{
      margin:0 0 6px 0 !important; font-size:13px; text-align:center;
      text-shadow:0 1px 3px rgba(0,0,0,.7); line-height:1.2;
    }
    #exchangeTool .panel{ margin-bottom:12px; }
    #exchangeTool label{display:block; font-size:14px; margin-bottom:6px; color:#fff;}
    #exchangeTool input,
    #exchangeTool select{
      width:80%; padding:8px; background:rgba(0,0,0,.7);
      border:1px solid rgba(255,255,255,.4); border-radius:4px;
      color:#fff; font-size:14px;
    }
    #exchangeActions{ display:flex; gap:10px; justify-content:space-between; margin:12px 0; }
    #exchangeActions button{
      flex:1; padding:8px 0; background:#013836; border:none;
      color:#fff; font-weight:bold; border-radius:8px;
      cursor:pointer; box-shadow:0 2px 6px rgba(0,0,0,.5);
    }
    #exchangeResult{ margin-top:10px; font-size:16px; text-align:center; color:#29cfa8; }
    #exchangeTool .exchange-row {
      display: flex;
      gap: 12px;
      margin-bottom: 12px;
    }
    #exchangeTool .exchange-item {
      flex: 1;
    }
    #exchangeTool .exchange-item label {
      display: block;
      font-size: 12px;
      margin-bottom: 4px;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }
    #exchangeTool .exchange-item select {
      width: 100%;
      padding: 6px;
      background: rgba(0,0,0,0.7);
      border: 1px solid rgba(255,255,255,0.4);
      border-radius: 4px;
      color: #fff;
      font-size: 14px;
      appearance: none;
    }
    #exchangeResultWrapper {
      margin: 8px 0;
      padding: 10px;
      background: rgba(34,69,115,0.2);
      border-radius: 4px;
      min-height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #exchangeResult {
      font-size: 15px;
      color: #a2d3df;
      font-weight: bold;
      text-shadow: 0 1px 2px rgba(0,0,0,0.7);
    }
    /* QR/條碼產生器 */
    #codeTool{
      width:45%; max-height:70vh; background:rgba(0,0,0,.7);
      margin:0 auto; padding:10px 20px; color:#fff;
      border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,.6);
      font-family:sans-serif; overflow-y:auto;
      position:relative; display:flex; flex-direction:column;
      transform:none !important; margin-top:0 !important;
    }
    #codeTool::before{
      content:""; display:block; height:0;
    }
    #codeTool > h2{
      margin:0 0 12px 0; font-size:13px; text-align:center;
      text-shadow:0 1px 3px rgba(0,0,0,.7); line-height:1.2;
    }
    #codeSettings label{
      display:flex; flex-direction:column; font-size:12px; color:#fff;
    }
    #codeSettings input[type="text"],
    #codeSettings input[type="number"],
    #codeSettings input[type="color"],
    #codeSettings select{
      margin-top:4px; padding:6px; background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.4); border-radius:4px;
      color:#fff; font-size:13px;
    }
    #codeSettings{
      display:flex; flex-wrap:wrap; gap:12px;
    }
    #codeSettings label{ width:100%; }
    #codeSettings select{
      background:rgba(0,0,0,0.7) !important;
      color:#fff !important;
    }
    #codeSettings input[type="file"] { display: none; }
    #codeSettings label.file-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 2px 8px;
      background: rgba(12, 45, 51, 0.7);
      color: #fff;
      border: none;
      border-radius: 8px;
      box-shadow: 0 3px 0 rgba(0,0,0,.35), 0 6px 12px rgba(0,0,0,.45);
      cursor: pointer;
      transition: transform .08s ease, box-shadow .12s ease, filter .12s ease;
      position: relative;
      font-size: 13px;
    }
    #generateCodeBtn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 2px 8px;
      background: rgba(3, 92, 114, 0.7);
      color: #fff;
      font-weight: bold;
      border: none;
      border-radius: 8px;
      box-shadow: 0 3px 0 rgba(0,0,0,.35), 0 6px 12px rgba(0,0,0,.45);
      cursor: pointer;
      transition: transform .08s ease, box-shadow .12s ease, filter .12s ease;
      position: relative;
      font-size: 14px;
    }
    #codeSettings label.file-btn::before {
      content: "\1F4E4";
      margin-right: 6px;
      font-size: 13px;
    }
    #codeSettings label.file-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 0 rgba(0,0,0,.4), 0 10px 18px rgba(0,0,0,.55);
      filter: brightness(1.08);
    }
    #codeSettings label.file-btn:active {
      transform: translateY(1px);
      box-shadow: inset 0 2px 4px rgba(0,0,0,.45), 0 2px 6px rgba(0,0,0,.4);
      filter: brightness(.95);
    }

    /* 單位換算器樣式 */
    #unitTool {
      width:45%; max-height:90vh; background:rgba(0,0,0,.7);
      margin:0 auto; padding:10px 20px; color:#fff;
      border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,.6);
      font-family:sans-serif; display:flex; flex-direction:column;
      overflow-y:auto; position:relative;
    }
    #unitTool::before{content:"";display:block;height:0;}
    #unitTool>h2{
      margin:0 0 12px 0;font-size:13px;text-align:center;
      text-shadow:0 1px 3px rgba(0,0,0,.7);line-height:1.2;
    }
    #unitTool .unit-row{
      display:flex;
      align-items:center;
      gap:10px;
      margin:8px 0;
    }
    #unitTool .unit-row label{
      width:80px;
      min-width:80px;
      font-size:12px;
      color:#fff;
      opacity:.9;
      text-shadow:0 1px 2px rgba(0,0,0,.5);
    }
    #unitResultWrapper{
      margin:8px 0; padding:10px;
      background:rgba(34,69,115,0.2);
      border-radius:4px; min-height:36px;
      display:flex; align-items:center; justify-content:center;
    }
    #unitResult{
      font-size:14px;       
      color: #a2d3df;
      font-weight: bold;
      text-shadow:0 1px 2px rgba(0,0,0,.7);
    }
    #unitActions{
      display:flex; gap:10px; margin-top:10px;
    }
    #unitTool .unit-io-group{
      background:rgba(60,111,159,.6);
      padding:10px;
      border-radius:10px;
      box-shadow:0 2px 10px rgba(0,0,0,.35);
      margin:10px 0 12px;
    }
    #unitTool .unit-row select,
    #unitTool .unit-row input{
      flex:0.85;
      min-width:0;
      background:rgba(0,0,0,.35);
      color:#fff;
      border-radius:6px;
      padding:8px 10px;
      outline:none;
      box-shadow:0 2px 6px rgba(0,0,0,.35) inset;
    }
    #unitTool .unit-actions{
      display:flex;
      gap:10px;
      justify-content:space-between;
      margin:10px 0 8px;
    }
    #unitTool .unit-result{
      margin-top:6px;
      background:rgba(34,69,115,.35);
      border-radius:8px;
      padding:10px 12px;
      color:#20ac8b;
      font-weight:bold;
      text-shadow:0 1px 2px rgba(0,0,0,.6);
    }
    #unitTool .unit-row label{
      width:80px;
      min-width:80px;
      font-size:12px;
      color:#fff;
      opacity:.9;
      text-shadow:0 1px 2px rgba(0,0,0,.5);
    }
    #unitActions button{
      flex:1; padding:8px 0; background:#0b5264;
      border:none; color:#fff; font-weight:bold;
      border-radius:8px; cursor:pointer;
      box-shadow:0 2px 6px rgba(0,0,0,.5);
      transition:transform .08s ease,
                 box-shadow .12s ease,
                 filter .12s ease;
    }
    #constantsPanel select {
      appearance: none;
      background: rgba(0,0,0,.7);
      color:#fff;
      border:1px solid rgba(255, 255, 255, 0.11);
      border-radius:6px;
      padding:6px 28px 6px 10px;
      outline:none;
      box-shadow:0 2px 6px rgba(0,0,0,.35) inset;
    }
    /* 常數顯示框 */
    #constantsPanel h3 { text-shadow:0 1px 2px rgba(0,0,0,.6); }
    #constantsPanel{
      margin-top:14px;
    }
    #constantsPanel h3{
      margin:0 0 10px 0;
      font-size:13px;
      text-align:center;
      color:#fff;
      opacity:.9;
      text-shadow:0 1px 2px rgba(0,0,0,.6);
    }
    #constantsPanel .const-row{
      display:flex;
      align-items:center;
      gap:10px;
      margin:8px 0;
    }
    #constantsPanel .const-row label{
      width:80px;
      min-width:80px;
      font-size:12px;
      color:#fff;
      opacity:.85;
    }
    #constantsPanel .const-row select{
      flex:1;
      min-width:0;
      background:rgba(0,0,0,.35);
      color:#fff;
      border:1px solid rgba(255,255,255,.15);
      border-radius:6px;
      padding:6px 10px;
      outline:none;
    }
    #constDisplay.const-display{
      margin-top:12px;
      background:rgba(5,23,46,.35);
      border-radius:8px;
      padding:12px;
      color:#fff;
    }
    #constDisplay .const-name{
      font-weight:bold;
      margin-bottom:6px;
    }
    #constDisplay .const-formula{
      font-size:14px;
      line-height:1.6;
    }
    #constDisplay .const-value{
      margin-top:6px;
      color:#29cfa8;
      font-weight:bold;
    }
    #unitCategory,
    #unitFrom,
    #unitTo{
      background: rgba(0,0,0,.6);
      color:#fff;
      border:1px solid rgba(255,255,255,.2);
    }
    #unitCategory option,
    #unitFrom option,
    #unitTo option{
      background-color: rgba(20,26,34,.95);
      color:#fff;
    }
    #unitCategory:checked,
    #unitFrom option:checked,
    #unitTo option:checked{ background-color:#1c3f64; }
    #unitCategory:hover,
    #unitFrom option:hover,
    #unitTo option:hover{ background-color:#255684; }
    #unitCategory:focus,
    #unitFrom:focus,
    #unitTo:focus{
      outline:none;
      box-shadow:0 0 0 2px rgba(41, 146, 207, 0.6);
    }
    #constCat,
    #constItem{
      background: rgba(0,0,0,.6);
      color:#fff;
      border:1px solid rgba(255,255,255,.2);
    }
    #constCat option,
    #constItem option{
      background-color: rgba(20, 34, 28, 0.95);
      color:#fff;
    }
    #constCat option:checked,
    #constItem option:checked{ background-color:#1c645a; }
    #constCat option:hover,
    #constItem option:hover{ background-color:#207954; }
    #constCat:focus,
    #constItem:focus{
      outline:none;
      box-shadow:0 0 0 2px rgba(41,207,168,.6);
    }
    .const-mini-table {
      width: 100%;
      border-collapse: collapse;
     font-size: 13px;
     margin-top: 6px;
    }
    .const-mini-table th,
    .const-mini-table td {
      border: 1px solid rgba(255,255,255,.15);
      padding: 6px 8px;
      text-align: center;
      white-space: nowrap;
    }
    .const-mini-table th {
      background: rgba(255,255,255,.08);
      font-weight: 600;
    }

    /* 光學十字 */
    #crossTool{
      width:45%;
      max-height:91vh;
      background:rgba(0,0,0,.7);
      margin:0 auto;
      padding:12px 16px;
      color:#fff;
      border-radius:8px;
      box-shadow:0 4px 12px rgba(0,0,0,.6);
      font-family:sans-serif;
      overflow-y:auto;
    }
    #crossTool h2{
     margin:0 0 10px 0;
      font-size:13px;
     text-align:center;
      text-shadow:0 1px 3px rgba(0,0,0,.7);
    }
    #crossTool input[readonly]{
      opacity:.85;
      pointer-events:none;
      background:rgba(255,255,255,.07);
    }
    #crossTool .cross-panel{
      background:rgba(41,207,168,.12);
      padding:10px;
      border-radius:6px;
      box-shadow:0 2px 6px rgba(0,0,0,.5);
      margin-bottom:10px;
    }
    #crossTool .cross-label{
      font-size:12px;
      margin-bottom:6px;
      opacity:.9;
    }
    #crossTool .cross-row{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    #crossTool .cross-row input{
    flex: 0 0 43px;
    width: 43px;
    min-width: 40px;
    padding: 8px 3px;
    font-size: 13px;
    }
    #crossTool input{
    flex:1;
      min-width:120px;
      background:rgba(0,0,0,.35);
      color:#fff;
      border:1px solid rgba(255,255,255,.25);
      border-radius:6px;
      padding:8px 4px;
      outline:none;
      box-shadow:0 2px 6px rgba(0,0,0,.35) inset;
    }
    #crossSVG{
      width:100%;
      height:auto;
      background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.15);
      border-radius:6px;
    }
    #crossTool .cross-size{
      display:flex;
      align-items:center;
      gap:5px;
    }    
    #crossTool .cross-label-inline{
      display:inline-block;
      margin:0;
      white-space:nowrap;
      font-size:12px;
      opacity:.9;
    }
    #crossTool .cross-size input[type="range"]{
      flex:1;
      min-width:50px;
    }
    #crossSizeVal{
      min-width:50px;
      text-align:right;
      display:inline-block;
    }
    .toric-hint{
      margin-top:8px;
      padding:8px 10px;
      border-radius:8px;
      background:rgba(255,184,0,.12);
      border:1px solid rgba(255,184,0,.35);
      color:#ffd36b;
      font-size:12px;
      line-height:1.5;
      box-shadow:0 2px 6px rgba(0,0,0,.25) inset;
    }
    #crossSVG .axis-line{ stroke:#1d9ca0; stroke-width:3; }
    #crossSVG .perp-line{ stroke:#a2d3df; stroke-width:3; }
    #labAxis,#labPerp{ text-anchor:middle; dominant-baseline:middle; }
    #crossSVG .axis-line,#crossSVG .perp-line{ vector-effect:non-scaling-stroke; }
    #labAxis{ fill:#1d9ca0; font-size:12px; }
    #labPerp{ fill:#a2d3df; font-size:12px; }
    #crossTool .toric-panel{ margin-top:12px; background: rgba(41,207,168,.14); box-shadow: 0 2px 6px rgba(0,0,0,.25) inset; }
    #crossTool .toric-row{ display:flex; align-items:center; gap:10px; }
    #crossTool .toric-row input,
    #crossTool .toric-row select{
      flex:1; min-width:40px;
      background:rgba(0,0,0,.35);
      color:#fff; border:1px solid rgba(255,255,255,.15);
      border-radius:6px; padding:6px 2px;
    }
    #crossTool .toric-row .toric-lab{ white-space:nowrap; font-size:12px; opacity:.9; }
    #crossTool .toric-note{ margin-top:8px; font-size:12px; opacity:.8; }
    #crossTool .toric-out{display:flex;gap:14px;align-items:flex-start;flex-wrap:wrap}
    #crossTool .toric-sep{align-self:center;opacity:.8}
    #crossTool .toric-line{background:transparent;border:1px solid rgba(255,255,255,.18); border-radius:8px;padding:10px 12px}
    #crossTool .toric-line.active{border-color:#29cfa8;box-shadow:0 0 0 2px rgba(41,207,168,.2) inset}
    #crossTool .frac{min-width:240px;display:flex;flex-direction:column;align-items:center}
    #crossTool .frac .num,#crossTool .frac .den{white-space:nowrap;color:#fff}
    #crossTool .frac .bar{width:100%;border-top:1px solid rgba(255,255,255,.35);margin:4px 0}
    #crossTool .arc-tag{color:#29cfa8;font-weight:700}
    #toricMinusLine, #toricPlusLine { position: relative; }
    #toricMinusLine::before, #toricPlusLine::before{
      content: attr(data-badge);
      position: absolute;
      top: 6px; left: 10px;
      padding: 2px 8px;
      font-size: 11px;
      color: #e7fff7;
      background: rgba(5,110,100,.25);
      border: 1px solid rgba(41,207,168,.2);
      border-radius: 999px;
      pointer-events: none;
      display: none;
    }
    #toricMinusLine.show-badge::before,
    #toricPlusLine.show-badge::before{ display: block; }
    #toricPlusLine.active::before,
    #toricMinusLine.active::before{
      background: rgba(41,207,168,.15);
      border-color: rgba(41,207,168,.29);
    }
    #toricMinusLine.show-badge, 
    #toricPlusLine.show-badge{
      padding-top: 38px;    
    }
    #toricBackPanel.toric-panel{
      margin-top:14px;
      background:rgba(75, 93, 99, 0.2);
      border:1px solid rgba(255,255,255,.12);
      border-radius:8px;
      padding:12px;
    }
    #toricBackPanel .toric-title{
      margin:0 0 8px 0; font-size:13px; color:#fff; opacity:.9; text-align:center;
    }
    #toricBackPanel .toric-row{ display:flex; gap:10px; align-items:center; margin-bottom:8px; }
    #toricBackPanel select, 
    #toricBackPanel input{
      background:rgba(0,0,0,.35); color:#fff; border:1px solid rgba(255,255,255,.18);
      border-radius:6px; padding:6px 4px; outline:none; min-width:0 !important; 
    }
    #toricBackPanel .axis-input{ width:30px; text-align:center; }
    #toricBackPanel .num-input{ width:30px; text-align:right; }
    #toricBackPanel .tb-frac .line{ display:flex; align-items:center; gap:6px; flex-wrap:wrap; }
    #toricBackPanel .tb-out{ margin-top:10px; display:grid; gap:8px; }
    #toricBackPanel .tb-out .mono{ width:100%; background:rgba(255,255,255,.06); }
    #toricBackPanel .tb-frac{ display:flex; flex-direction:column; gap:6px;}
    #toricBackPanel .tb-frac .num .line {gap: 4px!important;}
    #toricBackPanel .tb-frac .num .axis-input { width: 48px!important;  padding: 4px 4px!important;}
    #toricBackPanel .tb-frac .num .num-input { width: 68px!important;  padding: 4px 4px!important;}
    #toricBackPanel .tb-frac .den .line input.num-input { width: 68px!important;}
    #toricBackPanel .tb-frac .num{ order:1; }
    #toricBackPanel .tb-frac .bar{ order:2; height:1px; background:rgba(255,255,255,.25); }
    #toricBackPanel .tb-frac .den{ order:3; }
    .mini-sign-btn{
      margin-left:2px; padding:4px 6.5px;
      font-size:12px; line-height:1;
      color:#eafff7; background:rgba(41,207,168,.18);
      border:1px solid rgba(41,207,168,.45);
      border-radius:6px; cursor:pointer; user-select:none;
      transition:transform .08s ease, box-shadow .15s ease, background .15s ease;
    }
    .mini-sign-btn:hover{ background:rgba(41,207,168,.28); box-shadow:0 2px 8px rgba(0,0,0,.3); }
    .mini-sign-btn:active{ transform:scale(.98); }
    #toricBackPanel .tb-frac.back-mode .den{ order:1; }
    #toricBackPanel .tb-frac.back-mode .bar{ order:2; }
    #toricBackPanel .tb-frac.back-mode .num{ order:3; }
    .toric-hint.is-error{
      display:block !important;
      margin-top:8px;
      padding:8px 10px;
      border-radius:8px;
      background:rgba(255,184,0,.12);
      border:1px solid rgba(255,184,0,.35);
      color:#ffd36b;
      font-size:12px;
      line-height:1.5;
    }
    .cl-panel{ background: rgba(41,207,168,.12); border: 1px solid rgba(255,255,255,.08); border-radius: 10px; padding: 12px; box-shadow: 0 6px 16px rgba(0,0,0,.35); backdrop-filter: blur(2px);}  
    .cl-title { margin: 0 0 10px 0; font-size: 13px; text-align: center; color: #fff; opacity: .9;}
    .cl-row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-top: 10px;}
    .cl-row + .cl-row{ margin-top:10px; }
    .cl-field{ display:flex; align-items:center; gap:6px; }
    .cl-field--right{ margin-left:auto!important; }
    .cl-title{ text-align: left !important; margin: 0 0 10px 0; font-size: 13px; color: #fff; opacity: .9;}
    .cl-label,.cl-unit{ color:#fff; opacity:.85; font-size:12px; }
    .cl-input,.cl-select,.cl-output { background: rgba(0,0,0,.25); color: #fff; border: 1px solid rgba(255,255,255,.15); border-radius: 6px; padding: 8px;}
    .cl-select--short  { width: 80px; }
    #clPanel .cl-field input#clVD{ flex: 0 0 44px !important; width: 44px !important; min-width: 44px !important; max-width: 44px !important;} 
    .cl-output-pair{ align-items: stretch; }
    .cl-group{ display:flex; align-items:center; gap:10px; flex:1; min-width:260px; }
    .cl-output-label{ min-width:120px; color:#fff; opacity:.9; display:flex; align-items:center; }
    .cl-output{ flex:1; }
    .cl-output-sep{ opacity:.6; padding:0 6px; }
    .is-invalid{
    outline:2px solid #ffb84d !important;
    box-shadow:0 0 0 2px rgba(255,184,0,.35) inset !important;
    }
    #tbMsg{
      margin-top:8px; padding:8px 10px;
      border-radius:8px;
      background:rgba(255,184,0,.12);
      border:1px solid rgba(255,184,0,.35);
      color:#ffd36b; font-size:12px; line-height:1.5;
    }
    #toricBackPanel .tb-form-row{
      display:flex; align-items:center; gap:10px;margin-bottom:8px;
    }
    #toricBackPanel .tb-form-row > label{ min-width:48px; }
    #tbClearBtn{
      margin-left:auto;
      padding:6px 12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,.22);
      background:rgba(255,255,255,.06);
      color:#fff;
      cursor:pointer;
      transition:transform .08s ease, box-shadow .15s ease, background .15s ease;
    }
    #tbClearBtn:hover{
     background:rgba(255,255,255,.12);
      box-shadow:0 4px 12px rgba(0,0,0,.25) inset;
    }
    #tbClearBtn:active{ transform:scale(.98); }

    /* 稜鏡轉換 */
    #tool8Container .panel.prism-panel{
      background: rgba(5,23,46,.35);
      border: 1px solid rgba(255,255,255,.08);
     border-radius: 10px;
     padding: 12px;
     margin-top: 14px;
   }
   #tool8Container .panel-title{
     font-size: 14px; color:#dff; opacity:.92; margin-bottom:8px;
   }
   #tool8Container .subhead{
     margin:10px 0 6px; font-size:12px; color:#9fe; opacity:.9;
   }
   #tool8Container .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
   #tool8Container .row.g label{ display:flex; align-items:center; gap:6px; }
   #tool8Container input, #tool8Container select{
     background: rgba(0,0,0,.28); color:#fff; border:1px solid rgba(255,255,255,.15);
     border-radius:6px; padding:6px 8px;
   }
  #tool8Container .btn{
    padding:6px 10px; border-radius:6px; border:1px solid rgba(41,207,168,.5);
    background:rgba(41,207,168,.2); color:#bff; cursor:pointer;
  }
  #tool8Container .btn:hover{
    padding:6px 10px; border-radius:6px; border:1px solid rgba(55,237,198,.5);
    background:rgba(55,237,198,.2); color:#bff; cursor:pointer;
  }
  #tool8Container .result-line{
    width:80%; min-height:28px; display:flex; align-items:center;
    padding:6px 8px; background:rgba(0,0,0,.22); border:1px solid rgba(255,255,255,.12);
    border-radius:6px; color:#10bedd;
  }
  #tool8Container .mini-plot{ margin-top:10px; }
  #tool8Container .mini-plot svg{ width:100%; height:160px; }
  #tool8Container .mini-plot .axis{ stroke:rgba(255,255,255,.25); stroke-width:.8; }
  #tool8Container .mini-plot .dot{ fill:#29cfa8; }
  #tool8Container .mini-plot .vec{ stroke:#29cfa8; stroke-width:2; }
  #tool8Container .mini-plot-legend{ font-size:11px; color:#9fe; opacity:.85; margin-top:4px; }
  .prism-tool .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .prism-tool .row.two-cols{align-items:flex-end}
  .prism-tool .row.two-cols .col{flex:1;min-width:220px;display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .prism-tool label{display:flex;align-items:center;gap:6px}
  .prism-tool .row label > input,.prism-tool .row label > select {flex: 0 0 auto; width: auto;}
  #prS, #prC {min-width: 70px;}
  #tool8Container #prAxis { width: 36px !important; max-width: 36px !important; min-width: 36px !important; flex: 0 0 36px !important; text-align: center;}
  #tool8Container #mvVmm,#tool8Container #mvHmm{ width: 48px !important; max-width: 48px !important; min-width: 48px !important; flex: 0 0 48px !important; text-align: right;}
  #tool8Container #rvVpd,#tool8Container #rvHpd,#tool8Container #pvH,#tool8Container #pvH,#tool8Container #pvV,#tool8Container #pvR,#tool8Container #pvTheta{ width: 55px !important; max-width: 55px !important; min-width: 55px !important; flex: 0 0 55x !important; text-align: right;}
  .prism-panel{background:rgba(10,30,35,.35);border:1px solid rgba(255,255,255,.08);border-radius:10px;padding:12px;margin-top:10px}
  .prism-panel .panel-title{font-size:13px;color:#cfe;opacity:.9;margin-bottom:8px}
  .prism-panel .subttl{min-width:72px;color:#aff;font-size:12px}
  .prism-tool .btn-primary{padding:8px 14px;border-radius:8px;border:1px solid rgba(41,207,168,.4);background:rgba(41,207,168,.2);color:#eafff7;cursor:pointer}
  .prism-tool .btn-primary.wide{margin-left:auto}
  .prism-tool .answer{margin-top:10px;color:#eafff7}
  .pr-plot{width:100%;max-width:480px;background:rgba(255,255,255,.04);border-radius:6px;margin-top:8px}

    /* 追加覆寫 */
    .time-row{display:flex;align-items:center;gap:8px;margin-bottom:10px;}
    .time-row label{margin:0;width:auto;}
    .time-output{margin-left:auto;font-size:12px;color:#29cfa8;font-weight:bold;text-shadow:0 1px 2px rgba(0,0,0,.7);} 
    
    /* 按鈕 */
    #audioActions button,
    #generateCodeBtn,
    #downloadPngBtn,
    #downloadJpgBtn,
    #toolSelector button,
    .mode-btn,
    .unit-actions button,
    #unitTool button,
    #addEventBtn,
    #calculateBtn,
    #resetBtn,
    #swapBtn,
    #swapBinBtn{
      position: relative;
      transition: transform .08s ease, box-shadow .12s ease, filter .12s ease;
      box-shadow: 0 3px 0 rgba(0,0,0,.35), 0 6px 12px rgba(0,0,0,.45);
    }
    #audioActions button:hover,
    #morseActions button:hover,
    #exchangeActions button:hover,
    #binaryActions button:hover,
    #generateCodeBtn:hover,
    #downloadPngBtn:hover,
    #downloadJpgBtn:hover,
    #toolSelector button:hover,
    .mode-btn:hover,
    .unit-actions button:hover,
    #unitTool button:hover,
    #addEventBtn:hover,
    #calculateBtn:hover,
    #resetBtn:hover,
    #unitActions button:hover,
    #swapBtn:hover,
    #swapBinBtn:hover{
      transform: translateY(-2px);
      box-shadow: 0 5px 0 rgba(0,0,0,.4), 0 10px 18px rgba(0,0,0,.55);
      filter: brightness(1.08);
    }

    #audioActions button:active,
    #morseActions button:active,
    #exchangeActions button:active,
    #binaryActions button:active,
    #generateCodeBtn:active,
    #downloadPngBtn:active,
    #downloadJpgBtn:active,
    #toolSelector button:active,
    .mode-btn:active,
    .unit-actions button:active,
    #unitTool button:active,
    #addEventBtn:active,
    #calculateBtn:active,
    #unitActions button:active,
    #resetBtn:active,
    #swapBtn:active,
    #swapBinBtn:active{
      transform: translateY(1px);
      box-shadow: inset 0 2px 4px rgba(0,0,0,.45), 0 2px 6px rgba(0,0,0,.4);
      filter: brightness(.95);
    }
    /* ==== 手機版調整（<= 768px）==== */
    @media (max-width:768px){
      body{ overflow:auto; }
      #toolSelector{ padding:15px 0 }
      #toolSelector button{margin:0 3px;padding:11px 12px;font-size:13px;; flex: 0 0 22.5%; }
      #crossTool{ width:85vw; max-height:85vh; padding:16px 18px; }
      #crossTool input{ min-width:80px; }
      .prism-tool .btn-primary.wide{ margin-left:0 !important; }
      .cl-output-pair{ flex-direction: column; gap:6px; }
      .cl-output-sep{ display:block; text-align:center; margin:4px 0; }
      #clToricOut,#clSphOut{ flex: 1 1 100% !important; width: 100% !important; }
      .cl-row--output { flex-direction: column; align-items: stretch; gap: 6px; }
      #tool8Container .row{ gap:8px !important; }
      #toricPanel .unit-row input,#crossPanel .unit-row input{ flex: 0 0 auto; width: auto; }
      #kA, #kA2, #mA, #pA{ flex: 0 0 26px !important;  width: 26px !important;  min-width: 26px !important;  max-width: 26px !important; }
      #kD1, #kD2{ flex: 0 0 40px !important;  width: 40px !important;  min-width: 40px !important;  max-width: 40px !important; }
      #timeTool,#morseTool,#binaryTool,#codeTool,#exchangeTool,#unitTool{ width:84vw;max-height:85vh;padding:16px 18px;transform:none;margin:10px auto; }

      /* 捲軸高度調整 */
      #eventsList{max-height:40vh;}
      .unit-row label,#constantsPanel .const-row label{ width:75px; min-width:75px; }
      .time-row{gap:6px;}
      .time-row input[type="time"]{width:45%;}
      .time-output{font-size:12px;}
      .mode-btn{font-size:13px;}
      .mode-btn.active{font-size:13px;}
      .panel textarea{width:100%;box-sizing:border-box;}
      .event-name{flex:0 0 22%;min-width:22%;}

      /* 摩斯工具 textarea 放大 */
      #morsePanels.panel textarea{width:100%;height:120px;}
      #swapBtn{padding:2px 22px;}
    }

    /* 極小螢幕（<=480px）*/
    @media (max-width:480px){
      #toolSelector button{font-size:10px;padding:7px 10px;}
      #timeTool,#morseTool{padding:14px 16px;}
      .mode-btn{font-size:12px;}
      .mode-btn.active{font-size:14px;}
      .duration-group input{width:50px;}
      #crossTool{ padding:14px 16px; }
      #crossTool input{ min-width:100px; }
    }
  </style>
</head>
<body>
  <canvas id="fishCanvas"></canvas>
  <div id="toolNav">
    <button id="prevBtn" class="nav-arrow">
      <svg viewBox="0 0 24 24"><polyline points="15,18 9,12 15,6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
    </button>
    <div id="toolSelector">
      <button id="tool1Btn" class="active">時間管理</button>
      <button id="tool6Btn">單位換算</button>
      <button id="tool7Btn">光學十字</button>
      <button id="tool8Btn">稜鏡轉換</button>
      <button id="tool5Btn">QR／條碼</button>
      <button id="tool4Btn">匯率轉換</button>
      <button id="tool2Btn">摩斯電碼</button>
      <button id="tool3Btn">轉二進制</button>
    </div>
    <button id="nextBtn" class="nav-arrow">
      <svg viewBox="0 0 24 24"><polyline points="9,18 15,12 9,6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
    </button>
  </div>
  <!-- 時間管理工具 -->
  <div id="tool1Container" class="tool-container active">
    <div id="timeTool">
      <button id="resetBtn" title="重整">↻</button>
      <h2>時間管理工具</h2>
      <div id="modeSelector">
        <button class="mode-btn active" data-mode="arrive">何時出發</button>
        <button class="mode-btn" data-mode="depart">何時到達</button>
      </div>
      <div class="time-row" id="rowStart">
        <label>開始時間</label>
        <input type="time" id="startTime" />
        <span class="time-output" id="calcEndOut"></span>
      </div>
      <div class="time-row" id="rowTarget">
        <label>目標時間</label>
        <input type="time" id="targetTime" />
        <span class="time-output" id="calcDepartOut"></span>
      </div>
      <div id="eventsList"></div>
      <div id="actionBtns">
        <button id="addEventBtn">新增行程</button>
        <button id="calculateBtn">計算時間</button>
      </div>
      <div id="result"></div>
    </div>
  </div>

  <!-- 摩斯電碼翻譯器 -->
  <div id="tool2Container" class="tool-container">
    <div id="morseTool">
      <h2>摩斯電碼翻譯器</h2>
      <div id="morsePanels">
        <div class="panel">
          <label for="textInput">英文 / 文字輸入</label>
          <textarea id="textInput" placeholder="輸入英文、數字或符號..."></textarea>
          <div class="counter" id="textCount">0 字元</div>
        </div>
        <button id="swapBtn" title="交換上下內容">⇅ 交換</button>
        <div class="panel">
          <label for="morseInput">摩斯碼輸入（用 . - 和 / 或空白分隔）</label>
          <textarea id="morseInput" placeholder="例如：.... . .-.. .-.. --- / .-- --- .-. .-.. -.."></textarea>
          <div class="counter" id="morseCount">0 符號</div>
        </div>
      </div>
      <div id="morseActions">
        <button id="copyTextBtn" data-copy-target="textInput">複製文字</button>
        <button id="copyMorseBtn" data-copy-target="morseInput">複製摩斯</button>
        <button id="clearAllBtn">清除</button>
      </div>
      <div id="morseAudioPanel" class="panel">
        <div class="audio-row">
          <label for="morseWpm">速度</label>
          <input id="morseWpm" type="range" min="5" max="40" value="22" step="1">
          <output id="morseWpmOut">20</output>
        </div>
      <div class="audio-row">
        <label for="morseFreq">音頻</label>
        <input id="morseFreq" type="range" min="300" max="1000" value="700" step="10">
        <output id="morseFreqOut">600 Hz</output>
      </div>
      <div class="audio-row">
        <label for="morseFarn">字距</label>
        <input id="morseFarn" type="range" min="1" max="4" step="0.1" value="1">
        <output id="morseFarnOut">1.00×</output>
      </div>
      <div class="audio-row">
        <label for="morseVol">音量</label>
        <input id="morseVol" type="range" min="0" max="1" value="0.3" step="0.05">
        <output id="morseVolOut">0.30</output>
      </div>

      <div id="audioActions">
        <button id="morsePlayBtn">播放電碼</button>
        <button id="morseStopBtn">停止播放</button>
      </div>
    </div>
  </div>
  </div>

  <!-- 二進制轉換 -->
  <div id="tool3Container" class="tool-container">
    <div id="binaryTool">
      <h2>二進制轉換器</h2>
      <div id="binaryPanels">
        <div class="panel">
          <label for="decimalInput">十進制輸入</label>
          <textarea id="decimalInput" placeholder="輸入數字..."></textarea>
        </div>
        <button id="swapBinBtn">⇅ 交換</button>
        <div class="panel">
          <label for="binaryInput">二進制輸入</label>
          <textarea id="binaryInput" placeholder="輸入 0/1..."></textarea>
        </div>
      </div>
      <div id="binaryActions">
        <button id="copyDecBtn"   data-copy-target="decimalInput">複製十進制</button>
        <button id="copyBinBtn"   data-copy-target="binaryInput">複製二進制</button>
        <button id="clearBinBtn">清除</button>
      </div>
    </div>
  </div>

  <!-- 匯率轉換 -->
  <div id="tool4Container" class="tool-container">
    <div id="exchangeTool">
      <h2>匯率轉換器</h2>
      <div class="panel">
        <label for="amountInput">金額</label>
        <input type="number" id="amountInput" placeholder="輸入金額" min="0" step="any" />
      </div>
      <div class="exchange-row">
        <div class="exchange-item">
          <label for="baseCurrency">原幣別</label>
          <select id="baseCurrency"></select>
        </div>
        <div class="exchange-item">
          <label for="targetCurrency">目標幣別</label>
          <select id="targetCurrency"></select>
        </div>
      </div>
      <div id="exchangeResultWrapper">
        <span id="exchangeResult"></span>
      </div>
      <div id="exchangeActions">
        <button id="convertBtn">轉換</button>
        <button id="copyExchangeBtn" data-copy-target="exchangeResult">複製結果</button>
        <button id="clearExchangeBtn">清除</button>
      </div>
      <div id="exchangeTimestamp" style="
          text-align: right;
          color: #ccc;
          font-size: 12px;
          margin-top: 6px;
      ">
        資料時間：--/--/-- --:--
      </div>
    </div>
  </div>
  <div id="tool5Container" class="tool-container">
    <div id="codeTool">
      <h2>QR／條碼產生器</h2>
      <div id="codeSettings">
        <label>模式
          <select id="codeType">
            <option value="qrcode">QR Code</option>
            <option value="barcode">條碼 (CODE128)</option>
          </select>
        </label>
        <label>文字／網址
          <input type="text" id="codeText" placeholder="輸入文字或網址" />
        </label>
        <label style="flex:0 0 20%;">
          尺寸 (px)
          <input type="number" id="codeSize" value="200" min="50" />
        </label>
        <label style="flex:0 0 8%;">
          前景色
          <input type="color" id="codeColor" value="#000000" />
        </label>
        <label style="flex:0 0 8%;">
          背景色
          <input type="color" id="codeBgColor" value="#ffffff" />
          </label>
        <label for="codeLogo" class="file-btn" style="flex:0 0 20%;"> 上傳 Logo</label>
        <input type="file" id="codeLogo" accept="image/*" style="display:none;" />
        <button id="generateCodeBtn" style="flex:0 0 20%;">生成</button>
      </div>
      <canvas id="codeCanvas" style="display:block;margin:0 auto 16px;"></canvas>
      <div id="downloadButtons" style="display:flex;gap:10px;justify-content:center;">
        <button id="downloadPngBtn" style="flex:1;padding:8px;border:none;border-radius:4px;background:#2F5C3B;color:#fff;cursor:pointer;">
          下載 PNG
        </button>
        <button id="downloadJpgBtn" style="flex:1;padding:8px;border:none;border-radius:4px;background:#2F5C3B;color:#fff;cursor:pointer;">
          下載 JPG
        </button>
      </div>
    </div>
  </div>
  <div id="tool6Container" class="tool-container">
    <div id="unitTool">
      <h2>單位換算</h2>
      <div class="unit-row">
        <label for="unitCategory">類型</label>
        <select id="unitCategory">
          <option value="acuity">視力</option>
          <option value="nearva">近距視力</option>
          <option value="rk">RK值</option>
          <option value="distance">距離</option>
          <option value="weight">重量</option>
          <option value="volume">容積</option>
          <option value="area">面積</option>
          <option value="temperature">溫度</option>
          <option value="angle">角度</option>
          <option value="time">時間</option>
          <option value="shoe">鞋碼</option>
        </select>
      </div>
      <div class="unit-io-group">
        <div class="unit-row">
          <label for="unitFrom">從</label>
          <select id="unitFrom"></select>
        </div>
        <div class="unit-row">
          <label for="unitTo">到</label>
          <select id="unitTo"></select>
        </div>
      </div>
      <div class="unit-row">
        <label for="unitValue">數值</label>
        <input type="number" id="unitValue" placeholder="輸入數值" />
      </div>
      <div id="unitResultWrapper">
        <span id="unitResult"></span>
      </div>
      <div id="unitActions">
        <button id="convertUnitBtn">轉換</button>
        <button id="clearUnitBtn">清除</button>
      </div>
      <div id="constantsPanel" class="panel">
        <h3>公式/常數速查</h3>
        <div class="const-row">
          <label for="constCat">主類別</label>
          <select id="constCat"></select>
         </div>
        <div class="const-row">
          <label for="constItem">子項目</label>
          <select id="constItem"></select>
        </div>
        <div id="constDisplay" class="const-display">
          <div id="constName" class="const-name"></div>
          <div id="constFormula" class="const-formula"></div>
          <div id="constValue" class="const-value"></div>
        </div>
      </div>
    </div>
  </div>
  <div id="tool7Container" class="tool-container">
    <div id="crossTool">
      <h2>光學十字轉換器（ 規則性散光 ）</h2>
      <div class="cross-panel">
        <div class="cross-label">正/負柱鏡表示</div>
        <div class="cross-row">
          <input id="pS" type="text" step="0.25" placeholder="S">
          <span>DS /</span>
          <input id="pC" type="text" step="0.25" placeholder="C">
          <span>DC x </span>
          <input id="pA" type="number" step="1" min="0" max="180" placeholder="軸">
        </div>
      </div>
      <div class="cross-panel">
        <div class="cross-label">正/負柱鏡表示</div>
        <div class="cross-row">
          <input id="mS" type="number" step="0.25" placeholder="S" readonly>
          <span>DS /</span>
          <input id="mC" type="number" step="0.25" placeholder="C" readonly>
          <span>DC x </span>
          <input id="mA" type="number" step="1" min="0" max="180" placeholder="軸" readonly>
        </div>
      </div>
      <div class="cross-panel">
        <div class="cross-label">子午線表示</div>
        <div class="cross-row">
          <input id="kD1" type="text" step="0.25" placeholder="D">
          <span>D @</span>
          <input id="kA"  type="number" step="1" min="0" max="180" placeholder="軸">
          <span>∕</span>
        </div>
        <div class="cross-row">
          <input id="kD2" type="text" step="0.25" placeholder="D">
          <span>D @</span>
          <input id="kA2" type="number" step="1" min="0" max="180" placeholder="軸" readonly>
        </div>
      </div>
      <div class="cross-panel">
        <div class="cross-label">光學十字</div>
        <div class="cross-panel">
          <div class="cross-row cross-size">
            <label for="crossSize" class="cross-label-inline">調整大小</label>
            <input id="crossSize" type="range" min="20" max="100" value="60" step="5">
            <span id="crossSizeVal">60%</span>
          </div>
        </div>
        <svg id="crossSVG" viewBox="0 0 240 240">
          <defs>
            <marker id="arrow" markerWidth="6" markerHeight="6" refX="3" refY="3" orient="auto">
              <circle cx="3" cy="3" r="1" fill="#0C4743"></circle>
            </marker>
          </defs>
          <g transform="translate(120,120)">
            <g id="crossG" transform="rotate(0)">
              <line class="axis-line" x1="-90" y1="0" x2="90" y2="0" marker-start="url(#arrow)" marker-end="url(#arrow)"></line>
              <line class="perp-line" x1="0" y1="-90" x2="0" y2="90" marker-start="url(#arrow)" marker-end="url(#arrow)"></line>
            </g>
            <text id="labAxis" x="0" y="-10"></text>
            <text id="labPerp" x="0" y="-10"></text>
          </g>
        </svg>
      </div>
      <div id="clPanel" class="panel cl-panel">
        <h3 class="cl-title">隱形眼鏡轉換</h3>
          <div class="cl-row cl-head">
            <label class="cl-field">
              <span class="cl-label">頂點距(VD)</span>
              <input id="clVD" type="number" min="0" step="0.5" value="12">
              <span class="cl-unit">mm</span>
            </label>
            <label class="cl-field cl-field--right">
              <span class="cl-label">值捨入：</span>
              <select id="clStep" class="cl-select cl-select--short">
                <option value="0.25">0.25 D</option>
                <option value="0.50">0.50 D</option>
                <option value="1.00">1.00 D</option>
              </select>
            </label>
          </div>
          <div class="cl-row cl-row--output cl-output-pair">
            <div class="cl-group">
              <label class="cl-output-label">散光隱眼處方</label>
              <input id="clToricOut" type="text" class="cl-output" readonly>
            </div>
            <span class="cl-output-sep"></span>
            <div class="cl-group">
              <label class="cl-output-label">無散光（等價球面）</label>
              <input id="clSphOut" type="text" class="cl-output" readonly>
            <span class="cl-output-sep"></span>
            </div>
          </div>
        </div>
      <div class="panel toric-panel">
        <div class="cross-label" style="margin-bottom:8px;">環曲面表示法</div>
        <div class="toric-row">
          <label class="toric-lab">設定球弧</label>
          <input id="toricSphere" type="number" min="0" step="0.25" inputmode="decimal" placeholder="?D(絕對值)">
          <label class="toric-lab">球弧設定於</label>
          <select id="toricLoc">
          <option value="front">前表面</option>
          <option value="back">後表面</option>
          </select>
        </div>
        <div class="toric-note">基弧／正交弧：絕對值較小者為基弧</div>
        <div class="toric-out">
          <div id="toricMinusLine" class="toric-line"></div>
          <div id="toricPlusLine"  class="toric-line"></div>
          <div id="toricHint" class="toric-hint" style="display:none;"></div>
        </div>
      </div>
      <div id="toricBackPanel" class="toric-panel">
        <h3 class="toric-title">環曲面表示 → 正/負柱鏡表示</h3>
          <div class="tb-row tb-form-row">
            <label>形式</label>
              <select id="tbForm">
              <option value="front">正散形式（前表散光）</option>
              <option value="back">負散形式（後表散光）</option>
            </select>
          <button id="tbClearBtn" type="button" class="tb-clear-btn" aria-label="清除本區欄位">清除</button>
        </div>
        <div class="frac tb-frac">
          <div class="num">
            <div class="line">
              <input id="tbBase"  class="num-input" type="number" step="0.25" placeholder="基弧">
              <span>DC×</span>
              <input id="tbAxis1" class="axis-input" type="number" min="1" max="180" step="1" placeholder="軸">
              <span> ／ </span>
              <input id="tbCross" class="num-input" type="number" step="0.25" placeholder="正交弧">
              <span>DC×</span>
              <input id="tbAxis2" class="axis-input" type="number" min="1" max="180" step="1" placeholder="軸">
            </div>
          </div>
          <div class="bar"></div>
          <div class="den">
            <div class="line">
              <input id="tbSphere" class="num-input" type="number" step="0.25" placeholder="球弧">
              <span>DS</span>
            </div>
          </div>
        </div>
        <div id="tbMsg" style="display:none"></div>
        <div class="tb-out">
          <label>負柱鏡形式：
            <input id="tbMinusOut" type="text" class="mono" readonly>
          </label>
          <label>正柱鏡形式：
            <input id="tbPlusOut"  type="text" class="mono" readonly>
          </label>
        </div>
      </div>  
    </div>  
  </div>
  <div id="tool8Container" class="tool-container">
    <div id="crossTool">
      <h2>稜鏡換算</h2>
      <div class="panel prism-panel">
        <div class="panel-title">稜鏡估量（Prentice Rule）</div>
          <div class="row rx-row">
            <label>眼別
              <select id="prEye">
                <option value="OD">OD</option>
                <option value="OS">OS</option>
              </select>
            </label>
            <label>S
              <select id="prS"></select>
            </label>
            <label>C
              <select id="prC"></select>
            </label>
            <label>Axis
             <input id="prAxis" type="text" inputmode="numeric" value="180" class="axis3">
            </label>
          </div>
        <div class="panel prism-panel">
          <div class="panel-title">移心稜鏡量（指定光心位移 → 產生稜鏡）</div>
          <div class="row two-cols">
            <div class="col">
              <div class="subttl">垂直位移</div>
              <label>方向
                <select id="mvVDir">
                  <option value="up">上(Up)</option>
                  <option value="down">下(Down)</option>
                </select>
              </label>
              <label>距離
                <input id="mvVmm" type="number" step="0.1" value="0">mm
              </label>
            </div>
            <div class="col">
              <div class="subttl">水平位移</div>
              <label>方向
                <select id="mvHDir">
                  <option value="temporal">顳(Temporal)</option>
                  <option value="nasal">鼻(Nasal)</option>
                </select>
              </label>
              <label>距離
                <input id="mvHmm" type="number" step="0.1" value="0">mm
              </label>
            </div>
            <button id="btnPrCalc" class="btn">計算稜鏡</button>
          </div>
          <div class="answer" id="prAnsForward"></div>
          <canvas id="prPlotF" class="pr-plot" width="420" height="220"></canvas>
        </div>
        <div class="panel prism-panel">
          <div class="panel-title">移心稜鏡量（指定稜鏡 → 所需光心位移）</div>
          <div class="row two-cols">
            <div class="col">
              <div class="subttl">垂直稜鏡</div>
              <label>稜鏡量(△)
                <input id="rvVpd" type="number" step="0.1" value="0">
              </label>
              <label>基底
                <select id="rvVbase">
                  <option value="BU">BU</option>
                  <option value="BD">BD</option>
                </select>
              </label>
            </div>
            <div class="col">
              <div class="subttl">水平稜鏡</div>
              <label>稜鏡量(△)
                <input id="rvHpd" type="number" step="0.1" value="0">
              </label>
              <label>基底
                <select id="rvHbase">
                  <option value="BO">BO</option>
                  <option value="BI">BI</option>
                </select>
              </label>
            </div>
            <button id="btnPrRev" class="btn">計算位移</button>
          </div>
        <div class="answer" id="prAnsReverse"></div>
          <canvas id="prPlotR" class="pr-plot" width="420" height="220"></canvas>
        </div>
      </div>
      <div class="panel prism-panel">
        <div class="panel-title">稜鏡合成 / 分解（V/H 轉換 360°表示）</div>
        <div class="subhead">水平/垂直 → 角度</div>
          <div class="row">
            <label>眼別
              <select id="pvEyeC">
                <option value="OD">OD</option>
                <option value="OS">OS</option>
              </select>
            </label>
          </div>
          <div class="row">
            <label>水平量(△)<input id="pvH" type="text" step="0.1" placeholder="稜鏡量"></label>
            <label>水平基底
              <select id="pvHbase">
                <option value="BI">BI</option>
                <option value="BO">BO</option>
              </select>
            </label>
          </div>
          <div class="row">
            <label>垂直量(△)<input id="pvV" type="text" step="0.1" placeholder="稜鏡量"> </label>
            <label>垂直基底 
              <select id="pvVbase">
                <option value="BU">BU</option>
                <option value="BD">BD</option>
              </select>
            </label>
          </div>
          <div class="row">
            <button id="pvCombineBtn" class="btn" style="margin:6px 0;">合成稜鏡</button>
          </div>
          <div id="pvCombineOut" class="result-line"></div>
          <div class="mini-plot"><svg viewBox="-80 -80 160 160">
            <line x1="-70" y1="0" x2="70" y2="0" class="axis"/>
            <line x1="0" y1="-70" x2="0" y2="70" class="axis"/>
            <circle cx="0" cy="0" r="2" class="dot"/>
            <line id="pvVec" x1="0" y1="0" x2="0" y2="0" class="vec"/>
          </svg></div>
          <hr style="opacity:.2;margin:12px 0;">
         <div class="subhead">角度 → 水平/垂直</div>
         <div class="row">
            <label>眼別
              <select id="pvEyeD">
                <option value="OD">OD</option>
                <option value="OS">OS</option>
              </select>
            </label>
          </div>
          <div class="row">
            <label>稜鏡量(△)<input id="pvR" type="text" step="0.1"></label>
            <label>角度(°)<input id="pvTheta" type="number" step="1" min="0" max="360" value="0"></label>
          </div>
          <div class="row">    
            <label>
              <select id="pvThetaMode">
                <option value="360">0~360°表示法</option>
                <option value="90">0~90°(半規)</option>
              </select>
            </label>
          </div>
          <div class="row">
            <button id="pvDecompBtn" class="btn" style="margin:6px 0;">分解稜鏡</button>
          </div>
          <div id="pvDecompOut" class="result-line">
        </div>
        <div class="mini-plot">
          <svg id="pvPlot" viewBox="-60 -60 120 120">
            <line x1="-60" y1="0" x2="60" y2="0" class="axis"/>
            <line x1="0" y1="-60" x2="0" y2="60" class="axis"/>
            <line id="pvVec2" x1="0" y1="0" x2="0" y2="0" class="vec"/>
            <circle r="2.5" cx="0" cy="0" class="dot"/>
          </svg>
          <div class="mini-plot-legend">向量：0°→、90°↑、180°←、270°↓</div>
        </div>
      </div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jsbarcode/dist/JsBarcode.all.min.js"></script>
  <audio id="clickSound" src="m/click.mp3"></audio>
  <audio id="scoreSound" src="m/Sou.mp3"></audio>
  <audio id="cutSound" src="m/cut1.mp3"></audio>
  <audio id="click1Sound" src="m/click1.mp3" preload="auto"></audio>
  <script>
    const clickSound = document.getElementById('clickSound');
    const scoreSound = document.getElementById('scoreSound');
    const cutSound = document.getElementById('cutSound');
    const click1Sound = document.getElementById('click1Sound');
    const fishCanvas = document.getElementById('fishCanvas');
    const fishCtx = fishCanvas.getContext('2d');
    let selectedHexagons = [];
    let hoveredHexagonsMap = {};
    let mouseX = -1, mouseY = -1;
    let time = 0;
    function playScoreSound() {
      scoreSound.currentTime = 0;
      scoreSound.play().catch(error => console.warn('範例按鈕音效失敗:', error));
    }
    document.querySelectorAll('.example-option').forEach(button => {
        button.addEventListener('click', playScoreSound);
    });
    function playclickSound() {
      clickSound.currentTime = 0;
      clickSound.play().catch(error => console.warn('範例按鈕音效失敗:', error));
    }
    document.querySelectorAll('.example-option').forEach(button => {
        button.addEventListener('click', playScoreSound);
    });
    function resizeCanvas() {
      fishCanvas.width = window.innerWidth;
      fishCanvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    function drawHexagon(ctx, cx, cy, r, style) {
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const ang = Math.PI / 3 * i - Math.PI / 6;
        const x = cx + r * Math.cos(ang);
        const y = cy + r * Math.sin(ang);
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      }
      ctx.closePath(); ctx.fillStyle = style; ctx.fill();
    }

    function drawGlow(ctx, x, y, r, op) {
      const g = ctx.createRadialGradient(x, y, r * 0.5, x, y, r);
      g.addColorStop(0, `rgba(190,250,255,${op * 0.8})`);
      g.addColorStop(1, `rgba(190,250,255,0)`);
      ctx.beginPath(); ctx.arc(x, y, r, 0, 2*Math.PI);
      ctx.fillStyle = g; ctx.fill();
    }

    function drawHexagonGrid(ctx, w, h, radius, t) {
      const hexW = 1.7 * radius;
      const hexH = Math.sqrt(3.1) * radius;
      
      for (let row = 0; row < h / (hexH * 0.8) + 1; row++) {
        const offsetX = (row % 2) * (hexW / 2);
        for (let col = 0; col < w / hexW + 1; col++) {
          const baseX = col * hexW + offsetX;
          const baseY = row * (hexH * 0.85);
          const waveX = Math.sin(baseX * 0.01 + t) * 3;
          const waveY = Math.cos(baseY * 0.01 + t) * 3;
          const x = baseX + waveX, y = baseY + waveY;
          let op = 0.08 + Math.sin(baseX * 0.01 + baseY * 0.01 + t) * 0.021;
          const bR = 70, bG = 220, bB = 255;
          let style = `rgba(${bR},${bG},${bB},${op})`;
          let glowOp = 0;
          let effR = radius;

          const dx = mouseX - x, dy = mouseY - y;
          const key = `${row}-${col}`;
          let isSelected = false;
          for (const hex of selectedHexagons) {
            if (hex.col === col && hex.row === row) {
              const e = (performance.now() - hex.startTime) / 1000;
              if (e < 1) {
                const m = e;
                style = `rgba(${70 + m * 120},${220 + m * 30},255,${op + m * (0.2 - op)})`;
                glowOp = m * 0.2;
              } else if (e < 2) {
                style = `rgba(190,250,255,0.2)`; glowOp = 0.2;
              } else if (e < 3) {
                const m = 1 - (e - 2);
                style = `rgba(${70 + m * 185},${220 + m * 35},255,${op + m * (0.2 - op)})`;
                glowOp = m * 0.2;
              }
              isSelected = true;
              break;
            }
          }
          if (Math.hypot(dx, dy) < radius * 1.2) {
            if (!hoveredHexagonsMap[key]) hoveredHexagonsMap[key] = { startTime: performance.now() };
          }
          if (!isSelected && hoveredHexagonsMap[key]) {
            const elapsed = performance.now() - hoveredHexagonsMap[key].startTime;
            const intensity = elapsed < 3000 ? 1 - (elapsed / 3000) : 0;
            const tR = bR + 0.1 * (255 - bR);
            const tG = bG + 0.1 * (255 - bG);
            const nR = Math.round(bR + intensity * (tR - bR));
            const nG = Math.round(bG + intensity * (tG - bG));
            style = `rgba(${nR},${nG},${bB},${op})`;
            effR = radius * (1 + 0.05 * intensity);
            glowOp = 0.1 * intensity;
          }

          if (glowOp > 0) drawGlow(ctx, x, y, radius * 1.5, glowOp);
          drawHexagon(ctx, x, y, effR, style);
        }
      }
      for (const k in hoveredHexagonsMap) {
        if ((performance.now() - hoveredHexagonsMap[k].startTime) / 1000 > 3) {
          delete hoveredHexagonsMap[k];
        }
      }
      selectedHexagons = selectedHexagons.filter(h => (performance.now() - h.startTime) / 1000 < 3);
    }
    function animateBackground() {
      time += 0.02;
      fishCtx.clearRect(0, 0, fishCanvas.width, fishCanvas.height);
      drawHexagonGrid(fishCtx, fishCanvas.width, fishCanvas.height, 45, time);
      requestAnimationFrame(animateBackground);
    }
    function randomSelectHexagon() {
      const cols = Math.ceil(fishCanvas.width / (1.7 * 45));
      const rows = Math.ceil(fishCanvas.height / (Math.sqrt(3.1) * 45));
      selectedHexagons.push({ col: Math.floor(Math.random() * cols), row: Math.floor(Math.random() * rows), startTime: performance.now() });
      setTimeout(randomSelectHexagon, 1000);
    }
    function handleMouseMove(e){
      const rect = fishCanvas.getBoundingClientRect();
      mouseX = e.clientX - rect.left;
      mouseY = e.clientY - rect.top;
    }
    function handleMouseLeave(){
      mouseX = -1;
      mouseY = -1;
    }
    window.addEventListener('mousemove', handleMouseMove, { passive: true });
    window.addEventListener('mouseleave', handleMouseLeave);
    window.addEventListener('touchmove', e => {
      if (e.touches && e.touches[0]) handleMouseMove(e.touches[0]);
    }, { passive: true });

    /* ===== 時間管理工具邏輯 ===== */
    const events = [];
    const eventsList = document.getElementById('eventsList');
    const startInput = document.getElementById('startTime');
    const targetInput = document.getElementById('targetTime');
    const resultDiv = document.getElementById('result');
    const modeButtons = document.querySelectorAll('.mode-btn');
    const rowStart = document.getElementById('rowStart');
    const rowTarget = document.getElementById('rowTarget');
    const labelStart = rowStart.querySelector('label');
    const labelTarget = rowTarget.querySelector('label');
    const calcEndOut = document.getElementById('calcEndOut');
    const calcDepartOut = document.getElementById('calcDepartOut');
    let mode = 'arrive';

    function setMode(m){
      mode = m;
      modeButtons.forEach(btn=>btn.classList.toggle('active', btn.dataset.mode===m));
      if(m==='arrive'){
        playScoreSound();
        rowTarget.style.display='block';
        rowStart.style.display='none';
        labelTarget.textContent='輸入行程目標時間';
        startInput.value='';
      }else{
        playScoreSound();
        rowStart.style.display='block';
        rowTarget.style.display='none';
        labelStart.textContent='輸入行程起始時間';
        targetInput.value='';
      }
      calcEndOut.textContent='';
      calcDepartOut.textContent='';
      resultDiv.textContent='';
    }
    setMode(mode);
    modeButtons.forEach(btn=>btn.addEventListener('click',()=>setMode(btn.dataset.mode)));

    document.getElementById('addEventBtn').addEventListener('click',()=>{
      events.push({name:'',hours:0,mins:0});
      renderEvents();
      playScoreSound();
    });
    function attachAutoPicker(el) {
      ['focus', 'click'].forEach(ev => {
        el.addEventListener(ev, () => {
          if (typeof el.showPicker === 'function') el.showPicker();
        });
      });
    }
    document.querySelectorAll('.time-row input[type="time"]').forEach(attachAutoPicker);

    function renderEvents(){
      eventsList.innerHTML='';
      events.forEach((e,i)=>{
        const div=document.createElement('div');
        div.className='event-item';
        div.innerHTML=`<input class="event-name" type="text" placeholder="行程名稱" value="${e.name}" data-i="${i}" data-f="name">
          <div class=\"duration-group\">
            <input type=\"number\" min=\"0\" value=\"${e.hours}\" data-i=\"${i}\" data-f=\"hours\"><span>小時</span>
            <input type=\"number\" min=\"0\" max=\"59\" value=\"${e.mins}\" data-i=\"${i}\" data-f=\"mins\"><span>分鐘</span>
          </div>
          <button class=\"remove-btn\" data-rm=\"${i}\">刪除</button>`;
        eventsList.appendChild(div);
      });
    }
    eventsList.addEventListener('click', e => {
      if (e.target.dataset.rm !== undefined) {
        cutSound.currentTime = 0;
        cutSound.play();
        const idx = parseInt(e.target.dataset.rm);
        events.splice(idx,1);
        renderEvents();
      }
    });
    eventsList.addEventListener('input',e=>{
      const i=e.target.getAttribute('data-i');
      const f=e.target.getAttribute('data-f');
      if(i!==null && f){
        events[i][f]=f==='name'?e.target.value:parseInt(e.target.value)||0;
      }
    });

    eventsList.addEventListener('click',e=>{
      if(e.target.dataset.rm!==undefined){
        const idx=parseInt(e.target.dataset.rm);
        events.splice(idx,1);renderEvents();
      }
    });

    document.getElementById('calculateBtn').addEventListener('click',()=>{
      playScoreSound();
      calcEndOut.textContent='';
      calcDepartOut.textContent='';
      resultDiv.textContent='';
      const totalMins = events.reduce((s,e)=>s+e.hours*60+e.mins,0);
      if(mode==='depart'){
        if(!startInput.value){resultDiv.textContent='請輸入起始(出發)時間';return;}
        const start=parseTime(startInput.value);
        const endRaw=addMinutes(start,totalMins);
        calcEndOut.textContent = '→ ' + formatWithDays(endRaw,'forward');
      }else{
        if(!targetInput.value){resultDiv.textContent='請輸入抵達(目標)時間';return;}
        const target=parseTime(targetInput.value);
        const departRaw=addMinutes(target,-totalMins);
        calcDepartOut.textContent = '→ ' + formatWithDays(departRaw,'backward');
      }
    });

    document.getElementById('resetBtn').addEventListener('click',()=>{
      cutSound.currentTime = 0;
      cutSound.play();
      if(confirm('確定要清空所有資料並回到模式選擇？')){
        events.length=0;
        startInput.value='';
        targetInput.value='';
        renderEvents();
        setMode('arrive');
        resultDiv.textContent='';
      }
    });

    function parseTime(str){const [h,m]=str.split(':').map(n=>parseInt(n,10));return h*60+m;}
    function formatTime(mins){mins=(mins+24*60)%(24*60);const h=Math.floor(mins/60).toString().padStart(2,'0');const m=(mins%60).toString().padStart(2,'0');return `${h}:${m}`;}
    function addMinutes(base,delta){return base+delta;}
    const DAY_MIN=1440;
    function formatWithDays(rawMins, type){
      // type: 'forward' => 結束/抵達 ; 'backward' => 出發
      if(type==='forward'){
        const days=Math.floor(rawMins/DAY_MIN);
        if(days>0){return `抵達時間：隔${days}天的 ${formatTime(rawMins)}`;}
        return `最終抵達時間：${formatTime(rawMins)}`;
      }else{ // backward
        if(rawMins<0){
          const daysBefore=Math.ceil(Math.abs(rawMins)/DAY_MIN);
          const norm=((rawMins % DAY_MIN)+DAY_MIN)%DAY_MIN;
          return `出發時間：前${daysBefore}天的 ${formatTime(norm)}`;
        }
        return `行程出發時間：${formatTime(rawMins)}`;
      }
    }
  
    // ===== 摩斯密碼翻譯器 =====
  const textInput     = document.getElementById('textInput');
  const morseInput    = document.getElementById('morseInput');
  const textCount     = document.getElementById('textCount');
  const morseCount    = document.getElementById('morseCount');
  const clearAllBtn   = document.getElementById('clearAllBtn');
  const swapBtn       = document.getElementById('swapBtn');
  const w = document.getElementById('morseWpm');
  const f = document.getElementById('morseFreq');
  const v = document.getElementById('morseVol');
  const fa = document.getElementById('morseFarn');
  const wo = document.getElementById('morseWpmOut');
  const fo = document.getElementById('morseFreqOut');
  const vo = document.getElementById('morseVolOut');
  const fao= document.getElementById('morseFarnOut');

  function sync(){ wo.textContent=w.value; fo.textContent=`${f.value} Hz`; vo.textContent=Number(v.value).toFixed(2); }
  ['input','change'].forEach(evt=>{
    w.addEventListener(evt,sync); f.addEventListener(evt,sync); v.addEventListener(evt,sync);
  });
  sync();

function syncAudioUI(){
  if (wo) wo.textContent = (w?.value ?? 20);
  if (fo) fo.textContent = `${f?.value ?? 600} Hz`;
  if (vo) vo.textContent = Number(v?.value ?? 0.3).toFixed(2);
  if (fao) fao.textContent = `${Number(fa?.value ?? 1).toFixed(2)}×`;
}
['input','change'].forEach(evt=>{
  w?.addEventListener(evt, syncAudioUI);
  f?.addEventListener(evt, syncAudioUI);
  v?.addEventListener(evt, syncAudioUI);
  fa?.addEventListener(evt, syncAudioUI);
});
syncAudioUI();
  const playBtn=document.getElementById('morsePlayBtn');
  const stopBtn=document.getElementById('morseStopBtn');
  let ac, playing = false, stopFlag = false;

  function getAC(){ if(!ac) ac = new (window.AudioContext||window.webkitAudioContext)(); return ac; }
  function dotSec(){
    const cwpm = Math.max(5, Math.min(60, parseInt(w?.value || 22,10)));
    return 1.2 / cwpm; 
  }
  function farn(){ const x = parseFloat(fa?.value || 1); return (isFinite(x)?Math.max(1,Math.min(4,x)):1); }
  
  function scheduleMorse(morse){
    const ctx = getAC();
    const u   = dotSec();
    const ff  = farn();
    const freq = parseInt(f?.value || 700,10);
    const vol  = parseFloat(v?.value || 0.3);
    const atk  = 0.005;
    const rel  = 0.008;
    const osc = ctx.createOscillator();
    const g   = ctx.createGain();
    currentOsc = osc; currentGain = g;

    osc.type = 'sine';
    osc.frequency.setValueAtTime(freq, ctx.currentTime);
    g.gain.setValueAtTime(0, ctx.currentTime);
    osc.connect(g); g.connect(ctx.destination);
    let t = ctx.currentTime + 0.02; 
    osc.start(t);
    const words = morse.split(/\s*\/\s*/);
    for (let wi=0; wi<words.length; wi++){
      const letters = words[wi].trim().split(/\s+/).filter(Boolean);
      for (let li=0; li<letters.length; li++){
        const syms = letters[li].split('');
        for (let si=0; si<syms.length; si++){
          const dur = (syms[si] === '.' ? 1*u : 3*u);

          g.gain.cancelScheduledValues(t);
          g.gain.setValueAtTime(0, t);
          g.gain.linearRampToValueAtTime(vol, t + atk);
          g.gain.setValueAtTime(vol, t + Math.max(atk, dur - rel));
          g.gain.linearRampToValueAtTime(0, t + dur);

          t += dur;
          if (si < syms.length - 1) {
            t += 1*u;
          }
        }
        if (li < letters.length - 1) {
          t += (3*u*ff);
        }
      }
      if (wi < words.length - 1) {
        t += (7*u*ff);
      }
    }
    osc.stop(t + 0.02);
    return t + 0.04;
 }
  function unitMs(){
    const val = parseInt((w?.value || 20), 10);
    return 1200 / Math.max(5, Math.min(60, val));
  }
  function normMorse(s){
    if(!s) return '';
    return s.trim()
            .replace(/[^\.\-\s\/|]/g,'')
            .replace(/\|/g,'/')
            .replace(/\s*\/\s*/g,' / ')
            .replace(/\s+/g,' ')
            .trim();
  }
  function sourceMorse(){
    const m = morseInput?.value?.trim();
    if (m) return normMorse(m);
    const t = textInput?.value || '';
    return normMorse(textToMorse(t));
  }
  function wait(ms){ return new Promise(r=>setTimeout(r, ms)); }
  function tone(ms){
    const ctx = getAC();
    const osc = ctx.createOscillator();
    const g   = ctx.createGain();
    osc.type = 'sine';
    osc.frequency.value = parseInt(f?.value || 600, 10);
    const vol = parseFloat(v?.value || 0.3);
    g.gain.setValueAtTime(0, ctx.currentTime);
    g.gain.linearRampToValueAtTime(vol, ctx.currentTime + 0.004);
    g.gain.linearRampToValueAtTime(0, ctx.currentTime + ms/1000 - 0.004);
    osc.connect(g); g.connect(ctx.destination);
    osc.start();
    osc.stop(ctx.currentTime + ms/1000);
    return new Promise(r=>setTimeout(r, ms));
  }
    function farnFactor(){
    const x = parseFloat(fa?.value || 1);
    return Number.isFinite(x) ? Math.max(1, Math.min(4, x)) : 1;
  }

  async function playMorse(){
    if (playing) return;
    const morse = sourceMorse();
    if (!morse) return;
    await getAC().resume();
    playing = true;

    const endAt = scheduleMorse(morse);

    const ctx = getAC();
    const watch = () => {
      if (!playing) return;
      if (ctx.currentTime >= endAt - 0.02) {
        playing = false;
        currentOsc = null; currentGain = null;
      } else {
        requestAnimationFrame(watch);
      }
    };
    watch();
  }

  playBtn?.addEventListener('click', async () => {
    if (!playing) { await getAC().resume(); playMorse(); }
  });

  stopBtn?.addEventListener('click', () => {
    if (!playing) return;
    playing = false;
    try {
      const ctx = getAC();
      if (currentGain) {
        currentGain.gain.cancelScheduledValues(ctx.currentTime);
        currentGain.gain.setTargetAtTime(0, ctx.currentTime, 0.005);
      }
      currentOsc?.stop(ctx.currentTime + 0.02);
    } catch(e){}
    currentOsc = null; currentGain = null;
  });

  const TEXT_TO_MORSE = {
    "A":".-","B":"-...","C":"-.-.","D":"-..","E":".","F":"..-.","G":"--.","H":"....","I":"..","J":".---",
    "K":"-.-","L":".-..","M":"--","N":"-.","O":"---","P":".--.","Q":"--.-","R":".-.","S":"...","T":"-",
    "U":"..-","V":"...-","W":".--","X":"-..-","Y":"-.--","Z":"--..",
    "0":"-----","1":".----","2":"..---","3":"...--","4":"....-","5":".....","6":"-....","7":"--...","8":"---..","9":"----.",
    ".":".-.-.-",",":"--..--","?":"..--..","!":"-.-.--",":":"---...",";":"-.-.-.","/":"-..-.","-":"-....-","(":"-.--.",")":"-.--.-",
    "\"":".-..-.","'":".----.","=":"-...-","+":".-.-.","@":".--.-.","&":".-...","¿":"..-.-","¡":"--...-"
  };
  const MORSE_TO_TEXT = Object.fromEntries(Object.entries(TEXT_TO_MORSE).map(([k,v])=>[v,k]));

  let lock = false;

  function getMorseTokens(str){
    return str.trim().replace(/\n+/g,' ').split(/(?:\s+|\/|\|)+/g).filter(Boolean);
  }
  function updateCounts(){
    if(textCount)  textCount.textContent  = [...(textInput?.value||'')].length + ' 字元';
    if(morseCount) morseCount.textContent = getMorseTokens(morseInput?.value||'').length + ' 符號';
  }
  function textToMorse(str){
    return str.toUpperCase().split('').map(ch=>{
      if(ch===' ') return '/';
      return TEXT_TO_MORSE[ch] || '';
    }).filter(Boolean).join(' ');
  }
  function morseToText(str){
    const tokens = getMorseTokens(str);
    return tokens.map(code=>{
      if(code==='/'||code==='|') return ' ';
      return MORSE_TO_TEXT[code] || '';
    }).join('').replace(/\s+/g,' ');
  }

  if(textInput){
    textInput.addEventListener('input', ()=>{
      if(lock) return; lock = true;
      morseInput.value = textToMorse(textInput.value);
      updateCounts(); lock = false;
    });
  }
  if(morseInput){
    morseInput.addEventListener('input', ()=>{
      if(lock) return; lock = true;
      textInput.value = morseToText(morseInput.value);
      updateCounts(); lock = false;
    });
  }

  clearAllBtn?.addEventListener('click', ()=>{
    textInput.value=''; morseInput.value=''; updateCounts();
    if (window.cutSound) { cutSound.currentTime = 0; cutSound.play(); }
  });

  swapBtn?.addEventListener('click', ()=>{
    const t = textInput.value;
    if (typeof playScoreSound === 'function') playScoreSound();
    textInput.value  = morseToText(morseInput.value);
    morseInput.value = textToMorse(t);
    updateCounts();
  });

  document.addEventListener('click', e => {
    const btn = e.target.closest('[data-copy-target]');
    if (!btn) return;
    const targetId = btn.getAttribute('data-copy-target');
    const srcEl = document.getElementById(targetId);
    if (!srcEl) return;
    const text = srcEl.value != null ? srcEl.value : srcEl.textContent.trim();
    navigator.clipboard.writeText(text).then(() => {
      const tip = document.createElement('div');
      tip.className = 'copy-tooltip';
      tip.textContent = '已複製';
      document.body.appendChild(tip);
      const r = btn.getBoundingClientRect();
      tip.style.left = `${r.left + r.width / 2}px`;
      tip.style.top  = `${r.top + window.scrollY - 8}px`;
      setTimeout(() => {
        tip.style.opacity = '0';
        setTimeout(() => tip.remove(), 300);
      }, 1000);
      if (typeof playScoreSound === 'function') playScoreSound();
    });
  });
  updateCounts();

    // 二進制轉換邏輯
    const decIn = document.getElementById('decimalInput');
    const binIn = document.getElementById('binaryInput');
    const copyDecBtn = document.getElementById('copyDecBtn');
    const copyBinBtn = document.getElementById('copyBinBtn');
    const clearBinBtn = document.getElementById('clearBinBtn');
    const swapBinBtn = document.getElementById('swapBinBtn');
    let lockBin = false;
    function updateBinary() {
      if (lockBin) return;
      lockBin = true;
      let d = decIn.value.trim().replace(/,/g, ''); 
      if (d === '') {
        binIn.value = '';
        lockBin = false;
        return;
      }
      // 處理小數點
      const parts = d.split('.');
      const intNum = parseInt(parts[0], 10);
      const intBin = isNaN(intNum) ? '' : intNum.toString(2);
      let fracBin = '';
      if (parts[1] !== undefined) {
        let frac = parseFloat('0.' + parts[1]);
        let count = 0;
        while (frac > 0 && count < 10) { 
          frac *= 2;
          if (frac >= 1) {
            fracBin += '1';
            frac -= 1;
          } else {
            fracBin += '0';
          }
          count++;
        }
      }
      binIn.value = fracBin ? `${intBin}.${fracBin}` : intBin;
      lockBin = false;
    }

    function updateDecimal() {
      if (lockBin) return;
      lockBin = true;
      const raw = binIn.value.trim();
      if (raw === '') {
        decIn.value = '';
      } else {
        const parts = raw.split(/([,\.\/])/);
        const result = parts.map(part => {
          if (/^[,\.\/]$/.test(part)) {
            return part;
          }
        const b = part.replace(/[^01]/g, '');
          if (b === '') return '';
          const n = parseInt(b, 2);
          return isNaN(n) ? '' : n.toString(10);
        }).join('');
        decIn.value = result;
      }
      lockBin = false;
    }
    decIn.addEventListener('input', updateBinary);
    binIn.addEventListener('input', updateDecimal);
    clearBinBtn.addEventListener('click', () => { 
      decIn.value = ''; 
      binIn.value = ''; 
      cutSound.currentTime = 0;
      cutSound.play(); 
    });
    swapBinBtn.addEventListener('click', () => {
      const t = decIn.value;
      decIn.value = binIn.value;
      binIn.value = t;
      updateBinary();
      playScoreSound();
    });

// ===== 匯率轉換邏輯 =====
document.addEventListener('DOMContentLoaded', () => {
  const amountInput      = document.getElementById('amountInput');
  const baseCurrency     = document.getElementById('baseCurrency');
  const targetCurrency   = document.getElementById('targetCurrency');
  const convertBtn       = document.getElementById('convertBtn');
  const copyExchangeBtn  = document.getElementById('copyExchangeBtn');
  const clearExchangeBtn = document.getElementById('clearExchangeBtn');
  const exchangeResult   = document.getElementById('exchangeResult');

  const CODES = ['TWD','USD','EUR','JPY','CNY','HKD','SGD','AUD','GBP','CAD','KRW','THB','CHF'];
  const NAMES = {
    TWD:'新台幣',USD:'美金',EUR:'歐元',JPY:'日幣',CNY:'人民幣',HKD:'港幣',
    SGD:'新加坡幣',AUD:'澳幣',GBP:'英鎊',CAD:'加拿大幣',KRW:'韓元',THB:'泰銖',CHF:'瑞士法郎'
  };
  const ratesCache = {};
  CODES.forEach(code => {
    const label = `${code} – ${NAMES[code]}`;
    baseCurrency .add(new Option(label, code));
    targetCurrency.add(new Option(label, code));
  });
  baseCurrency.value   = 'USD';
  targetCurrency.value = 'TWD';
  async function fetchRates() {
    try {
      const res = await fetch('https://open.er-api.com/v6/latest/TWD');
      const data = await res.json();
      if (data.result !== 'success' || typeof data.rates !== 'object') {
        throw new Error('Invalid API response');
      }
      CODES.forEach(code => {
        ratesCache[code] = data.rates[code] ?? null;
      });
      const ts = new Date(data.time_last_update_unix * 1000);
      const Y  = ts.getFullYear();
      const M  = String(ts.getMonth()+1).padStart(2,'0');
      const D  = String(ts.getDate()).padStart(2,'0');
      const h  = String(ts.getHours()).padStart(2,'0');
      const m  = String(ts.getMinutes()).padStart(2,'0');
      document.getElementById('exchangeTimestamp').textContent =
        `匯率掛牌時間：${Y}/${M}/${D} ${h}:${m}`;
    } catch (err) {
      console.error('取得匯率失敗，使用 fallback 列表', err);
      document.getElementById('exchangeTimestamp').textContent =
        '匯率掛牌時間：無法取得';
    }
  }

  function convertExchange() {
    const amt  = parseFloat(amountInput.value);
    const from = baseCurrency.value;
    const to   = targetCurrency.value;
    if (isNaN(amt) || ratesCache[from] == null || ratesCache[to] == null) {
      exchangeResult.textContent = '請輸入金額並等待匯率載入';
      return;
    }
    const result = amt * (ratesCache[to] / ratesCache[from]);
    exchangeResult.textContent = `${amt} ${from} = ${result.toFixed(4)} ${to}`;
  }

  fetchRates();
  convertBtn.addEventListener('click', () => {
    playScoreSound();
    convertExchange();
  });
  clearExchangeBtn.addEventListener('click', () => {
    amountInput.value = '';
    exchangeResult.textContent = '';
    cutSound.currentTime = 0;
    cutSound.play();
  });
});

  //======QR/條碼邏輯=========
  const codeType      = document.getElementById('codeType');
  const codeText      = document.getElementById('codeText');
  const codeSize      = document.getElementById('codeSize');
  const codeColor     = document.getElementById('codeColor');
  const codeBgColor   = document.getElementById('codeBgColor');
  const codeLogoInput = document.getElementById('codeLogo');
  const generateBtn   = document.getElementById('generateCodeBtn');
  const canvas        = document.getElementById('codeCanvas');
  const downloadPng   = document.getElementById('downloadPngBtn');
  const downloadJpg   = document.getElementById('downloadJpgBtn');
  const ctx           = canvas.getContext('2d');
  let logoImg         = new Image();

  codeLogoInput.addEventListener('change', () => {
    const file = codeLogoInput.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = e => logoImg.src = e.target.result;
    reader.readAsDataURL(file);
  });

  async function drawCode() {
    const text = codeText.value.trim();
    if (!text) return;
    const size = Math.max(50, parseInt(codeSize.value, 10) || 200);
    if (codeType.value === 'qrcode') {
      canvas.width = canvas.height = size;
      ctx.fillStyle = codeBgColor.value;
      ctx.fillRect(0, 0, size, size);
      await QRCode.toCanvas(canvas, text, {
        width: size,
        margin: 1,
        color: { dark: codeColor.value, light: codeBgColor.value }
      });
      if (logoImg.src) {
        const lw     = size * 0.2;   
        const margin = 5;        
        const lx     = (size - lw) / 2;   
        const ly     = (size - lw) / 2;  
        ctx.fillStyle = codeBgColor.value;
        ctx.fillRect(
          lx - margin,
          ly - margin,
          lw + margin * 2,
          lw + margin * 2
        );
        ctx.drawImage(logoImg, lx, ly, lw, lw);
      }
      } else {
        const w = size;
        const h = size * 0.5;
        canvas.width = w;
        canvas.height = h;
        ctx.fillStyle = codeBgColor.value;
        ctx.fillRect(0, 0, w, h);
        const modules = text.length * 11;
        const barWidth = Math.max(1, Math.floor(w / modules));
        JsBarcode(canvas, text, {
          format: 'CODE128',
          width: barWidth,
          height: h * 0.8,
          displayValue: false,
          lineColor: codeColor.value,
          background: codeBgColor.value
      });
    }
  }
  generateBtn.addEventListener('click', () => {drawCode();playScoreSound();});
  downloadPng.addEventListener('click', () => {
    const link = document.createElement('a');
    link.download = 'code.png';
    link.href = canvas.toDataURL('image/png');
    link.click();
    playScoreSound();
  });
  downloadJpg.addEventListener('click', () => {
    const link = document.createElement('a');
    link.download = 'code.jpg';
    link.href = canvas.toDataURL('image/jpeg', 0.8);
    link.click();
    playScoreSound();
  });

// 單位換算工具
  const K6MM = 8.73;   // 1.0 視力 @6m 的視標高度(mm)
  const K5MM = 7.27;   // 1.0 視力 @5m 的視標高度(mm)
  const H1M  = 1.581;  // 1M @40cm 的視標高度(mm) ≈ 4.5pt
  const PTMM = 0.35146;
  const N_MM = 0.53 / 3;
  const M_LABEL_CM = { M: 40, M60: 60, M67: 67, M33: 33 };
  const K_INDEX  = 1.3375;
  const RK_CONST = 1000 * (K_INDEX - 1);
  const SOFT_BC_OFFSET = { BC140: 0.70, BC142: 0.80, BC145: 0.90 };

  const maps = {
    distance: { m:1, cm:0.01, mm:0.001, um:1e-6, km:1000, mi:1609.34, ft:0.3048, chi:0.33333, taiChi:0.30303, in:0.0254 },
    weight:   { g:1, kg:1000, lb:453.592, oz:28.3495, jin:600 },
    volume:   { L:1, mL:0.001, gal:3.78541, qt:0.946353 },
    temperature:{ C:1, F:1, K:1 }, 
    area:     { m2:1, km2:1e6, ha:10000, ac:4046.86, ft2:0.092903, in2:0.00064516, ping:3.305785 },
    angle:    { deg:1, rad:Math.PI/180, grad:0.9, amin:1/60, asec:1/3600 },
    time:     { s:1, min:60, h:3600, d:86400, week:604800, month:2629800, year:31557600 },
    nearva:   { dec:   { toDec: v => +v, fromDec: V => V },
                logMAR:{ toDec: v => Math.pow(10, -v),      fromDec: V => -Math.log10(V) },
                MAR:   { toDec: v => 1 / (+v),              fromDec: V => 1 / V },
                M:      { toDec: v => 0.40/(+v),           fromDec: V => 0.40/V }, 
                M60:    { toDec: v => 0.60/(+v),           fromDec: V => 0.60/V }, 
                M67:    { toDec: v => 0.67/(+v),           fromDec: V => 0.67/V }, 
                M33:    { toDec: v => 0.33/(+v),           fromDec: V => 0.33/V },
                H40:{ toDec: mm => (0.40*H1M)/(+mm), fromDec: V => (0.40/V)*H1M },
                pt: { toDec: p  => (0.40*4.5)/(+p),  fromDec: V => (0.40/V)*4.5  },
                  N: { toDec:   n => 3.2 / Number(n),  fromDec: V => 3.2 / Number(V)}
              },
    acuity:   {
                dec:   { toDec: v => +v,                    fromDec: V => V },
                logMAR:{ toDec: v => Math.pow(10, -v),      fromDec: V => -Math.log10(V) },
                MAR:   { toDec: v => 1 / (+v),              fromDec: V => 1 / V },
                s20:   { toDec: v => 20 / (+v),             fromDec: V => 20 / V }, 
                s6:    { toDec: v => 6  / (+v),             fromDec: V => 6  / V },
                H6m:{ toDec: mm => K6MM/(+mm), fromDec: V => K6MM/V },
                H5m:{ toDec: mm => K5MM/(+mm), fromDec: V => K5MM/V }
              },
  };
  const shoeCharts = [
    { footMin: 23.0, footMax: 23.5, TW: 65,   US: 4.5,  US_sport: '5-5.5',   EU: 35, JP: '22-22.5', UK: 2.5 },
    { footMin: 23.5, footMax: 24.0, TW: 66,   US: 5.0,  US_sport: '5.5-6',   EU: 35, JP: '22.5-23', UK: 3.0 },
    { footMin: 24.0, footMax: 24.5, TW: 67,   US: 5.5,  US_sport: '6-6.5',   EU: 36, JP: '23-23.5', UK: 3.5 },
    { footMin: 24.5, footMax: 25.0, TW: 68,   US: 6.0,  US_sport: '6.5-7',   EU: 37, JP: '23.5-24', UK: 4.0 },
    { footMin: 25.0, footMax: 25.5, TW: 69,   US: 6.5,  US_sport: '7-7.5',   EU: 37, JP: '24-24.5', UK: 4.5 },
    { footMin: 25.5, footMax: 26.0, TW: 70,   US: 7.0,  US_sport: '7.5-8',   EU: 38, JP: '24.5-25', UK: 5.0 },
    { footMin: 26.0, footMax: 26.5, TW: 71,   US: 7.5,  US_sport: '8-8.5',   EU: 38, JP: '25-25.5', UK: 5.5 },
    { footMin: 26.5, footMax: 27.0, TW: 72,   US: 8.0,  US_sport: '8.5-9',   EU: 39, JP: '25.5-26', UK: 6.0 },
    { footMin: 27.0, footMax: 27.5, TW: 73,   US: 8.5,  US_sport: '9-9.5',   EU: 40, JP: '26-26.5', UK: 6.5 },
    { footMin: 27.5, footMax: 28.0, TW: 74,   US: 9.0,  US_sport: '9.5-10',  EU: 40, JP: '26.5-27', UK: 7.0 },
    { footMin: 28.0, footMax: 28.5, TW: 75,   US: 9.5,  US_sport: '10-10.5', EU: 41, JP: '27-27.5', UK: 7.5 },
    { footMin: 28.5, footMax: 29.0, TW: 76,   US: 10.0, US_sport: '10.5-11', EU: 42, JP: '27.5-28', UK: 8.0 },
    { footMin: 29.0, footMax: 29.5, TW: 77,   US: 10.5, US_sport: '11-11.5', EU: 42, JP: '28-28.5', UK: 8.5 },
    { footMin: 29.5, footMax: 30.0, TW: 78,   US: 11.0, US_sport: '11.5-12', EU: 43, JP: '28.5-29', UK: 9.0 },
    { footMin: 30.0, footMax: 30.5, TW: 79,   US: 11.5, US_sport: '12-12.5', EU: 43, JP: '29-29.5', UK: 9.5 },
    { footMin: 30.5, footMax: 31.0, TW: 80,   US: 12.0, US_sport: '12.5-13', EU: 44, JP: '29.5-30', UK: 10.0 }
  ];
  const labels = {
    rk:{ K: '角膜度數（D）', r: '角膜曲率半徑（mm）',  BC140: '軟式隱眼 建議BC（Ø14.0）', BC142: '軟式隱眼 建議BC（Ø14.2）', BC145: '軟式隱眼 建議BC（Ø14.5）'},
    acuity:{ dec: '小數視力', logMAR: 'logMAR', MAR: 'MAR(角分)', s20: 'Snellen 20英尺/x',  s6:  'Snellen 6公尺/x',  H6m: '視標高度（@6m, mm）', H5m: '視標高度（@5m, mm）'},
    nearva:{ dec: '小數視力', logMAR: 'logMAR', MAR: 'MAR(角分)',  M:  'M 系統（於 40cm）', M60: 'M 系統（於 60cm）', M67: 'M 系統（於 67cm）', M33: 'M 系統（於 33cm）', pt: '點數視力（point, @40cm）', N: 'N 標示（@40cm）', H40: '視標高度（@40cm, mm）',},
    distance:{ m:'公尺',cm:'公分',mm:'毫米',um:'微米',chi:'市尺',taiChi:'台尺',km:'公里',mi:'英里',ft:'英尺',in:'英吋' },
    weight:{ g:'克',kg:'公斤',lb:'磅',oz:'盎司',jin:'台斤' },
    volume:{ L:'公升',mL:'毫升',gal:'加侖',qt:'夸脫' },
    temperature:{ C:'攝氏度',F:'華氏度',K:'開氏度' },
    area:{ m2:'平方公尺',km2:'平方公里',ha:'公頃',ac:'英畝',ft2:'平方英尺',in2:'平方英吋',ping:'坪' },
    angle:{ deg:'度',rad:'弧度',grad:'梯度',amin:'分角',asec:'秒角' },
    time:{ s:'秒',min:'分',h:'時',d:'天',week:'週',month:'月',year:'年' },
    shoe:{ foot:'腳尺寸(cm)',TW:'台灣尺碼',US:'美國尺碼',US_sport:'美國運動鞋尺碼',UK:'英國尺碼',EU:'歐洲尺碼',JP:'日本/中國尺碼' }
  };
  const suffixMap = {
    distance:{ m:'m',cm:'cm',mm:'mm',um:'µm',km:'km',mi:'mi',ft:'ft',chi:'chi',taiChi:'taiChi',in:'in' },
    weight:{ g:'g',kg:'kg',lb:'lb',oz:'oz',jin:'台斤' },
    volume:{ L:'L',mL:'mL',gal:'gal',qt:'qt' },
    temperature:{ C:'°C',F:'°F',K:'K' },
    area:{ m2:'m²',km2:'km²',ha:'ha',ac:'ac',ft2:'ft²',in2:'in²',ping:'坪' },
    angle:{ deg:'°',rad:'rad',grad:'grad',amin:'′',asec:'″' },
    time:{ s:'秒',min:'分',h:'時',d:'天',week:'週',month:'月',year:'年' },
    shoe:{ foot:'cm', TW:'TW', US:'US', US_sport:'USsport', UK:'UK', EU:'EU', JP:'JP' },
    acuity:{ dec:'', logMAR:' logMAR', MAR:' MAR', s20:'', s6:'', H6m:' mm @6m', H5m:' mm @5m' },
    nearva:{ dec:'', logMAR:' logMAR', MAR:' MAR', M:'', M60:'', M67:'', M33:'', pt:' pt', N: ' N', H40:' mm @40cm' },
    rk:{ K:'D', r:'mm', BC140:'mm', BC142:'mm', BC145:'mm' }
  };

  const UNIT_DEFAULTS = {
    acuity:      { from:'dec', to:'s20' },
    nearva:      { from:'dec', to:'M' },
    distance:    { from:'m',   to:'ft' },
    weight:      { from:'kg',  to:'jin' },
    volume:      { from:'L',   to:'mL' },
    area:        { from:'m2',  to:'ping' }, 
    temperature: { from:'C',   to:'F' },
    angle:       { from:'amin', to:'asec' },
    time:        { from:'h',   to:'min' },
    rk:          { from:'r', to:'K' },
    shoe:        { from:'foot',  to:'EU' }
  };

  const catSel   = document.getElementById('unitCategory');
  const fromSel  = document.getElementById('unitFrom');
  const toSel    = document.getElementById('unitTo');
  const valInput = document.getElementById('unitValue');
  const resultEl = document.getElementById('unitResult');
  const btnConvert = document.getElementById('convertUnitBtn');
  const btnClear   = document.getElementById('clearUnitBtn');

  function convertRK(val, from, to){
    const v = parseFloat(val);
    if (!isFinite(v) || v <= 0) return null;
    let rmm;
    if (from === 'K') rmm = RK_CONST / v;
    else if (from === 'r') rmm = v;
    else if (SOFT_BC_OFFSET[from] != null) rmm = v - SOFT_BC_OFFSET[from];
    else return null;
    if (!isFinite(rmm) || rmm <= 0) return null;
    if (to === 'K') return RK_CONST / rmm;
    if (to === 'r') return rmm;
    if (SOFT_BC_OFFSET[to] != null) return rmm + SOFT_BC_OFFSET[to];
    return null;
  }
  function acuityToDecimal(val, unit){
    const conv = maps.acuity?.[unit];
    const V = conv?.toDec(parseFloat(val));
    return (isFinite(V) && V > 0) ? V : NaN;
  }
  function decimalToAcuity(V, unit){
    const conv = maps.acuity?.[unit];
    if (!conv) return '';
    const out = conv.fromDec(V);
    if (!isFinite(out) || out <= 0) return '';
    if (unit === 's20') return `20/${Math.round(out)}`;
    if (unit === 's6')  return `6/${Math.round(out)}`;
    if (unit === 'H6m' || unit === 'H5m') return `${out.toFixed(2)} mm`;
    if (unit === 'dec' || unit === 'logMAR' || unit === 'MAR') return Number(out).toFixed(2);
    return String(out);
  }
  function convertAcuity(val, from, to){
    const V = ACUITY_MAP[from]?.toDec(parseFloat(val));
    if (!isFinite(V) || V<=0) return '';
    const out = ACUITY_MAP[to]?.fromDec(V);
    if (!isFinite(out) || out<=0) return '';
    if (to==='s20') return `20/${Math.round(20/V)}`;
    if (to==='s6')  return `6/${Math.round(6/V)}`;
    if (to==='H6m') return `${out.toFixed(2)} mm`;
    if (to==='H5m') return `${out.toFixed(2)} mm`;
    return Number(out).toFixed(2);
  }
  function nearToDecimal(val, unit) {
    const v = parseFloat(val);
    if (!isFinite(v) || v <= 0) return NaN;
    const conv = maps?.nearva?.[unit];
   return (conv && typeof conv.toDec === 'function') ? conv.toDec(v) : NaN;
  }
  function decimalToNear(V, unit) {
    if (!isFinite(V) || V <= 0) return '';
    const conv = maps?.nearva?.[unit];
    if (!conv || typeof conv.fromDec !== 'function') return '';
    const out = conv.fromDec(V);
    if (!isFinite(out)) return '';
    if (unit in M_LABEL_CM) return `${Number(out).toFixed(2)} M @ ${M_LABEL_CM[unit]}cm`;
    if (unit === 'H40')     return `${Number(out).toFixed(2)} mm`;
    if (unit === 'pt')      return `${Number(out).toFixed(2)} pt`;
    if (unit === 'N')       return `N${Math.round(out)}`;     
    if (unit === 'dec' || unit === 'logMAR' || unit === 'MAR') return Number(out).toFixed(2);
    return String(out);
  }
  function populateUnits() {
    const cat  = catSel.value;
    const defs = UNIT_DEFAULTS[cat] || {};
    fromSel.innerHTML = '';
    toSel.innerHTML   = '';

    const items = Object.entries(labels[cat] || {});
    items.forEach(([code, name]) => {
      const text = `${code} – ${name}`;
      fromSel.add(new Option(text, code));
      toSel  .add(new Option(text, code));
    });
    const setIfExist = (sel, val) => {
      if (val && Array.from(sel.options).some(o => o.value === val)) {
      sel.value = val;
      } else if (sel.options.length) {
      sel.selectedIndex = 0;
      }
    };
    setIfExist(fromSel, defs.from);
    setIfExist(toSel,   defs.to);
  }
  catSel.addEventListener('change', populateUnits);
  populateUnits(); 

  function findShoeRow(value, unit) {
    const v = parseFloat(value);
    return shoeCharts.find(row => {
      if (unit === 'foot') {
        return v >= row.footMin && v <= row.footMax;
      }
      const cell = row[unit];
      if (typeof cell === 'number') return v === cell;
      const parts = cell.split('-').map(parseFloat);
      return parts.length === 1
        ? v === parts[0]
        : (v >= parts[0] && v <= parts[1]);
    });
  }
  function convertTemperature(v, from, to) {
    let c =
      from === 'C' ? v :
      from === 'F' ? (v - 32) * 5/9 :
      v - 273.15;
    return (
      to === 'C' ? c :
      to === 'F' ? (c * 9/5 + 32) :
      c + 273.15
    );
  }
function convertUnit(){
  const cat = catSel.value, from = fromSel.value, to = toSel.value;
  const v = parseFloat(valInput.value);
  if (isNaN(v)) { resultEl.textContent = '請輸入數值'; return; }

  let r, display, suffix = suffixMap[cat]?.[to] ?? to;

  if (cat === 'acuity') {
    const V = acuityToDecimal(v, from);
    if (!isFinite(V)) { resultEl.textContent = '輸入超出範圍'; return; }
    display = decimalToAcuity(V, to);
    resultEl.textContent = display || '無法換算';
    return;
  }
  if (cat === 'nearva') {
    const V = nearToDecimal(v, from);
    if (!isFinite(V)) { resultEl.textContent = '輸入超出範圍'; return; }
    display = decimalToNear(V, to);
    resultEl.textContent = display || '無法換算';
    return;
  }
  if (cat === 'temperature') {
    let c = from === 'C' ? v : from === 'F' ? (v - 32) * 5/9 : v - 273.15;
    r = to === 'C' ? c : to === 'F' ? c * 9/5 + 32 : c + 273.15;
    resultEl.textContent = `${r.toFixed(4)} ${suffix}`;
    return;
  }
  if (cat === 'time') {
    r = v * maps[cat][from] / maps[cat][to];
    resultEl.textContent = `${r.toFixed(4)} ${suffix}`;
    return;
  }
  if (cat === 'rk') {
    const out = convertRK(v, from, to);
    if (out == null) { resultEl.textContent = '輸入不合法或超出範圍'; return; }
    const suffix = suffixMap.rk?.[to] ?? to;
    const dp = (to === 'K') ? 2 : 2; 
    resultEl.textContent = `${out.toFixed(dp)} ${suffix}`;
    return;
  }
  if (cat === 'shoe') {
    const row = findShoeRow(v, from); 
    if (!row) {
      resultEl.textContent = '不支援此鞋碼';
      return;
    }
    const cell = row[to]; 
    const out  = (typeof cell === 'number') ? cell : cell;
    const suffix = suffixMap.shoe?.[to] ?? to;
    resultEl.textContent = `${out} ${suffix}`;
    return;
  }
  r = v * maps[cat][from] / maps[cat][to];
  resultEl.textContent = `${r.toFixed(4)} ${suffix}`;
}

  catSel.addEventListener('change', populateUnits);
  btnConvert.addEventListener('click', () => {
    convertUnit();
    playScoreSound();
  });
  btnClear  .addEventListener('click', () => {
    valInput.value = '';
    resultEl.textContent = '';
    cutSound.currentTime = 0;
    cutSound.play();
  });
  populateUnits();
  document.getElementById('clearUnitBtn').addEventListener('click', () => {
    valInput.value = '';
    resultEl.textContent = '';
    cutSound.currentTime = 0;
    cutSound.play();
  });
  const CONST_DB = {
  optics: {
    c:       { name:'光速（真空）',     latex:'c = 299\\,792\\,458\\ \\mathrm{m\\,s^{-1}}', value:'299,792,458 m/s（定義值）' },
    alpha:   { name:'精細結構常數',     latex:'\\alpha \\approx \\frac{1}{137.035999084}',   value:'≈ 1/137.035999084（無因次）' },
    rydberg: { name:'銳德伯常數',       latex:'R_\\infty \\approx 10\\,973\\,731.568160\\ \\mathrm{m^{-1}}', value:'10,973,731.568160 m⁻¹' },
    abbe:    { name:'Abbe 極限（解析度）', latex:'d \\approx \\frac{0.61\\,\\lambda}{\\mathrm{NA}}', value:'公式' },
    rayleigh:{ name:'瑞利判據（角解析度）', latex:'\\theta \\approx 1.22\\,\\frac{\\lambda}{D}', value:'公式' },
    na:      { name:'數值孔徑',         latex:'\\mathrm{NA} = n\\,\\sin\\theta', value:'公式' }
  },
  physics: {
    h:       { name:'普朗克常數',       latex:'h = 6.62607015\\times10^{-34}\\ \\mathrm{J\\,s}', value:'6.62607015×10⁻³⁴ J·s（定義值）' },
    hbar:    { name:'約化普朗克常數',   latex:'\\hbar = \\frac{h}{2\\pi} \\approx 1.054571817\\times10^{-34}\\ \\mathrm{J\\,s}', value:'≈ 1.054571817×10⁻³⁴ J·s' },
    e:       { name:'基本電荷',         latex:'e = 1.602176634\\times10^{-19}\\ \\mathrm{C}', value:'1.602176634×10⁻¹⁹ C（定義值）' },
    eps0:    { name:'真空介電常數',     latex:'\\varepsilon_0 \\approx 8.8541878128\\times10^{-12}\\ \\mathrm{F\\,m^{-1}}', value:'≈ 8.8541878128×10⁻¹² F/m' },
    mu0:     { name:'真空磁導率',       latex:'\\mu_0 \\approx 1.25663706212\\times10^{-6}\\ \\mathrm{N\\,A^{-2}}', value:'≈ 1.25663706212×10⁻⁶ N·A⁻²' },
    kB:      { name:'波茲曼常數',       latex:'k_B = 1.380649\\times10^{-23}\\ \\mathrm{J\\,K^{-1}}', value:'1.380649×10⁻²³ J/K（定義值）' },
    NA:      { name:'亞佛加厥常數',     latex:'N_A = 6.02214076\\times10^{23}\\ \\mathrm{mol^{-1}}', value:'6.02214076×10²³ mol⁻¹（定義值）' },
    R:       { name:'氣體常數',         latex:'R = 8.314462618\\ \\mathrm{J\\,mol^{-1}\\,K^{-1}}', value:'8.314462618 J/(mol·K)' },
    G:       { name:'萬有引力常數',     latex:'G \\approx 6.67430\\times10^{-11}\\ \\mathrm{m^3\\,kg^{-1}\\,s^{-2}}', value:'≈ 6.67430×10⁻¹¹ m³·kg⁻¹·s⁻²' },
    me:      { name:'電子質量',         latex:'m_e \\approx 9.1093837015\\times10^{-31}\\ \\mathrm{kg}', value:'≈ 9.1093837015×10⁻³¹ kg' },
    mp:      { name:'質子質量',         latex:'m_p \\approx 1.67262192369\\times10^{-27}\\ \\mathrm{kg}', value:'≈ 1.67262192369×10⁻²⁷ kg' }
  },
  oph: {
    n_index:     { name:'折射率公式',           latex:'n = \\dfrac{c}{v}', value:'c：真空光速；v：介質中相速' },
    light_speed: { name:'光速/波速公式',             latex:'c = \\lambda\\,\\nu ； v = \\lambda\\,\\nu', value:'c：真空光速 299,792,458 m/s； λ：波長； ν：頻率； υ：波速；' },
    snell:       { name:'施奈爾定律',           latex:'n_1\\,\\sin i = n_2\\,\\sin r', value:'i：入射角；r：折射角' },
    critical_angle: { name: '全反射臨界角',     latex: '\\theta_c = \\arcsin\\!\\left(\\dfrac{n_2}{n_1}\\right),\\quad (n_1>n_2)', value: 'θ_c：臨界角；n₁：入射介質折射率；n₂：較稀折射率'},
    power:       { name:'屈光度公式',           latex:'D = \\dfrac{1}{f}', value:'D：屈光度（D）；f：焦距（m，符號依高斯記號）' },
    newton:      { name:'牛頓關係式（薄透鏡）',  latex:'x\\,x\' = f\\,f\'', value:'x：物點至第一焦點距；x\'：像點至第二焦點距' },
    refr_surf:   { name:'曲率折射面公式',        latex:'\\dfrac{n_2}{v} - \\dfrac{n_1}{u} = \\dfrac{n_2 - n_1}{R}', value:'u/v：物/像距；R：曲率半徑（符號依高斯記號）' },
    f1_surface:  { name:'第一焦點（折射面）',    latex:'f = -\\dfrac{n_1\\,R}{\\,n_2 - n_1\\,}', value:'物方焦距' },
    f2_surface:  { name:'第二焦點（折射面）',    latex:'f\' = \\dfrac{n_2\\,R}{\\,n_2 - n_1\\,}', value:'像方焦距' },
    magnification: { name: '橫向放大率',        latex: 'm = \\dfrac{y\'}{y} = -\\dfrac{d_i}{d_o}', value: 'm：橫向放大率；y\'/y：像高/物高；d_i/d_o：像距/物距（高斯符號）'},
    total_mag:   { name: '總放大率（厚透鏡）',    latex: "M_{\\mathrm{thick}} = \\left(\\dfrac{L}{L'}\\right)_{1}\\times\\left(\\dfrac{L}{L'}\\right)_{2}", value: '以聚散度表示：兩表面之 (L/L′) 相乘；L 為入射聚散度，L′ 為出射聚散度（單位 D）'},
    vergence:    { name:'聚散度關係式',         latex:'L\' = L + F', value:'L = n/l；L\' = n\'/l\'; F：屈光力' },
    vertex_shift:    { name:'頂點距前移/後移（隱眼公式）', latex:'F_2 = \\dfrac{F_1}{1 - d\\,F_1}', value:'d 單位(m)；鏡片向眼移動 d>0。例：眼鏡→隱眼換算' },
    accom_vergence:  { name:'調節之聚散度關係式', latex:'L + F_A = F_{\\mathrm{FP}},\\quad L=\\tfrac{1}{l},\\; F_{\\mathrm{FP}}=\\tfrac{1}{l_{\\mathrm{FP}}}', value:'l：物距(m)；F_A：角膜平面調節(D)；遠點屈光度 F_FP（近視為負）' },
    ametropia_verg:  { name:'屈光不正之聚散度關係式', latex:'L\' = L + F_{\\text{eye}},\\quad L=\\tfrac{n}{l},\\; L\'=\\tfrac{n\'}{l\'}', value:'完全成像於視網膜需 L\' 與眼軸相符；1/L 為遠點距，1/L\' 近似對應眼軸長（模型眼）' },
    convex_lens_imaging: { name: '凸透鏡成像（薄透鏡，f>0）', table: { headers: ['物距 s', '像位置 s′', '像別'], rows: [['s > 2f','f < s′ < 2f', '實像、倒立、縮小'],['s = 2f','s′ = 2f','實像、倒立、等大'],['f < s < 2f','s′ > 2f','實像、倒立、放大'],['s = f','s′ → ∞','平行光（無成像）'],['0 < s < f','s′<0（物側）','虛像、正立、放大']]},note: '凹透鏡成像：任意物距皆得虛像、正立、縮小，像位在物側（s′ < 0，m 介於 0 與 1）。'},
    concave_mirror_imaging: { name: '凹面鏡成像（焦距 f>0，以主軸約定）',table: {headers: ['物距 s', '像位置 s′', '像別'],rows: [['s > 2f', 'f < s′ < 2f','實像、倒立、縮小'],['s = 2f','s′ = 2f','實像、倒立、等大'],['f < s < 2f','s′ > 2f','實像、倒立、放大'],['s = f','s′ → ∞', '平行光（無成像）'],['0 < s < f','s′ < 0（鏡後）','虛像、正立、放大']]},note: '凸面鏡：任意物距皆得虛像、正立、縮小，像位在鏡後；平面鏡：虛像、正立、等大，像距=物距。'},
    purkinje_images: { name: '普金傑像（Purkinje Images）', table: {headers: ['編號', '反射界面', '像別', '亮度/大小', '隨物移動'], rows: [['I','角膜前表','虛像、正立','最亮、較大','同向'],['II', '角膜後表','虛像、正立', '最小、極暗','同向'],['III','晶體前表','虛像、正立','中等','同向'],['IV','晶體後表', '實像、倒立','極暗、極小','反向']]}},
    thin_img:    { name:'薄透鏡成像',           latex:'\\dfrac{1}{f} = \\dfrac{1}{d_o} + \\dfrac{1}{d_i}', value:'f：焦距；d_o/d_i：物/像距' },
    nominal:     { name:'標稱屈光力',           latex:'F_t = F_1 + F_2', value:'薄透鏡近似值屈光力（忽略厚度影響）' },
    Fe:          { name:'等效屈光力',           latex:'F_e = F_1 + F_2 - \\dfrac{t}{n}\\,F_1 F_2', value:'厚鏡等效單薄透鏡之屈光力' },
    Fv_front:    { name:'前頂點屈光力',         latex:'F_v = \\dfrac{F_1}{1 - \\dfrac{t}{n}F_2}', value:'測於前頂點' },
    Fv_back:     { name:'後頂點屈光力',         latex:'F_v\' = \\dfrac{F_2}{1 - \\dfrac{t}{n}F_1}', value:'測於後頂點' },
    H1:          { name:'第一主平面位置',       latex:'H = -\\dfrac{t}{n}\\,\\dfrac{F_2}{F_e}', value:'自第一表面量出（向右為正）' },
    H2:          { name:'第二主平面位置',       latex:'H\' = \\dfrac{t}{n}\\,\\dfrac{F_1}{F_e}', value:'自第二表面量出（向右為正）' },
    SM:          { name:'眼鏡放大率',           latex:'\\mathrm{SM} \\approx \\underbrace{\\dfrac{1}{1 - \\dfrac{t}{n}F_1}}_{\\text{Shape}}\\;\\times\\;\\underbrace{\\dfrac{1}{1 - d_v F_e}}_{\\text{Power}}', value:'d_v：頂點距（m）' },
    prism_min:   { name:'稜鏡最小偏向角',        latex:'\\delta_{\\min} = 2\\,\\arcsin\\!\\big(n\\,\\sin\\tfrac{A}{2}\\big) - A', value:'A：稜鏡頂角（弧度）' },
    prism_disp:  { name:'稜鏡偏移距離（薄稜鏡）', latex:'\\Delta \\approx L\\,\\tan\\delta,\\quad \\delta \\approx (n-1)A', value:'L：到幕距；A：頂角（小角度近似）' },
    prentice:    { name:'Prentice 法則',        latex:'P = c\\,F', value:'P：稜鏡度（△）；c：偏心量（cm）；F：D' },
    prism_base:  { name:'鏡片稜鏡基底厚度',      latex: '\\Delta = \\dfrac{100\\,g\\,(n-1)}{d}', value:'Δ：稜鏡度；g：基底厚度差；d：鏡片直徑（g、d 同單位）；n：折射率' },
    prism_compo: { name:'合成稜鏡（座標）',      latex:'P = \\sqrt{P_x^2 + P_y^2},\\; \\theta = \\operatorname{atan2}(P_y,P_x)', value:'θ：由 +x 逆時針' },
    prism_decomp:{ name:'分解稜鏡（座標）',      latex:'P_x = P\\cos\\theta,\\; P_y = P\\sin\\theta', value:'將稜鏡分解為水平/垂直分量' },
    thick_hint:  { name:'厚透鏡提示（等效法）',  latex:'\\boxed{\\;F_e,\\ H,\\ H\'\\;\\Rightarrow\\; \\text{以主平面作薄透鏡成像}\\;}', value:'以主平面替代求像' },
    mirror:      { name:'面鏡反射公式（球面鏡）', latex:'\\dfrac{1}{f} = \\dfrac{1}{s} + \\dfrac{1}{s\'},\\quad f = \\dfrac{R}{2}', value:'符號依高斯記號' },
    lensmaker:   { name:'薄透鏡造鏡者公式',       latex:'F = \\left(\\dfrac{n}{n_0}-1\\right)\\!\\left(\\dfrac{1}{R_1}-\\dfrac{1}{R_2}\\right)', value:'n_0 為周圍介質' },
    oblique_astig: { name: '斜散光差（斜向像差）', latex: 'F_{\\mathrm{eff}} = F\\left(1 + \\dfrac{\\sin^{2}\\theta}{2n}\\right)', value: 'θ：入射角；n：折射率；F：名義屈光力。前傾：F@180；面彎：F@090'},
    oblique_astig_power: { name: '斜散光差屈光力（斜向像差）', latex: 'F_{\\mathrm{OA}} = F\\,\\tan^{2}\\theta', value: 'θ：斜視角；F：名義屈光力'}
  },
  vis:{
    hof_avg:         { name:'Hofstetter（平均值）', latex:'AA_{\\text{avg}}(A) = 18.5 - 0.3A\\;\\mathrm{D}', value:'A：年齡（歲）；AA：調節幅度（D）' },
    hof_max:         { name:'Hofstetter（最大值）', latex:'AA_{\\text{max}}(A) = 25 - 0.4A\\;\\mathrm{D}', value:'A：年齡（歲）；AA：調節幅度（D）' },
    hof_min:         { name:'Hofstetter（最小值）', latex:'AA_{\\text{min}}(A) = 15 - 0.25A\\;\\mathrm{D}', value:'A：年齡（歲）；AA：調節幅度（D）；最小值臨床較常應用' },
    donders_table:   { name: "Donder's table（年齡調節幅度）",  table: { headers: ["年齡(歲)", "調節幅度 (D)"], rows: [ [10, 14.0],[15, 12.0],[20, 10.0],[25, 8.5],[30, 7.0],[35, 5.5],[40, 4.5],[45, 3.5],[50, 2.5],[55, 1.75],[60, 1.00],[65, 0.50],[70, 0.25],[75, 0]]},note: "經典估計，個體差異可達 ±2D，僅供參考。"},
    mbs:             { name: '最小鏡坯尺寸（MBS）', latex: '\\mathrm{MBS} = \\mathrm{FPD} - \\mathrm{PD} + \\mathrm{ED} + 2', value: 'MBS：鏡坯最小直徑（mm）；FPD：框幾何中心距（Frame PD, mm）；PD：瞳距（mm）；ED：鏡圈最大直徑（mm）；+2 mm 為加工預留量。'},
    decentration_h:  { name: '屈光加工水平移心', latex: 'H = \\dfrac{\\mathrm{FD} - \\mathrm{PD}}{2}', value: 'H：每眼水平移心量（mm）；FD：框距/框瞳距（FPD, mm）；PD：雙眼瞳距（mm）。單眼計算：H_R = \\tfrac{\\mathrm{FPD}}{2} - \\mathrm{MPD}_R；H_L = \\tfrac{\\mathrm{FPD}}{2} - \\mathrm{MPD}_L。'},
    polar_block:     { name:'Malus定律（偏光遮光率）', latex:'T = \\dfrac{I}{I_0} = \\cos^{2}\\!\\theta,\\quad B = 1 - T = \\sin^{2}\\!\\theta', value:'θ：偏振方向相對角；T：透過率；B：遮光率' },
    vogel:           { name:'沃格爾公式（基弧選擇）', latex:'\\mathrm{BC} = \\begin{cases} SE + 6.00, & \\text{正鏡} \\\\ \\dfrac{SE}{2} + 6.00, & \\text{負鏡} \\end{cases}', value:'BC：基弧（D）；SE：球等效（D）；經典 Vogel 配鏡經驗式' },
    edge_thickness:  { name:'鏡片邊緣厚度（近似）', latex:'t_e \\approx t_c + \\dfrac{|F|\\,D^{2}}{2000\\,(n-1)}', value:'負鏡近似；D：有效徑(mm)；n：折射率；F：屈光力(D)。正鏡中心厚度增加同項' },
    abbe_dispersion: { name: '色散力／阿貝數', latex: 'V_{d} = \\dfrac{n_{d}-1}{n_{F}-n_{C}},\\quad \\omega = \\dfrac{1}{V_{d}}', value: 'n_F=486.1nm（F 線）, n_d=587.6nm（d 線）, n_C=656.3nm（C 線）。Vd 越大 → 色散越小；色散力 ω=1/Vd。'},
    lca:             { name:'縱向色像差', latex:'\\mathrm{LCA} = \\dfrac{F}{V}', value:'LCA：縱向色像差（D）；F：屈光力（D）；V：阿貝數' },
    tca:             { name:'橫向色像差', latex:'\\mathrm{TCA} = \\dfrac{c\\,F}{V}', value:'TCA：色像差(△)；c：偏心量(cm)；F：屈光力(D)；V：阿貝數' },
    accommodation_power: { name:'調節幅度', latex:'AA = \\dfrac{1}{l_{\\mathrm{NP}}} - \\dfrac{1}{l_{\\mathrm{FP}}}', value:'AA：調節幅度（D）；l_NP：近點距離（m）；l_FP：遠點距離（m，正視者 ≈ ∞ ⇒ 0D）' },
    grating_va:      { name:'條紋視力公式', latex:'\\mathrm{VA}_{\\text{decimal}} \\approx \\dfrac{f_{\\mathrm{cpd}}}{30},\\quad \\mathrm{MAR}\\,(\\mathrm{arcmin}) \\approx \\dfrac{30}{f_{\\mathrm{cpd}}}', value:'f_cpd：每度循環數；近似換算 Snellen：分母 ≈ 600 / f_cpd' },
    javal:           { name:'Javal’s 法則（估算總散光）', latex:'\\vec{TA} \\approx 1.25\\,\\vec{CA} + \\big(-0.50\\ \\mathrm{D} @ 90^\\circ\\big)', value:'\\vec{CA}：角膜散光向量；加上約 0.50D ATR 內部散光' },
    reflectance_normal: { name:'反射率（法線入射）', latex:'R = \\left(\\dfrac{n_1 - n_2}{n_1 + n_2}\\right)^{2}', value:'n₁、n₂：兩介質折射率；R：能量反射率' },
    transmittance:   { name:'透光率', latex:'T = \\dfrac{I}{I_0} \\approx (1 - R_1)(1 - R_2)\\,e^{-\\alpha x}', value:'I/I₀：出/入射強度；R₁,R₂：兩表面反射率；α：吸收係數；x：厚度' },
    ar_thickness:    { name:'AR 鍍膜', latex:'t = \\dfrac{\\lambda_0}{4 n_{\\mathrm{film}}}', value:'設計波長 λ₀；n_film：鍍膜折射率；單層厚為設計波長的四分之一' },
    dk_value:        { name: '氧氣滲透係數（Dk）',latex: 'Dk\\;[\\text{Barrer}] \\,=\\, 10^{-11}\\,\\dfrac{\\mathrm{cm}^2\\,\\mathrm{mL}\\,O_2}{\\mathrm{s}\\,\\mathrm{mL}\\,\\mathrm{mmHg}}', value: 'DK=擴散係數(D)*溶解係數(K)，單位：Barrer（材料與溫度相關，隱形眼鏡材料常以 35 °C 標示）上述公式為Barrer的定義'},
    dk_over_t:       { name: '氧氣傳輸率（Dk/t）', latex: '\\dfrac{Dk}{t}\\;[\\text{Barrer}/\\text{cm}] \\,=\\, 10^{-9}\\,\\dfrac{\\mathrm{cm}^2\\,\\mathrm{mL}\\,O_2}{\\mathrm{s}\\,\\mathrm{mL}\\,\\mathrm{mmHg}}',table: { headers: ['研究者', '避免類型', '透氧指標'], rows: [['Holden–Mertz','日戴水腫',  '≥ 24×10⁻⁹'],['Holden–Mertz','長戴8%水腫','≥ 24×10⁻⁹'],['Holden–Mertz','長戴4%水腫','≥ 87×10⁻⁹'],['Harvitt–Bonanno',    '日戴水腫',  '≥ 35×10⁻⁹'],['Harvitt–Bonanno','長戴水腫','≥ 125×10⁻⁹'],['Papas','輪部血管增生','≥ 125×10⁻⁹'],['Morgan–Efron','日戴中央水腫','≥ 20×10⁻⁹'],['Morgan–Efron','日戴周邊水腫','≥ 33×10⁻⁹'],]},note: 't或L：代表鏡片中央厚度或局部厚度（cm），單位：Barrer/cm。上述公式為Barrer/cm的定義與DK/t期望值研究整理。',},
    eop:             { name: '等效氧份百分比（EOP）', latex: '\\mathrm{EOP}=f\\!\\left(\\dfrac{Dk}{t}\\right)', value: 'f：不同的研究模型給出的不同的假設與生理參數，大氣氧21%=EOP最大21%，日戴避免水腫 EOP≥ 9.9%；長戴避免4%水腫EOP≥17.9%（Holden–Mertz 門檻）'},
    corneal_kr:      { name: '角膜RK轉換', latex: 'K\\,[\\mathrm{D}] = \\dfrac{337.5}{r\\,[\\mathrm{mm}]}\\quad;\\quad r\\,[\\mathrm{mm}] = \\dfrac{337.5}{K\\,[\\mathrm{D}]}', value: '採慣用折射率常數 n_k = 1.3375。'},
    hr_quarter:      { name:'增強反射鍍膜', latex: 'd_H=\\frac{\\lambda_0}{4n_H},\\; d_L=\\frac{\\lambda_0}{4n_L};\\quad R=\\left(\\frac{(n_H/n_L)^{2N}-(n_s/n_0)}{(n_H/n_L)^{2N}+(n_s/n_0)}\\right)^2', value: 'N：HL 對數；設計於 λ₀、正入射最優；對比越大與層數越多，R 越高；鍍膜多用高/低折射率交替的四分之一波堆疊。'},
    near_pd:         { name:'近用 PD（工作距離換算）', latex:'\\mathrm{NPD} \\approx \\mathrm{DPD}\\,\\frac{z}{z+v} = \\mathrm{DPD}\\,\\frac{\\mathrm{PD}_{cm}}{\\mathrm{PD}_{cm}+v_m\\,CD}', value:'DPD：遠用PD(mm)；z：工作距離(m)；v_m≈0.027 m（頂點→旋轉中心）；PD_cm=DPD/10；CD：近物刺激(△)。40cm 快速近似：NPD≈DPD−3 mm'},
    add_final:       { name: 'ADD 最終附加', latex: '\\mathrm{ADD}_{\\mathrm{final}} = \\mathrm{FCC} + \\dfrac{\\mathrm{NRA} + \\mathrm{PRA}}{2}', value: 'FCC：交叉圓柱（近點）結果；NRA/PRA：正/負相對調節；單位皆為屈光度（D）。'},
    fva_total:       { name:'融合性輻輳幅度 FVA（Total）', latex:'\\mathrm{FVA}_{\\mathrm{total}} = \\mathrm{PFV}_{\\text{break}} + \\lvert\\mathrm{NFV}_{\\text{break}}\\rvert', value:'單位 △；請註明測試距離（例：@40 cm）' },
    conv_amp_npc:    { name:'內聚幅度（NPC 法）', latex:'A_{\\mathrm{conv}} = \\dfrac{PD_{\\mathrm{cm}}}{NPC_{\\mathrm{m}}}', value:'PD：瞳距(cm)；NPC：近點輻輳距離(m)(須加上眼球迴轉半徑與頂點距離)；輸出單位 △' },
    npa_npc_compare: { name: "NPA 與 NPC 比較", table: { headers: ["", "NPA調節近點", "NPC聚合近點"], rows: [["觀察終點", "模糊點", "破裂點／回復點"],["視標", "調節性視標", "先非調節性"],["測驗","單/雙眼都要","僅雙眼"]]},note: "NPC-先非調節性視標，沒過再使用調節性視標。"},
    va_recalc:       { name:'視力值換算', latex:'\\mathrm{VA}_{new} = \\mathrm{VA}\\times \\dfrac{d_{\\text{actual}}}{d_{\\text{standard}}}', value:'以距離比修正視力：實際距離/標準距離' },
    ac_a_grad:       { name:'AC/A（梯度法）', latex:'\\dfrac{AC}{A} = \\dfrac{\\Delta\\Phi}{\\Delta L}\\;\\Big(\\frac{\\triangle}{\\mathrm{D}}\\Big)', value:'\\Delta\\Phi：相位變化(△)；\\Delta L：加減鏡(D)。備註：可能高估 A 使 AC/A 偏低；期望≈4/1' },
    ac_a_calc:       { name:'AC/A（計算型）', latex:'\\dfrac{AC}{A} = PD_{\\text{cm}} + (\\Phi_n - \\Phi_d)\\,W,\\quad W=\\dfrac{1}{d\\,(\\mathrm{m})}', value:'PD：瞳距(cm)；\\Phi：近/遠相位(△，ESO為+)；d：測試距離(m)。期望≈6/1' },
    cd_quick:        { name:'CD（近物刺激）', latex:'\\mathrm{CD} \\approx \\dfrac{PD}{4} - 1', value:'快速估算於 40 cm；PD：瞳距(mm)。更一般：CD(△)=PD(cm)/距離(m)' },
    frame_comp_prism: { name: '框架眼鏡補償異位', table: { headers: ['方式', '注意'], rows: [['處方紓解稜鏡', '稜鏡規則（公式分析）'],['調整瞳距', '屈光度'],['調整球面度數', 'AC/A']]}},
    power_comp_phoria: { name: '屈光度補償眼位', table: { headers: ['', '近視', '遠視'], rows: [['內斜', '弱矯', '強矯'],['外斜', '強矯', '弱矯']]},note:"需參考AC/A與雙眼視機能影響"},
    sheard:          { name:'Sheard’s 法則', latex:'\\text{Reserve}_{\\text{comp}} \\ge 2\\,\\lvert\\text{phoria}\\rvert,\\quad P_{\\min}=\\tfrac{2E-R}{3}', value:'補償性融合儲備≥2×斜位；處方稜鏡：E=斜位(△)，R=對側模糊點(△)；常用於EXO' },
    percival:        { name:'Percival’s 法則', latex:'\\quad P_{\\min}=\\tfrac{G}{3}-\\tfrac{2L}{3}',value: '以模糊點(blur)為依據：G＝斜位較大的模糊點」，L＝反向較小的模糊點。判準：需求應位於融合範圍的中間三分之一；若 P_{min}≤0 則不需稜鏡；常用於ESO' },
    one_to_one:      { name:'1:1 法則', latex:'\\mathrm{BO}_{\\min} = \\dfrac{\\mathrm{ESO} - \\mathrm{BI}_{\\mathrm{recovery}}}{2}', value:'近距 ESO：最小 BO 儲備 ≈ (ESO − BI 還原點)/2（單位 △）'},
    sheard_train:    { name: 'Sheard’s 訓練稜鏡', latex: '\\Delta_{\\mathrm{train}} = 2\\,\\lvert\\mathrm{phoria}\\rvert', value: '給予「反向」基底（對抗斜位方向）；單位 △，請註明測試距離'},
    percival_train:  { name: 'Percival’s 訓練稜鏡', latex: '\\Delta_{\\mathrm{train}} = \\dfrac{G_{\\mathrm{blur}}}{2}', value: 'G_blur：斜位方向「較大的模糊點」；給予反向基底；單位 △'},
    one_to_one_train: { name: '1:1 Rule 訓練稜鏡', latex: '\\Delta_{\\mathrm{train}} = \\mathrm{Recovery}_{\\mathrm{opp}}', value: '取「對向」(補償方向) 的還原點(recovery)數值作為訓練量；單位 △'},
    anterior_chamber_depth_ultrasound: { name: '前房深度計算', latex: '\\mathrm{ACD} = \\dfrac{v_{\\mathrm{aq}}\\,\\Delta t}{2}', value: 'v_{aq}：房水音速（37°C）≈ 1532 m/s；Δt：自角膜後表面到水晶體前表面之「去回」時間差（超音波圖常見讀值）。' + '若 Δt 以 μs，則 ACD[mm] ≈ 0.766 × Δt[μs]（因 1532 m/s = 1.532 mm/μs，取一半）。' + '例：Δt=4.0 μs → ACD ≈ 3.06 mm。參考音速：角膜 1550 m/s、房水 1532 m/s、水晶體 1641 m/s（37°C）。' },
    spectacle_fov_no_prism: { name: '視覺視場（眼鏡視場，無稜鏡）', latex: '2\\,\\theta = 2\\,\\arctan\\!\\left(\\dfrac{W/2}{\\,VD + r_e\\,}\\right)', value: 'W：鏡片（或鏡框有效孔徑）寬；VD：頂點距；r_e：眼球迴轉半徑（約 13–14 mm）。'},
    spectacle_fov_with_prism: { name: '實際視場（含稜鏡影響）', latex: "2\\,\\theta' \\approx 2\\,\\arctan\\!\\left(\\dfrac{W/2}{\\,VD + r_e\\,}\\right) \\;\\pm\\; \\Delta\\theta_{\\text{prism}}", value: '遠視易出現環形盲區 → 視場縮小；近視易有環形複影 → 視場增大。△θprism：大小與稜鏡量及視距幾何配置相關。'},
    prism_notation: { name: "斜視醫囑簡寫（Prism notation）", table: { headers: ["縮寫", "意義"], rows: [["D", "遠（distance）"],["N / ′", "近（near）"],["E", "內斜（eso-）"],["X", "外斜（exo-）"],["H", "上斜（hyper-）"],["P", "隱斜（phoria）"],["T", "斜視（tropia）"],["alt", "交替性（alternating）"],["(T)", "間歇性（intermittent）"]]},note: "臨床處方常用縮寫；可搭配稜鏡大小與方向書寫，例如：6△ BO @ D。"}
  },
  refr: {
    cr39:        { name:'CR-39（標準樹脂）',            latex:'n \\approx 1.499', value:'d 線（589 nm）、20°C 近似' },
    poly:        { name:'聚碳酸酯（Polycarbonate）',    latex:'n \\approx 1.586', value:'d 線（589 nm）、20°C 近似' },
    trivex:      { name:'Trivex（PPG）',                 latex:'n \\approx 1.532', value:'d 線（589 nm）、20°C 近似' },
    crown:       { name:'冕牌玻璃 （BK7 近似）',   latex:'n \\approx 1.523', value:'d 線（589 nm）、20°C 近似' },
    acrylic:     { name:'壓克力（PMMA）',     latex:'n \\approx 1.490', value:'d 線（589 nm）、~20°C' },
    water:       { name:'水',             latex:'n \\approx 1.333', value:'d 線（589 nm）、~20°C' },
    model_eye:   { name:'全眼（簡化模型眼）', latex:'n \\approx 1.333', value:'Reduced Eye 等效近似' },
    vitreous:    { name:'玻璃體',         latex:'n \\approx 1.336', value:'d 線（589 nm）' },
    crystalline: { name:'水晶體（等效）',  latex:'n \\approx 1.406', value:'實際為梯度折射率；此為等效值' },
    aqueous:     { name:'房水',           latex:'n \\approx 1.336', value:'d 線（589 nm）' },
    cornea:      { name:'角膜',           latex:'n \\approx 1.376', value:'角膜實折射率（非 1.3375 有效值）' },
  },
  lv:{
    eq_mag_power:  { name:'等效放大鏡屈光度', latex:'F_{eq} = X\\,\\dfrac{VA_{old}}{VA_{new}},\\quad X\\in\\{\\lvert F_{wear}\\rvert,\\ 1/l\\}', value:'X：配戴度數或工作距離倒數(1/m)' },
    end_evp:       { name: '最佳閱讀距離(EVD) / 等效視度(EVP)', latex: '\\frac{l_{old}}{VA_{old}} = \\frac{l_{new}}{VA_{new}},\\quad \\mathrm{END}=l_{new},\\quad \\mathrm{EVP}=\\frac{1}{\\mathrm{END}}', value: 'l_old：原距離(m)；VA_old：原視力；l_new：新距離(m)；VA_new：新視力（故 l_new = l_old \\cdot VA_{new}/VA_{old}）'},
    jnd:           { name:'恰能分辨差（JND）', latex:'\\mathrm{JND\\ (D)} \\approx \\dfrac{\\text{Snellen 分母}}{100}', value:'例：20/200 ⇒ JND≈2.00D（試片步距≈±1.00D）' },
    fov_simple:    { name:'視野寬度（近似）', latex:'\\mathrm{FOV} \\approx \\dfrac{\\varnothing}{v}\\,f', value:'\\varnothing：鏡片直徑；v：頂點距；f：凸透鏡焦距（粗略近似）' },
    reading_speed_targets: { name: '閱讀速度與目標', table: { headers: ['閱讀速度', '視力保留', '閱讀目標往下'], rows: [['快速閱讀', '3：1','5 log steps'],['流暢閱讀', '2：1','3 log steps'],['點式閱讀','1.3：1','1 log steps']]}},
    kestenbaum:    { name:'Kestenbaum 規則（近用估算）', latex: 'F_{\\mathrm{near}} \\approx \\dfrac{1}{\\mathrm{VA}_{\\mathrm{dec}}} = \\dfrac{\\text{Snellen}_{\\mathrm{den}}}{\\text{Snellen}_{\\mathrm{num}}}\\;\\mathrm{D}', value: '例：20/200→10D；6/60→10D。為初步估算，臨床常需 ×1.5～2 以達舒適閱讀。'},
    telescope_compare: { name: '伽利略 & 克卜勒望遠鏡比較表', table: { headers: ['指標', '伽利略', '克卜勒'], rows: [['光學結構', '凸物+凹目(正立)', '凸物+凸目(倒像)'],['鏡筒長度', '較短', '較長'],['視野', '較小', '較大'],['近視放大率', '減少', '增加'],['遠視放大率', '增加', '減少']]},note: '未矯正近視兩種望遠鏡皆縮短鏡筒長度，遠視則反之；結論：未矯正遠視 → 伽利略較合適；未矯正近視 → 克卜勒較合適。'},
    tube_len:      { name:'望遠鏡鏡筒長', latex:'L_{tube}^{\\mathrm{Kepler}}=f_o+f_e,\\quad L_{tube}^{\\mathrm{Galileo}}=f_o-|f_e|', value:'f_o：物鏡焦距；f_e：目鏡焦距' },
    telescope_M:   { name: '望遠鏡放大倍率', latex: 'M = -\\dfrac{F_e}{F_o} = \\dfrac{f_o}{f_e} = \\dfrac{D_{\\mathrm{obj}}}{D_{\\mathrm{exit}}}', value: 'F_o/F_e：物鏡/目鏡屈光力（D）；f_o/f_e：物鏡/目鏡焦距；D_obj/D_exit：入/出瞳直徑。Kepler 倒像取負號，實務多報 |M|。'},
    telescope_near:{ name:'望遠鏡近用（加近用鏡）', latex:'l \\approx \\dfrac{1}{F_{cap}}', value:'加裝近用鏡 F_cap（D）後可在 l=1/F_cap（m）處閱讀' },
    compound_scope:{ name:'複式望遠鏡（望遠鏡+鏡片）', latex:'M_{total} \\approx M_{tel}\\times M_{aux},\\quad M_{aux}\\approx \\dfrac{F_{aux}}{4}\\ (25\\,\\mathrm{cm})', value:'F_{aux}：附加鏡視度（D）' },
    ang_mag:       { name:'角放大', latex:'M_\\theta = \\dfrac{\\theta_{new}}{\\theta_{old}}', value:'新視角/原視角' },
    size_mag:      { name:'物體放大', latex:'M_{size} = \\dfrac{s_{new}}{s_{obj}}', value:'放大後尺寸/物體尺寸' },
    dist_mag:      { name:'距離增大', latex:'M_{dist} = \\dfrac{l_{old}}{l_{new}}', value:'原距離/新距離' },
    proj_mag:      { name:'投射放大', latex:'M_{proj} = \\dfrac{s_{screen}}{s_{object}}', value:'投影大小/目標大小' },
    magnifier_M:   { name:'放大鏡放大倍率', latex: 'M_{\\infty}=\\dfrac{D}{f}=D\\,F,\\quad M_{NP}=1+\\dfrac{D}{f}=1+D\\,F', value: 'D：近點視度（常取 4D=25cm）；f：焦距(m)；F=1/f（D）。M_∞：虛像在無窮遠（放鬆）；M_NP：虛像在近點（最大倍率）。'},
    std_mag_25:    { name:'等效(標準)放大率（25 cm）', latex:'M_{25} = \\dfrac{F}{4}', value:'參考視距 25 cm（4D）；常規放大率=等效放大率+1' }
  }
};

const constCat   = document.getElementById('constCat');
const constItem  = document.getElementById('constItem');
const constName  = document.getElementById('constName');
const constFormula = document.getElementById('constFormula');
const constValue = document.getElementById('constValue');

function fillCats(){
  constCat.innerHTML = '';
  constCat.add(new Option('視覺光學（Visual Optics）','oph'));
  constCat.add(new Option('視光學綜論（Optometry Overview）','vis'));
  constCat.add(new Option('低視力學（low vision）','lv'));
  constCat.add(new Option('折射率（Refractive index）','refr'));
  constCat.add(new Option('光學（Optics）','optics'));
  constCat.add(new Option('物理（Physics）','physics'));
  constCat.value = 'oph';
  fillItems();
  renderConst();
}
function fillItems(){
  const group = CONST_DB[constCat.value];
  constItem.innerHTML = '';
  Object.entries(group).forEach(([key,obj])=>{
    constItem.add(new Option(obj.name, key));
  });
}
function renderConst(){
  const group = CONST_DB[constCat.value];
  const key = constItem.value;
  const obj = group[key];
  constName.textContent = obj.name;
  constFormula.innerHTML = `\\(${obj.latex}\\)`;
  constValue.textContent = obj.value;
  if (window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise([constFormula]);
}
function buildMiniTable(tbl) {
  const thead = `<thead><tr>${
    tbl.headers.map(h => `<th>${h}</th>`).join('')
  }</tr></thead>`;
  const tbody = `<tbody>${
    tbl.rows.map(r => `<tr>${
      r.map(c => `<td>${c}</td>`).join('')
    }</tr>`).join('')
  }</tbody>`;
  return `<table class="const-mini-table">${thead}${tbody}</table>`;
}

function renderConst() {
  const cat  = constCat.value;
  const key  = constItem.value;
  const item = CONST_DB[cat]?.[key];
  if (!item) return;
  constName.textContent = item.name || '';
  constFormula.innerHTML = item.latex ? `\\(${item.latex}\\)` : '';
  if (item.table) {
    constValue.innerHTML = buildMiniTable(item.table) +
      (item.note ? `<div style="margin-top:6px;opacity:.8;">${item.note}</div>` : '');
  } else {
    constValue.textContent = item.value || (item.note || '');
  }
  if (window.MathJax && constFormula.innerHTML) {
    MathJax.typesetPromise?.([constFormula]);
  }
}

fillCats();
fillItems();
renderConst();

constCat.addEventListener('change', ()=>{ fillItems(); renderConst(); });
constItem.addEventListener('change', renderConst);

  /* === 光學十字邏輯 === */
(() => {
  const pS = document.getElementById('pS');
  if (!pS) return;

  const pC = document.getElementById('pC');
  const pA = document.getElementById('pA');
  const mS = document.getElementById('mS');
  const mC = document.getElementById('mC');
  const mA = document.getElementById('mA');
  const kD1 = document.getElementById('kD1');
  const kA  = document.getElementById('kA');
  const kD2 = document.getElementById('kD2');
  const kA2 = document.getElementById('kA2');

  const crossG  = document.getElementById('crossG');
  const labAxis = document.getElementById('labAxis');
  const labPerp = document.getElementById('labPerp');
  const clVD      = document.getElementById('clVD');     
  const clStepSel = document.getElementById('clStep');    
  const clToric   = document.getElementById('clToricOut'); 
  const clSphOnly = document.getElementById('clSphOut');   

  const toricSphere  = document.getElementById('toricSphere');
  const toricLoc     = document.getElementById('toricLoc');
  const toricMinusEl = document.getElementById('toricMinusLine');
  const toricPlusEl  = document.getElementById('toricPlusLine');
  const SELECTOR_MODE = 'sphere';

  const sizeInput = document.getElementById('crossSize');
  const sizeLabel = document.getElementById('crossSizeVal');

  let scale = sizeInput ? Number(sizeInput.value)/100 : 1;
  const BASE_LEN  = 70;
  const LABEL_PAD = 9;
  [pS,pC,pA,mS,mC,mA,kD1,kA,kD2,kA2,toricSphere].forEach(el=>{
    try { el.type = 'text'; } catch(_) {}
    el.setAttribute('inputmode','tel');
    el.addEventListener('input', () => {
      const caret = el.selectionStart;
      const cleaned = (el===pA || el===mA || el===kA || el===kA2)
        ? cleanTel(el.value).replace(/^-/, '') 
        : cleanTel(el.value);
      el.value = cleaned;
      try { el.setSelectionRange(caret, caret); } catch(_) {}
    }, {passive:true});
  });
  [mS,mC,mA].forEach(el=>{ if (el) el.readOnly = true; });
  
  function injectSignBtn(input, onFlip) {
    if (!input) return;
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'mini-sign-btn';
    btn.textContent = '±';
    input.insertAdjacentElement('afterend', btn);
    btn.addEventListener('click', () => {
      const v = parseNum(input.value);
      if (!Number.isFinite(v)) return;
      const nv = -v;
      input.value = isZero(nv) ? '0.00' : fmtInputD(nv);
      if (typeof onFlip === 'function') onFlip();
      input.dispatchEvent(new Event('input',  {bubbles:true}));
      input.dispatchEvent(new Event('change', {bubbles:true}));
    });
  }
  injectSignBtn(pS, () => updateAllFromPrimary());
  injectSignBtn(pC, () => updateAllFromPrimary());
  injectSignBtn(kD1, () => updateAllFromMeridians());
  injectSignBtn(kD2, () => updateAllFromMeridians());


  let updating = false;
  let editingEl = null;
  let toricSphereTouched = false;
  const numInputs  = [pS,pC,mS,mC,kD1,kD2].filter(Boolean);
  const axisInputs = [pA,mA,kA,kA2].filter(Boolean);

  const round2 = x => Number(x).toFixed(2);
  const isZero = v => Math.abs(Number(v)) < 0.005;
  const fmtSC  = x => (Number(x) >= 0 ? '+' : '') + round2(x).replace(/\.00$/,'');
  const fmtInputD = v => isZero(v) ? '0.00' : fmtSC(v);
  const fmtA3  = a => String(a).padStart(3,'0');
  const fmtLabelD = v => isZero(v) ? 'Plano' : `${fmtSC(v)}D`;

  const normAxis = a => { let x = Math.round(Number(a)||0)%180; if(x<=0)x+=180; return x; };
  const axisRaw0_179 = a => { let x = Math.round(Number(a)||0)%180; if(x<0)x+=180; return x; };
  const axisSwap90 = a => { const A = normAxis(a); return A>90 ? A-90 : A+90; };

  const cleanSignedDecimal = s => {
    s = String(s ?? '')
      .replace(/\u2212|–|—/g,'-')
      .replace(/[^\d\.\-]/g,'');
    let neg = false;
    if (s.startsWith('-')) { neg = true; s = s.slice(1); }
    s = s.replace(/-/g,'');
    const parts = s.split('.');
    const head = parts.shift() || '';
    const tail = parts.join('');
    let out = head.replace(/^0+(\d)/,'$1');
    if (tail) out += '.' + tail.replace(/\./g,'');
    if (out === '' || out === '.') out = '0';
    return (neg ? '-' : '') + out;
  };
  const cleanAxisTyping = s => String(s ?? '').replace(/[^\d]/g,'').slice(0,3);
  const cleanTel = (s) => {
    s = String(s ?? '')
        .replace(/[−–—]/g, '-')  
        .replace(/,/g, '.')      
        .replace(/[^\d.\-]/g, ''); 
    s = s.replace(/(?!^)-/g, '');
    const firstDot = s.indexOf('.');
    if (firstDot !== -1) {
      s = s.slice(0, firstDot + 1) + s.slice(firstDot + 1).replace(/\./g, '');
    }
    return s;
  };
  const parseNum = v => {
    const s = cleanSignedDecimal(v);
    const n = parseFloat(s);
    return isFinite(n) ? n : NaN;
  };
  function clearToricUI(){
    if (toricMinusEl) { toricMinusEl.innerHTML=''; toricMinusEl.style.display='none'; }
    if (toricPlusEl ) { toricPlusEl .innerHTML=''; toricPlusEl .style.display='none'; }
    setToricHint('');
  }  
  toricSphere?.addEventListener('input', () => {
    toricSphereTouched = true;
    updateToric();
  });
  toricLoc?.addEventListener('change', () => {
    updateToric();
  });
  function fmtSigned0(n){
    if (!Number.isFinite(n)) return '';
    if (Math.abs(n) < 0.005) return '0.00';
    return (n >= 0 ? '+' : '-') + Math.abs(n).toFixed(2);
  }
    function roundToStep(x, step){
    if (!isFinite(x)) return NaN;
    return Math.round(x/step)*step;
  }
  function effAtCornea(F, d_mm){
    const d = (Number(d_mm)||0)/1000; 
    return F / (1 - d*F);
  } 

  function updateCL(){
    if (!clToric || !clSphOnly) return;
    const S = parseNum(pS?.value);
    const C = parseNum(pC?.value);
    const A = parseNum(pA?.value);
    if (!isFinite(S) || !isFinite(C) || !isFinite(A)){
      clToric.value = ''; clSphOnly.value = '';
      return;
    }
    const vd   = parseFloat(clVD?.value) || 12;          
    const step = parseFloat(clStepSel?.value) || 0.25;      
    const F1 = effAtCornea(S,      vd);
    const F2 = effAtCornea(S + C,  vd);
    const rF1 = roundToStep(F1, step);
    const rF2 = roundToStep(F2, step);
    let Sm, Cm, Ax;
    if (rF1 >= rF2){
      Sm = rF1; Cm = rF2 - rF1; Ax = normAxis(A);     
    }else{
      Sm = rF2; Cm = rF1 - rF2; Ax = normAxis(axisSwap90(A)); 
    }
    clToric.value = `${fmtSigned0(Sm)}DS/${fmtSigned0(Cm)}DC × ${fmtA3(Ax)}`;
    const SE_spec = S + C/2;
    const SE_cl   = roundToStep(effAtCornea(SE_spec, vd), step);
    clSphOnly.value = `${fmtSigned0(SE_cl)}DS`;
  }
  clVD?.addEventListener('input',  updateCL);
  clStepSel?.addEventListener('change', updateCL);
  [pS,pC,pA].forEach(el => el?.addEventListener('input', updateCL));

  function formatField(el){
    if (!el) return;
    const v = parseNum(el.value);
    if (!Number.isFinite(v)) return;
    if (axisInputs.includes(el)) {
      el.value = fmtA3(normAxis(v));
    } else {
      el.value = fmtInputD(v);          
    }
  }
  function formatAllExcept(except){
    [...numInputs, ...axisInputs].forEach(el=>{
      if (el && el !== except) formatField(el);
    });
  }
  let lastFocused = null;
  [...numInputs, ...axisInputs].forEach(el=>{
    el.addEventListener('focus', () => {
      if (lastFocused && lastFocused !== el) formatField(lastFocused);
      editingEl   = el;    
      lastFocused = el;
    });
  });
  function transpose(S,C,A){ return { S:S+C, C:-C, A:axisSwap90(A) }; }
  function updateLabels(S,C,A){
    const th  = -axisRaw0_179(A) * Math.PI/180; 
    const thP = th + Math.PI/2;
    const R   = BASE_LEN * scale;
    const pad = LABEL_PAD;
    const sideForTop = t => (Math.sin(t) >= 0 ? -1 : 1);
    const sAxis = sideForTop(th);
    const sPerp = sideForTop(thP);

    const fmtA3H = a => String(axisRaw0_179(a)).padStart(3,'0');
    labAxis.setAttribute(
      'transform',
      `rotate(${th*180/Math.PI}) translate(${sAxis*(R+pad)},0) rotate(${-th*180/Math.PI})`
    );
    labAxis.textContent = `${fmtLabelD(S)} @${fmtA3H(A)}`;
    labPerp.setAttribute(
      'transform',
      `rotate(${thP*180/Math.PI}) translate(${sPerp*(R+pad)},0) rotate(${-thP*180/Math.PI})`
    );
    labPerp.textContent = `${fmtLabelD(S+C)} @${fmtA3H(axisSwap90(A))}`;
  }
  function updateCross(S,C,A){
    curS=S; curC=C; curA=A;
    const a = -axisRaw0_179(A);
    crossG.setAttribute('transform', `rotate(${a}) scale(${scale})`);
    updateLabels(S,C,A);
  }
  function updateAllFromPrimary(){
    if (updating) return;
    const S0 = parseNum(pS.value);
    const C0 = parseNum(pC.value);
    const A0 = parseNum(pA.value);
    if (!isFinite(S0) || !isFinite(C0) || !isFinite(A0)){
      [mS,mC,mA,kD1,kA,kD2,kA2].forEach(el => el && (el.value=''));
      updateCross(0,0,0);
      updating=false;updateCL();
      return;
    }
    const A = normAxis(A0);
    updating = true;
    if (editingEl !== pS) pS.value = fmtInputD(S0);
    if (editingEl !== pC) pC.value = fmtInputD(C0);
    if (editingEl !== pA) pA.value = fmtA3(A);
    const t = transpose(S0, C0, A);
    mS.value = fmtInputD(t.S);
    mC.value = fmtInputD(t.C);
    mA.value = fmtA3(t.A);
    if (editingEl !== kD1) kD1.value = fmtInputD(S0);
    if (editingEl !== kA ) kA .value = fmtA3(A);
    if (editingEl !== kD2) kD2.value = fmtInputD(S0 + C0);
    if (editingEl !== kA2) kA2.value = fmtA3(normAxis(A + 90));

    updateCross(S0, C0, A);
    updating = false;
  }
  function updateAllFromMeridians(){
    if (updating) return;
    const D1 = parseNum(kD1.value);
    const A1 = parseNum(kA.value);
    const D2 = parseNum(kD2.value);
    if (!isFinite(D1) || !isFinite(A1) || !isFinite(D2)){
      [pS,pC,pA,mS,mC,mA].forEach(el => el && (el.value=''));
      updateCross(0,0,0);
      updating=false; updateCL();
      return;
    }
    const A = normAxis(A1);
    const S = D1;
    const C = D2 - D1;
    updating = true;

    if (editingEl !== pS) pS.value = fmtInputD(S);
    if (editingEl !== pC) pC.value = fmtInputD(C);
    if (editingEl !== pA) pA.value = fmtA3(A);

    const t = transpose(S, C, A);
    mS.value = fmtInputD(t.S);
    mC.value = fmtInputD(t.C);
    mA.value = fmtA3(t.A);

    if (editingEl !== kA2) kA2.value = fmtA3(normAxis(A + 90));
    if (editingEl !== kD1) kD1.value = fmtInputD(S);
    if (editingEl !== kA ) kA .value = fmtA3(A);
    if (editingEl !== kD2) kD2.value = fmtInputD(S + C);

    updateCross(S, C, A);
    updating = false;
  }

  const fmtRx = (S,C,A) => {
    const s = (Math.abs(S)<0.005) ? '0.00' : ((S>=0?'+':'') + Number(S).toFixed(2));
    const c = (Math.abs(C)<0.005) ? '0.00' : ((C>=0?'+':'') + Number(C).toFixed(2));
    const a = String(normAxis(A)).padStart(3,'0');
    return `${s}DS ${c}DC ×${a}`;
  };

  function pickBaseAndCross(a,b){
    return (Math.abs(a) <= Math.abs(b))
      ? { base:a, cross:b }
      : { base:b, cross:a };
  }
  function updateToric(){
  if (!toricSphere || !toricMinusEl || !toricPlusEl) return;
  const Bs = parseNum(toricSphere?.value);
  if (!toricSphereTouched || !Number.isFinite(Bs)) {
    clearToricUI();
    return;
  }
  const BsAbs = Math.abs(Bs);
  const S0 = parseNum(pS.value), C0 = parseNum(pC.value), A0 = parseNum(pA.value);
  if (!isFinite(BsAbs) || !isFinite(S0) || !isFinite(C0) || !isFinite(A0)){
    toricMinusEl.innerHTML = toricPlusEl.innerHTML = '';
    toricMinusEl.style.display = toricPlusEl.style.display = 'none';
    return;
  }
  const A = normAxis(A0);
  const M = (C0 <= 0) ? { S:S0,    C:C0,   A }
                      : { S:S0+C0, C: C0,  A: axisSwap90(A) };
  const D_axis = M.S;
  const D_perp = M.S + M.C;
  const isFrontSel = (toricLoc?.value === 'front');
  let Sph, T_axis, T_perp;
  if (SELECTOR_MODE === 'sphere') {
    Sph    = isFrontSel ? +BsAbs : -BsAbs;
    T_axis = D_axis - Sph;
    T_perp = D_perp - Sph;
  } else { 
    const toricOnFront = isFrontSel;
    const sgn = toricOnFront ? +1 : -1;
    T_axis = sgn * Math.abs(D_axis);
    T_perp = sgn * Math.abs(D_perp);
    Sph = D_axis - T_axis; 
  }
  const baseIsAxis = Math.abs(T_axis) <= Math.abs(T_perp);
  const baseVal  = baseIsAxis ? T_axis : T_perp;
  const baseAxis = baseIsAxis ? A      : axisSwap90(A);
  const crossVal = baseIsAxis ? T_perp : T_axis;
  const crossAxis= baseIsAxis ? axisSwap90(A) : A;
  const fmtDCx = (v, ax) => `${fmtInputD(v)}DC×${fmtA3(ax)}`;
  const fmtDS  = v => `${fmtInputD(v)}DS`;
  const frac   = (top,bottom) =>
    `<div class="frac"><div class="num">${top}</div><div class="bar"></div><div class="den">${bottom}</div></div>`;
  const topDCs   = `${fmtDCx(baseVal,  axisSwap90(baseAxis))} ／ ${fmtDCx(crossVal, axisSwap90(crossAxis))}`;
  const bottomDS = `${fmtDS(Sph)}`;
  toricMinusEl.innerHTML = frac(topDCs, bottomDS); 
  toricPlusEl .innerHTML = frac(bottomDS, topDCs); 
  const showRight = isFrontSel;
  toricPlusEl.style.display  = showRight ? '' : 'none';
  toricMinusEl.style.display = showRight ? 'none' : '';
  toricPlusEl.dataset.badge  = '負散形式（後表散光）';
  toricMinusEl.dataset.badge = '正散形式（前表散光）';
  toricPlusEl.classList.toggle('show-badge',  showRight);
  toricMinusEl.classList.toggle('show-badge', !showRight);
  toricPlusEl.classList.toggle('active',  showRight);
  toricMinusEl.classList.toggle('active', !showRight);
  const sepEl = document.getElementById('toricSep');
  if (sepEl) sepEl.style.display = 'none';
  const EPS = 0.005;
  const s1 = Math.abs(T_axis) < EPS ? 0 : Math.sign(T_axis);
  const s2 = Math.abs(T_perp) < EPS ? 0 : Math.sign(T_perp);
  let hint = '';
  const sphereOnFront = (toricLoc?.value === 'front');
  if ((s1 * s2) <= 0 && (s1 !== 0 || s2 !== 0)) {
    hint = `散光面兩子午符號相異，該透鏡正確之球弧設定為${sphereOnFront ? '後表面' : '前表面'}`;
  } else {
    const allPos = (s1 > 0 && s2 > 0);
    const allNeg = (s1 < 0 && s2 < 0);
    if (sphereOnFront && allPos) hint = '該透鏡變成雙凸透鏡，正確之球弧設定為後表面';
    if (!sphereOnFront && allNeg) hint = '該透鏡變成雙凹透鏡，正確之球弧設定為前表面';
  }
setToricHint(hint);
}

toricSphere?.addEventListener('input',  updateToric);
toricLoc   ?.addEventListener('change', updateToric);
const toricHint = document.getElementById('toricHint');
function setToricHint(msg){
  if (!toricHint) return;
  if (msg) { toricHint.textContent = msg; toricHint.style.display = ''; }
  else     { toricHint.textContent = '';  toricHint.style.display = 'none'; }
}
const __endPrimary   = updateAllFromPrimary;
const __endMeridians = updateAllFromMeridians;
updateAllFromPrimary = function(){ __endPrimary.call(this);   updateToric(); };
updateAllFromMeridians = function(){ __endMeridians.call(this); updateToric(); };
updateToric();

  [pS,pC,pA,kD1,kA,kD2,kA2].forEach(el => el && el.addEventListener('focus', () => { editingEl = el; }));

  [pS,pC,pA,kD1,kA,kD2,kA2].forEach(el => el && el.addEventListener('blur', () => {
    if (el===pS || el===pC || el===kD1 || el===kD2){
      const n = parseNum(el.value);
      if (isFinite(n)) el.value = fmtInputD(n);
    } else if (el===pA || el===kA || el===kA2){
      const n = parseNum(el.value);
      if (isFinite(n)) el.value = fmtA3(normAxis(n));
    }
    editingEl = null;
  }));

  [pS,pC,pA].forEach(el => el.addEventListener('input', updateAllFromPrimary));
  [kD1,kA,kD2,kA2].forEach(el => el.addEventListener('input', updateAllFromMeridians));

  sizeInput?.addEventListener('input', () => {
    scale = Number(sizeInput.value)/100;
    if (sizeLabel) sizeLabel.textContent = `${Math.round(scale*100)}%`;
    updateCross(curS,curC,curA);
  });
  const __origUpdateAllFromPrimary = updateAllFromPrimary;
  updateAllFromPrimary = function(){
    __origUpdateAllFromPrimary.call(this);
    formatAllExcept(editingEl);
  };

  const __origUpdateAllFromMeridians = updateAllFromMeridians;
  updateAllFromMeridians = function(){
    __origUpdateAllFromMeridians.call(this);
    formatAllExcept(editingEl);
  };
  pS.value = '0.00'; pC.value = '-1.50'; pA.value = '180';
  mS.value = '-1.50'; mC.value = '+1.50'; mA.value = '090';
  updateAllFromPrimary();
  updateCL();
})();

(() => {
  const $ = id => document.getElementById(id);
  const tbPanel = document.getElementById('toricBackPanel');
  const tbForm   = $('tbForm');
  const tbBase   = $('tbBase');   
  const tbAxis1  = $('tbAxis1');  
  const tbCross  = $('tbCross'); 
  const tbAxis2  = $('tbAxis2');     
  const tbSphere = $('tbSphere');   
  const outMinus = $('tbMinusOut');
  const outPlus  = $('tbPlusOut');  
  const tbFrac = document.querySelector('#toricBackPanel .tb-frac');
  const tbClearBtn = document.getElementById('tbClearBtn');
  const tbHint   = $('tbHint'); 
  

  const EPS = 0.005;
  const clamp180 = a => {
    let x = Math.round(num(a) || 0) % 180;
    if (x <= 0) x += 180;
    return x;
  };
  const axis90 = a => {
    const A = clamp180(a);
    return A > 90 ? A - 90 : A + 90;
  };
    const cleanSignedDecimal = s => {
    s = String(s ?? '')
      .replace(/\u2212|–|—/g,'-')
      .replace(/[^\d\.\-]/g,'');
    let neg = false;
    if (s.startsWith('-')) { neg = true; s = s.slice(1); }
    s = s.replace(/-/g,'');
    const parts = s.split('.');
    const head = parts.shift() || '';
    const tail = parts.join('');
    let out = head.replace(/^0+(\d)/,'$1');
    if (tail) out += '.' + tail.replace(/\./g,'');
    if (out === '' || out === '.') out = '0';
    return (neg ? '-' : '') + out;
  };
  const num = v => {
    const s = cleanSignedDecimal(v);
    const n = parseFloat(s);
    return Number.isFinite(n) ? n : NaN;
  };

  const setWarn = (el, on) => { if (el) el.classList.toggle('warn', !!on); };
  const setHint = msg => {
    if (!tbHint) return;
    if (msg) { tbHint.textContent = msg; tbHint.style.display = ''; }
    else { tbHint.textContent = ''; tbHint.style.display = 'none'; }
  };

  [tbBase, tbCross, tbSphere].forEach(el=>{
    if (!el) return;
    try { el.type = 'text'; } catch(e){}
    el.setAttribute('inputmode','tel');
    el.addEventListener('input', () => { el.value = cleanSignedDecimal(el.value); });
    el.addEventListener('blur',  () => {
      const v = num(el.value);
      if (Number.isFinite(v)) el.value = fmtSigned0(v);
    });
  });

  [tbAxis1, tbAxis2].forEach(el=>{
    if (!el) return;
    try { el.type = 'text'; } catch(e){}
    el.setAttribute('inputmode','numeric');
    el.addEventListener('input', () => {
      el.value = String(el.value).replace(/[^\d]/g,'').slice(0,3);
    });
    el.addEventListener('blur', () => { el.value = fmtA3(el.value); });
  });

  function forceTextTel(el){
    if (!el) return;
    try { el.type = 'text'; } catch(e){}
    el.setAttribute('inputmode','tel');
  }
  [ tbSphere, tbBase, tbCross ].forEach(forceTextTel);
  function addSignBtn(el){
    if (!el || el.dataset.hasSign==='1') return;
    const b = document.createElement('button');
    b.type = 'button';
    b.className = 'mini-sign-btn';
    b.textContent = '±';
    b.addEventListener('click', () => {
        cutSound.currentTime = 0;
        cutSound.play();
      const v = num(el.value);
      if (!Number.isFinite(v)) return;
      const nv = (Math.abs(v) < EPS) ? 0 : -v;
      el.value = fmtSigned0(nv);
      el.dispatchEvent(new Event('input', {bubbles:true}));
      el.dispatchEvent(new Event('change',{bubbles:true}));
    });
    el.insertAdjacentElement('afterend', b);
   el.dataset.hasSign='1';
  }
  [ tbSphere, tbBase, tbCross ].forEach(addSignBtn);
  
  function clearInvalid(){
    [tbSphere,tbBase,tbCross,tbAxis1,tbAxis2].forEach(el=>el&&el.classList.remove('is-invalid'));
  }
  function markInvalid(arr){ arr.forEach(el=>el&&el.classList.add('is-invalid')); }
  ['tbBase','tbCross','tbSphere'].forEach(id => bindSignBtn(document.getElementById(id)));

  function bindSignBtn(input){
    if (!input) return;
    const root = tbPanel || document;
    let btn = root.querySelector(`.mini-sign-btn[data-target="${input.id}"]`)
           || (input.nextElementSibling?.classList?.contains('mini-sign-btn') ? input.nextElementSibling : null);
    if (!btn) return;
    btn.addEventListener('click', () => {
        cutSound.currentTime = 0;
        cutSound.play();
      let v = num(input.value);
      if (!Number.isFinite(v)) v = 0;
      input.value = fmtSigned0(-v);
      updateToricBack();
    });
  }
  [tbBase, tbCross, tbSphere].forEach(bindSignBtn);

  const fmtA3 = a => String(clamp180(a)).padStart(3,'0');
  function fmtSigned0(n){
    if (!Number.isFinite(n)) return '';
    if (Math.abs(n) < 0.005) return '0.00';
    return (n >= 0 ? '+' : '-') + Math.abs(n).toFixed(2);
  }
  const A1 = document.getElementById('tbAxis1'); 
  const A2 = document.getElementById('tbAxis2'); 
  if (!A1 || !A2) return;
    const norm180 = n => {       
    let a = Math.round(Number(n)||0) % 180;
    if (a <= 0) a += 180;
    return a;
  };
  const pad3 = a => String(a).padStart(3,'0');
  function bindSignButton(input){
    if (!input) return;
    const btn = (input.nextElementSibling && input.nextElementSibling.classList?.contains('mini-sign-btn'))
      ? input.nextElementSibling
      : document.querySelector(`.mini-sign-btn[data-target="${input.id}"]`);
    if (!btn) return;
    btn.addEventListener('click', () => {
      try{ cutSound.currentTime = 0; cutSound.play(); }catch(e){}
      if (!(typeof val === 'number' && isFinite(val))) return;
      const flipped = -val;
      input.value = fmtSigned0(flipped);
      input.dispatchEvent(new Event('input',  { bubbles:true }));
      input.dispatchEvent(new Event('change', { bubbles:true }));
      if (input === pS || input === pC || input === pA) {
        updateAllFromPrimary();
      } else if (input === kD1 || input === kD2 || input === kA || input === kA2) {
        updateAllFromMeridians();
      }
    });
  }
  [pS, pC, kD1, kD2].forEach(bindSignButton);

  function formatAxis(el){
    if (!el || el.value === '') return;
    el.value = pad3(norm180(el.value));
  }
  function applyTBLayout(){ const isBack = tbForm.value === 'back'; tbFrac.classList.toggle('back-mode', isBack); }
  tbForm.addEventListener('change', () => { applyTBLayout(); updateToricBack(); });
  applyTBLayout();

  function autoPairFrom(changed){
    if (changed === A1 && (!A2.value || A2.dataset.auto === '1')) {
      const a2 = norm180(Number(A1.value) + 90);
      A2.value = pad3(a2);
      A2.dataset.auto = '1';
    } else if (changed === A2 && (!A1.value || A1.dataset.auto === '1')) {
      const a1 = norm180(Number(A2.value) - 90);
      A1.value = pad3(a1);
      A1.dataset.auto = '1';
    }
  }
  ['blur','change'].forEach(evt => {
    A1.addEventListener(evt, () => { formatAxis(A1); autoPairFrom(A1); A1.dataset.auto='0'; });
    A2.addEventListener(evt, () => { formatAxis(A2); autoPairFrom(A2); A2.dataset.auto='0'; });
  });
  window.padToricBackAxes = function(){
    formatAxis(A1);
    formatAxis(A2);
  };
  let syncing = false;
  function syncAxis(who){
    if (syncing) return;
    syncing = true;
    const a1 = num(tbAxis1.value);
    const a2 = num(tbAxis2.value);
    if (who === 'a1' && Number.isFinite(a1)) tbAxis2.value = fmtA3(axis90(a1));
    if (who === 'a2' && Number.isFinite(a2)) tbAxis1.value = fmtA3(axis90(a2));
    syncing = false;
  }
  tbAxis1?.addEventListener('input', () => { syncAxis('a1'); updateToricBack(); });
  tbAxis2?.addEventListener('input', () => { syncAxis('a2'); updateToricBack(); });

  [tbBase, tbCross, tbSphere].forEach(el=>{
    if (!el) return;
    if (el.type !== 'text') { try{ el.type='text'; }catch(e){} }
    el.setAttribute('inputmode','decimal');
    el.addEventListener('blur', () => {
      const x = num(el.value);
      if (Number.isFinite(x)) el.value = fmtSigned0(x);
    });
  });
  function setTBHint(msg){
    if (!tbMsg) return;
    if (msg && msg.trim()){
      tbMsg.textContent = msg;
      tbMsg.style.display = 'block';
    }else{
      tbMsg.textContent = '';
      tbMsg.style.display = 'none';
    }
  }
  const markBad = (el, bad) => { if (el) el.classList.toggle('is-invalid', !!bad); };
  function updateToricBack(){
    setTBHint('');
    [tbBase,tbCross,tbSphere].forEach(el=>markBad(el,false));
    const mode = (tbForm.value || 'front');   
    const S0 = num(tbSphere.value);
    let   B0 = num(tbBase.value);
    let   X0 = num(tbCross.value);
    let   A1 = num(tbAxis1.value);
    let   A2 = num(tbAxis2.value);

    const a1ok = Number.isFinite(A1), a2ok = Number.isFinite(A2);
    if (a1ok && !a2ok) A2 = axis90(A1);
    if (!a1ok && a2ok) A1 = axis90(A2);
    if (![S0,B0,X0,A1,A2].every(Number.isFinite)) {
      outMinus.value = ''; outPlus.value = '';
      return;
    }
    if (Math.abs(B0) > Math.abs(X0)) { [B0,X0] = [X0,B0]; [A1,A2] = [A2,A1]; }
    const sgn = x => (Math.abs(x) < EPS ? 0 : (x>0? +1 : -1));
    const sS  = sgn(S0), sB = sgn(B0), sX = sgn(X0);
    const errs = [];
      if (mode === 'back'){       
        if (sB > 0) { errs.push('後表散光：基弧應為負值'); markBad(tbBase, true); }
        if (sX > 0) { errs.push('後表散光：正交弧應為負值'); markBad(tbCross, true); }
        if (sS < 0) { errs.push('後表散光：球弧應為正值'); markBad(tbSphere,true); }
      } else {     
        if (sB < 0) { errs.push('前表散光：基弧應為正值'); markBad(tbBase, true); }
        if (sX < 0) { errs.push('前表散光：正交弧應為正值'); markBad(tbCross, true); }
        if (sS > 0) { errs.push('前表散光：球弧應為負值'); markBad(tbSphere,true); }
      }
      if (sB * sX < 0) {
        errs.push('散光面兩子午符號相異（鞍形），非新月形');
        markBad(tbBase, true); markBad(tbCross, true);
      }
      if (errs.length){
        outMinus.value = '';
        outPlus.value  = '';
        setTBHint(errs.join('；'));
        return;
      }
    const F1 = S0 + B0;
    const F2 = S0 + X0;
    let Sminus, Cminus, Aminus, Splus, Cplus, Aplus;
    if (F1 >= F2){
      Sminus = F1; Cminus = F2 - F1; Aminus = A1; 
      Splus  = F2; Cplus  = F1 - F2; Aplus  = A2;  
    }else{
      Sminus = F2; Cminus = F1 - F2; Aminus = A2;
      Splus  = F1; Cplus  = F2 - F1; Aplus  = A1;
    }
    outMinus.value = `${fmtSigned0(Sminus)}DS/${fmtSigned0(Cminus)}DC × ${fmtA3(Aminus)}`;
    outPlus .value = `${fmtSigned0(Splus )}DS/${fmtSigned0(Cplus )}DC × ${fmtA3(Aplus )}`;
  }

    ['input','change'].forEach(ev=>{
      [tbForm,tbBase,tbCross,tbSphere].forEach(el=>{
        el && el.addEventListener(ev, updateToricBack, {passive:true});
      });
    });
    [tbBase,tbCross,tbSphere].forEach(el=>{
      if (el && el.value.trim()!==''){
        const v = num(el.value); if (Number.isFinite(v)) el.value = fmtSigned0(v);
      }
    });
    tbClearBtn?.addEventListener('click', () => {
      try{ cutSound.currentTime=0; cutSound.play(); }catch(e){}
      [tbBase, tbAxis1, tbCross, tbAxis2, tbSphere].forEach(el => { if (el) el.value = ''; });
      if (typeof setHint === 'function') setHint('');
      if (outMinus) outMinus.value = '';
      if (outPlus)  outPlus.value  = '';
      if (typeof updateToricBack === 'function') updateToricBack();
    });
    updateToricBack();
})();

  // =====稜鏡換算 =====
(() => {
  const $ = id => document.getElementById(id);
  
  const EPS = 1e-6;
  const parseNum = v => {
    const s = String(v??'').trim().replace(/\u2212/g,'-').replace(/,/g,'.').replace(/[^\d+.\-]/g,'');
    const n = parseFloat(s); return Number.isFinite(n) ? n : NaN;
  };
  const clamp180 = a => { let x = Math.round(parseNum(a)||0)%180; if (x<=0) x+=180; return x; };
  const deg = r => r*180/Math.PI, rad = d => d*Math.PI/180;
  const fmtA3 = a => String(clamp180(a)).padStart(3,'0');
  const fmtSigned0 = v => (Math.abs(v)<0.005) ? '0.00' : ((v>=0?'+':'-')+Math.abs(v).toFixed(2));
  const deg2rad = d => d * Math.PI/180;
  const norm180 = a => { let x = Math.round(+a||0)%180; if (x<=0) x+=180; return x; };
  const fmtPrism = v => `${Math.abs(v).toFixed(2)}△`;
  // 球柱任意子午線屈光力：F(θ) = S + C sin²(θ - Axis)
  const Fmer = (S,C,Axis,thetaDeg) => S + C * Math.pow(Math.sin(rad(thetaDeg - Axis)), 2);
  function baseTextH(eye, signX){
    if (eye==='OD') return signX>0 ? 'BO' : 'BI';
    return signX>0 ? 'BI' : 'BO';
  }
  const baseTextV = signY => (signY>0 ? 'BU' : 'BD');
 // UI refs
const prEye   = document.getElementById('prEye');
const prS     = document.getElementById('prS');
const prC     = document.getElementById('prC');
const prAxis  = document.getElementById('prAxis');

const mvVDir  = document.getElementById('mvVDir');
const mvVmm   = document.getElementById('mvVmm');
const mvHDir  = document.getElementById('mvHDir');
const mvHmm   = document.getElementById('mvHmm');
const btnPrCalc = document.getElementById('btnPrCalc');
const ansF    = document.getElementById('prAnsForward');
const plotF   = document.getElementById('prPlotF');

const rvVpd   = document.getElementById('rvVpd');
const rvVbase = document.getElementById('rvVbase');
const rvHpd   = document.getElementById('rvHpd');
const rvHbase = document.getElementById('rvHbase');
const btnPrRev  = document.getElementById('btnPrRev');
const ansR    = document.getElementById('prAnsReverse');
const plotR   = document.getElementById('prPlotR');


(function populateRxSelects(){
  // S: +20 → -20 ;  |S| <= 12 step 0.25, else step 0.50
  const sOpts = [];
  for (let v=20; v>=-20; ){
    sOpts.push(v);
    if (Math.abs(v) > 12) v -= 0.5; else v -= 0.25;
  }
  prS.innerHTML = sOpts
    .map(v=>`<option value="${v.toFixed(2)}">${v>=0?'+':''}${v.toFixed(2)}</option>`)
    .join('');

  // C: 0 → -6 step 0.25（含 -0.00）
  const cOpts = [];
  for (let v=0; v>=-6; v-=0.25) cOpts.push(v);
  prC.innerHTML = cOpts
    .map(v=>`<option value="${v.toFixed(2)}">${v.toFixed(2)}</option>`)
    .join('');

  prS.value = "4.00";
  prC.value = "-1.50";
  prAxis.value = "180";
})();

// Sph-Cyl 在任意子午線的屈光力：F(θ) = S + C * sin^2(θ)（θ=該子午線與Cyl軸的夾角）
function meridianPower(S,C, axisDeg, meridianDeg){
  const theta = Math.abs(norm180(meridianDeg) - norm180(axisDeg));
  const s2 = Math.sin(deg2rad(theta))**2;
  return S + C*s2;
}

const _fallbackToPatientX = (eye, x) => x;
const toPatientXSafe = (typeof toPatientX === 'function') ? toPatientX : _fallbackToPatientX;
function decLabelFromMM(eye, mmX, mmY){
  const sideH = (mmX === 0) ? '-'
    : (toPatientXSafe(eye, mmX) > 0
        ? ((eye === 'OD') ? '往右(鼻)' : '往右(顳)')
        : ((eye === 'OD') ? '往左(顳)' : '往左(鼻)'));
  const sideV = (mmY === 0) ? '-' : (mmY > 0 ? '往上' : '往下');
  return `${mmX.toFixed(1)}mm ${sideH} , ${mmY.toFixed(1)}mm ${sideV}`;
}

// 眼別
function horizBaseName(eye, sign){ 
  if (sign === 0) return '—';
  const temporal = sign>0;
  if (eye === 'OD') return temporal ? 'BI' : 'BO';
  return temporal ? 'BO' : 'BI'; 
}
function vertBaseName(sign){ 
  if (sign===0) return '—';
  return sign>0 ? 'BU' : 'BD';
}
function baseSignFromName(eye, base){
  if (base==='BU') return +1;
  if (base==='BD') return -1;
  if (base==='BO') return (eye==='OD') ? -1 : +1;
  if (base==='BI') return (eye==='OD') ? +1 : -1;
  return 0;
}
function hvToBase(eye, vx, vy) {
  const Habs = Math.abs(vx);
  const Vabs = Math.abs(vy);
  const Hbase =
    vx === 0 ? '' :
    (eye === 'OD' ? (vx > 0 ? 'BI' : 'BO') 
                  : (vx > 0 ? 'BO' : 'BI'));
  const Vbase =
    vy === 0 ? '' : (vy > 0 ? 'BU' : 'BD'); 
  return { Habs, Hbase, Vabs, Vbase };
}
function signedH_from_base(eye, Habs, base) {
  const s = (base === 'BO')
    ? ((eye === 'OD') ? -1 : +1)
    : ((eye === 'OD') ? +1 : -1);
  return s * Math.abs(Habs);
}
function base_from_signedH(eye, Hsigned) {
  if (!Number.isFinite(Hsigned) || Math.abs(Hsigned) < 1e-9) return { Habs: 0, base: 'BI' };
  const isPos = Hsigned > 0;
  const base = (eye === 'OD')
    ? (isPos ? 'BI' : 'BO')
    : (isPos ? 'BO' : 'BI');
  return { Habs: Math.abs(Hsigned), base };
}
function signedV_from_base(Vabs, base) {
  return (base === 'BU' ? +1 : -1) * Math.abs(Vabs);
}
function base_from_signedV(Vsigned) {
  if (!Number.isFinite(Vsigned) || Math.abs(Vsigned) < 1e-9) return { Vabs: 0, base: 'BU' };
  return { Vabs: Math.abs(Vsigned), base: (Vsigned > 0 ? 'BU' : 'BD') };
}

// 坐標與向量
function drawPrPlot(canvas, vx, vy, mmX=0, mmY=0, eye='OD'){
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0,0,W,H);
  // 比例
  const pxPerDelta = 5;
  const pxPerMM    = 4;
  const margin     = 10;

  ctx.save();
  ctx.translate(W/2, H/2);
  //背景格線
  ctx.strokeStyle = 'rgba(255,255,255,.07)';
  ctx.lineWidth = 1;
  const step = 5 * pxPerMM;              // 每 5 mm 一格
  for (let x = step; x <= W/2 - margin; x += step) {
    ctx.beginPath(); ctx.moveTo( x, -H/2+margin); ctx.lineTo( x, H/2-margin); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(-x, -H/2+margin); ctx.lineTo(-x, H/2-margin); ctx.stroke();
  }
  for (let y = step; y <= H/2 - margin; y += step) {
    ctx.beginPath(); ctx.moveTo(-W/2+margin,  y); ctx.lineTo(W/2-margin,  y); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(-W/2+margin, -y); ctx.lineTo(W/2-margin, -y); ctx.stroke();
  }
  // ====== 主軸 ======
  ctx.strokeStyle = 'rgba(255,255,255,.25)';
  ctx.lineWidth = 1.2;
  ctx.beginPath(); ctx.moveTo(-W/2+margin, 0); ctx.lineTo(W/2-margin, 0); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0, -H/2+margin); ctx.lineTo(0, H/2-margin); ctx.stroke();
  ctx.fillStyle = 'rgba(155,205,245,.24)';
  ctx.font = '12px system-ui,Segoe UI,Arial';
  const leftLabel = (eye==='OD') ? 'Temporal' : 'Nasal';
  const rightLabel  = (eye==='OD') ? 'Nasal' : 'Temporal';
  ctx.fillText(rightLabel,  W/2 - margin - 40, 14);
  ctx.fillText(leftLabel,  -W/2 + margin + 6,  14);
  ctx.fillText('Up', 6, -H/2 + margin + 14);
  ctx.fillText('Down', 6,  H/2 - margin - 6);
  ctx.save();
  ctx.globalAlpha = 0.07;
  // 眼白橢圓
  ctx.fillStyle = '#ffffff';
  ctx.beginPath();
  const rx = Math.min(W*0.34, 55), ry = Math.min(H*0.25, 24);
  ctx.ellipse(0, 0, rx, ry, 0, 0, Math.PI*2);
  ctx.fill();
  // 虹膜
  ctx.globalAlpha = 0.22;
  ctx.strokeStyle = '#00d3b1';
  ctx.lineWidth = 12.5;
  const irisR = 17;
  ctx.beginPath(); ctx.arc(0, 0, irisR, 0, Math.PI*2); ctx.stroke();
  ctx.restore();
  // 瞳位
  const pxX =  mmX * pxPerMM;
  const pxY = -mmY * pxPerMM;
  // 連線 OC→Pupil
  ctx.strokeStyle = 'rgba(141,230,210,.9)';
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(pxX, pxY); ctx.stroke();
  // 鏡片（圓 + 光心）
  ctx.fillStyle = 'rgba(141,230,210,.07)';
  ctx.beginPath(); ctx.arc(pxX, pxY, 126, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = 'rgba(255,255,255,.55)';
  ctx.beginPath(); ctx.arc(pxX, pxY, 3, 0, Math.PI*2); ctx.fill();
  // 註解文字Dec
  ctx.fillStyle = 'rgba(255,255,255,.75)';
  ctx.font = '12px system-ui,Segoe UI,Arial';
  const label = decLabelFromMM(eye, mmX, mmY);
  ctx.fillText(`Dec: ${label}`, -W/2 + margin + 6, -H/2 + margin + 14);
  // 註解文字稜鏡H/V
  ctx.fillStyle = '#45f0c6';
  const { Habs, Hbase, Vabs, Vbase } = hvToBase(eye, vx, vy);
  ctx.fillText(
    `Prism: ${Vabs.toFixed(2)}△${Vbase} , ${Habs.toFixed(2)}△${Hbase}`,
    -W/2 + margin + 6,
    -H/2 + margin + 28
  );
  ctx.restore();
}

// ---- 正向計算（位移 → 稜鏡）----
function calcForward(){
  cutSound.currentTime = 0; cutSound.play();
  const eye = prEye.value;
  const S   = parseFloat(prS.value);
  const C   = parseFloat(prC.value);
  const A   = norm180(prAxis.value);
  const Fv = meridianPower(S, C, A, 90);
  const Fh = meridianPower(S, C, A, 180);

  const dv_mm = Math.abs(parseFloat(mvVmm.value)||0);
  const dh_mm = Math.abs(parseFloat(mvHmm.value)||0);
  const dv_cm = dv_mm / 10;
  const dh_cm = dh_mm / 10;
  const sv = (mvVDir.value==='up') ? +1 : -1;
  const sh = (mvHDir.value==='temporal')
               ? ((eye==='OD') ? -1 : +1)  
               : ((eye==='OD') ? +1 : -1);

  // Prentice
  const Pv = Fv * dv_cm * sv;   // 垂直分量（△）
  const Ph = Fh * dh_cm * sh;   // 水平分量（△）
  const vBase = vertBaseName(Math.sign(Pv));
  const hBase = horizBaseName(eye, Math.sign(Ph));

  // 顯示
  const out = [];
  if (Math.abs(Pv) > 0.0005) out.push(`${Math.abs(Pv).toFixed(2)}△${vBase}`);
  if (Math.abs(Ph) > 0.0005) out.push(`${Math.abs(Ph).toFixed(2)}△${hBase}`);
  const vecMag = Math.hypot(Pv,Ph);
  let vecAng = Math.atan2(Pv, Ph) * 180 / Math.PI;
    if (vecAng < 0) vecAng += 360; 
  ansF.textContent = out.length
    ? `${eye}：產生${out.join(' ＋ ')}（合成 ≈ ${vecMag.toFixed(2)}△ @ ${vecAng.toFixed(0)}°）`
    : `${eye}：0△`;
  const mmX = sh * dh_mm; 
  const mmY = sv * dv_mm; 
  drawPrPlot(document.getElementById('prPlotF'), Ph, Pv, mmX, mmY, eye);
}
// ---- 反向計算（稜鏡 → 位移）----
function calcReverse(){
  cutSound.currentTime = 0; cutSound.play();
  const eye = prEye.value;
  const S   = parseFloat(prS.value);
  const C   = parseFloat(prC.value);
  const A   = norm180(prAxis.value);
  const Fv = meridianPower(S, C, A, 90);
  const Fh = meridianPower(S, C, A, 180);
  const Vpd = parseFloat(rvVpd.value)||0; 
  const Hpd = parseFloat(rvHpd.value)||0; 
  const Vsgn = baseSignFromName(eye, rvVbase.value);  
  const Hsgn = baseSignFromName(eye, rvHbase.value);  
  const dv_mm = (Fv!==0) ? Math.abs((Vpd*Vsgn) / Fv) * 10 : 0;
  const dh_mm = (Fh!==0) ? Math.abs((Hpd*Hsgn) / Fh) * 10 : 0;
  const mmY = (Vsgn>0 ? +1 : -1) * dv_mm;
  const mmX = (Hsgn>0 ? +1 : -1) * dh_mm;
  const Pv = Math.abs(parseFloat(rvVpd.value)||0) * baseSignFromName(eye, rvVbase.value);
  const Ph = Math.abs(parseFloat(rvHpd.value)||0) * baseSignFromName(eye, rvHbase.value);
  const vDir = (Math.sign(Pv)>0) ? '往上' : (Math.sign(Pv)<0 ? '往下' : '—');
  const hDir = (function(){
    if (Math.sign(Ph)===0) return '—';
    const temporal = (baseSignFromName(eye, (Math.sign(Ph)>0? (eye==='OD'?'BO':'BI') : (eye==='OD'?'BI':'BO'))) > 0);
    return temporal ? '往顳側(Temporal)' : '往鼻側(Nasal)';
  })();
  ansR.textContent = `${eye}：光學中心垂直${vDir}約 ${dv_mm.toFixed(1)} mm；水平${hDir}約 ${dh_mm.toFixed(1)} mm`;
  drawPrPlot(document.getElementById('prPlotR'), Hpd*Hsgn, Vpd*Vsgn, mmX, mmY, eye);
}

prAxis.addEventListener('blur', ()=> prAxis.value = fmtA3(prAxis.value));

btnPrCalc.addEventListener('click', calcForward); 
btnPrRev .addEventListener('click', calcReverse);

drawPrPlot(plotF, 0, 0);
drawPrPlot(plotR, 0, 0);

  // === ② H/V 合成與分解 ===
  const pvH=$('pvH'), pvHbase=$('pvHbase'), pvV=$('pvV'), pvVbase=$('pvVbase');
  const pvEyeC = $('pvEyeC');
  const pvCombineBtn=$('pvCombineBtn'), pvCombineOut=$('pvCombineOut');
  const pvR=$('pvR'), pvTheta=$('pvTheta'), pvThetaMode = $('pvThetaMode'), pvDecompBtn=$('pvDecompBtn'), pvDecompOut=$('pvDecompOut');
  const pvEyeD = $('pvEyeD');
  const pvVec=$('pvVec'), pvVec2=$('pvVec2');;


  function setPvVec(R, theta) {
    const x = R * Math.cos(rad(theta));
    const y = R * Math.sin(rad(theta));
    const pvVec = $('pvVec');
    pvVec.setAttribute('x1', 0);
    pvVec.setAttribute('y1', 0);
    pvVec.setAttribute('x2', x.toFixed(2));
    pvVec.setAttribute('y2', (-y).toFixed(2)); 
  }
    function setPvVec2(R, theta) {
    const x = R * Math.cos(rad(theta));
    const y = R * Math.sin(rad(theta));
    const pvVec2 = $('pvVec2');
    pvVec2.setAttribute('x1', 0);
    pvVec2.setAttribute('y1', 0);
    pvVec2.setAttribute('x2', x.toFixed(2));
    pvVec2.setAttribute('y2', (-y).toFixed(2)); 
  }

  // 水平/垂直 → 角度
  function combinePrism(){
    cutSound.currentTime = 0; cutSound.play();
    const eye = pvEyeC.value; 
    const Hraw = parseNum(pvH.value);
    const Vraw = parseNum(pvV.value);
    const Habs = Number.isFinite(Hraw) ? Math.abs(Hraw) : 0;
    const Vabs = Number.isFinite(Vraw) ? Math.abs(Vraw) : 0;
    const x = signedH_from_base(eye, Habs, pvHbase.value);
    const y = signedV_from_base(Vabs, pvVbase.value);
    const R = Math.hypot(x, y);
    let theta = deg(Math.atan2(y, x)); if (theta < 0) theta += 360;
    pvCombineOut.textContent = `${R.toFixed(2)}△ @ ${theta.toFixed(1)}°`;
    setPvVec(R*7, theta); 
  }

  // 角度 → 水平/垂直
  function decompPrism(){
    cutSound.currentTime = 0; cutSound.play();
    const eye = pvEyeD.value;
    const R = Number(parseNum(pvR.value)) || 0;
    let theta = Number(parseNum(pvTheta.value)) || 0;
      if (pvThetaMode.value === '360') {
      while (theta < 0) theta += 360;
      while (theta >= 360) theta -= 360;
    } else {
      if (theta < 0) theta = 0;
      if (theta > 90) theta = 90;
   }
    const x = R * Math.cos(rad(theta));
    const y = R * Math.sin(rad(theta));
    const { Habs, base: Hbase } = base_from_signedH(eye, x);
    const { Vabs, base: Vbase } = base_from_signedV(y);
    pvDecompOut.textContent =
      `${Vabs.toFixed(2)}△${Vbase}  ＋  ${Habs.toFixed(2)}△${Hbase}`;
    const hStr = (Math.abs(x) < 1e-6) ? `${fmtPrism(0)}`
                                      : `${fmtPrism(x)} ${Hbase}`;
    const vStr = (Math.abs(y) < 1e-6) ? `${fmtPrism(0)}`
                                      : `${fmtPrism(y)} ${Vbase}`;
    pvDecompOut.textContent = `水平：${hStr}；垂直：${vStr}`;
    setPvVec2(R * 7, theta);
  }

  pvCombineBtn?.addEventListener('click', combinePrism);
  pvDecompBtn?.addEventListener('click', decompPrism);
})();
  /* === 小工具列邏輯 === */
  const tabBtns = Array.from(document.querySelectorAll('#toolSelector button'));
  const containers = tabBtns.map(b =>
    document.getElementById(b.id.replace('Btn','Container'))
  );
  tabBtns.forEach((btn,i) => {
    btn.addEventListener('click', () => {
      playclickSound()
      tabBtns.forEach((b,j) => b.classList.toggle('active', i===j));
      containers.forEach((c,j) => c.classList.toggle('active', i===j));
    });
  });

  const scroller   = document.getElementById('toolSelector');
  const scrollBtns = Array.from(scroller.querySelectorAll('button'));
  let itemWidth = scrollBtns[0]?.offsetWidth || 0;
  window.addEventListener('resize', () => {
    itemWidth = scrollBtns[0].offsetWidth;
  });

  let currentIndex = 0;
  const total = scrollBtns.length;

  function updateFocus() {
    scrollBtns.forEach((btn, i) =>
      btn.classList.toggle('focused', i === currentIndex)
    );
  }

  function scrollToIndex(idx) {
    currentIndex = Math.max(0, Math.min(total - 1, idx));
    scrollBtns[currentIndex].scrollIntoView({
      behavior: 'smooth',
      inline: 'center',
      block: 'nearest'
    });
    updateFocus();
  }

  document.getElementById('prevBtn').addEventListener('click', () => {
    scrollToIndex(currentIndex - 1);
    click1Sound.currentTime = 0;
    click1Sound.play();
  });
  document.getElementById('nextBtn').addEventListener('click', () => {
    scrollToIndex(currentIndex + 1);
    click1Sound.currentTime = 0;
    click1Sound.play();
  });
  
  updateFocus();
  window.MathJax = { tex: {inlineMath: [['\\(','\\)'], ['$', '$']]} };

    randomSelectHexagon();
    animateBackground();
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.min.js" defer></script>
</html>


