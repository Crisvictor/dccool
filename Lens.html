<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link rel="icon" href="img/optometry.png" type="image/x-icon">
<link rel="shortcut icon" href="img/optometry.png" type="image/x-icon">
<script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<title>é¡ç‰‡åšåº¦æ¨¡æ“¬å™¨</title>
<style>
  :root{
    --bg:#0b1220;          /* èƒŒæ™¯ */
    --ink:#e5e7eb;         /* ä¸»è¦æ–‡å­— */
    --muted:#94a3b8;       /* æ¬¡è¦æ–‡å­— */
    --card:#0f172a;        /* å¡ç‰‡åº•è‰² */
    --border:#1e293b;      /* é‚Šæ¡†è‰² */
    --pri:#38bdf8;         /* é‡é»/ç„¦é»è‰² */
    --ok:rgba(34, 197, 94, .4);
    --ng:rgba(248, 113, 113, .4);
  }
  html,body{height:100%}
  body{
    margin:0;
    font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans TC",Arial;
    background:radial-gradient(1200px 800px at 20% -10%,#0e1728 0%,#0b1220 55%),
               radial-gradient(800px 800px at 90% 10%,#0a1a2f 0%,transparent 60%),
               var(--bg);
    color:var(--ink);
  }
  .wrap{max-width:1200px;margin:24px auto;padding:0 16px}
  h1{font-size:22px;margin:0 0 12px;color:#f1f5f9}
  .grid{display:grid;gap:10px}
  .g-3{grid-template-columns:repeat(3,minmax(0,1fr))}
  .card{
    background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,.02));
    border:1px solid var(--border);
    border-radius:16px;
    box-shadow:0 10px 35px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.03);
    backdrop-filter:saturate(110%) blur(2px);
  }
  .card>.hd{
    padding:12px 16px;
    border-bottom:1px solid var(--border);
    font-weight:580;
    color:#cbd5e1;
  }
  .card>.bd{padding:8px 16px}
  .row{display:grid;grid-template-columns:1fr 160px;align-items:center;gap:8px;margin:8px 0}
  .row label{color:var(--muted);font-size:12px}
  input,select{
    width:100%;max-width:100%;box-sizing:border-box;
    padding:8px 10px;
    border:1px solid #334155;
    background:#0b1628;
    color:var(--ink);
    border-radius:10px;font-size:14px;outline:none;
    transition:border-color .15s, box-shadow .15s, background .15s;
  }
  input::placeholder{color:#71839a}
  select option{background:#0b1628;color:var(--ink)}
    input:focus,select:focus{
    border-color:#60a5fa;
    box-shadow:0 0 0 2px rgba(56,189,248,.25);
    background:#0c1a31;
  }
  .kpis{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:6px}
  .kpi{
    border:1px solid var(--border);
    border-radius:8px;
    background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.02));
    padding:5px
  }
  .kpi .t{font-size:11px;color:var(--muted)}
  .kpi .v{font-weight:700;margin-top:2px;color:#e2e8f0}
  .canvas{
    aspect-ratio:1/1;border-radius:16px;
    border:1px solid var(--border);
    background:radial-gradient(500px 400px at 60% 40%,rgba(148,163,184,.08),transparent 60%),
               #0b1324;
    display:flex;align-items:center;justify-content:center
  }
  .kpi-double{
    display:flex;
    flex-direction:column;
    gap:11px;
  }
  .kpi-subcard{
    padding-top:8px;
    border-top:1px solid var(--border);
  }
  .kpi-subcard:first-child{
    border-top:none;
  }
  .kpi-subtitle{
    font-size:12px;
    color:var(--muted);
    font-weight:600;
    margin-bottom:6px;
  }
  .note{font-size:12px;color:var(--muted)}
  .danger{color:var(--ng);font-weight:700}
  @media (max-width:980px){.g-3{grid-template-columns:1fr}}
  hr{border:0;border-top:1px dashed var(--border);margin:10px 0}
</style>
</head>
<body>
  <div class="wrap">
    <h1>é¡ç‰‡åšåº¦æ¨¡æ“¬å™¨</h1>
    <p class="note">ç”¨é€”ï¼šåœ¨è¨‚è£½å‰ï¼Œè¼¸å…¥åº¦æ•¸/æŠ˜å°„ç‡èˆ‡æ¡†åƒæ•¸ï¼Œä¼°ç®—è£å‹å¾Œé‚Šç·£åšåº¦æ˜¯å¦è¶³å¤ åšå‡ºæºå°–èˆ‡è»Šæºï¼Œä¸¦æª¢æŸ¥é¡å¯ç‰‡å¾‘æ˜¯å¦è¶³å¤ ã€‚<br>è²æ˜ï¼šæœ¬æ•™å­¸å·¥å…·ç‚ºåšåº¦å¹¾ä½•è¿‘ä¼¼å€¼ï¼Œæœªå«å‰å¾Œè¡¨é¢å½åº¦ï¼ˆBase Curveï¼‰è¨­å®šèˆ‡æŠ˜å°„é¢è¨­è¨ˆï¼ˆå¦‚éçƒé¢èˆ‡å¤šç„¦ï¼‰ä»æœƒç”¢ç”Ÿèª¤å·®ï¼Œå¯¦å‹™ä»éœ€ä»¥åŠ å·¥ç¶“é©—ç‚ºæº–ã€‚</p>

    <div class="grid g-3">
      <div class="card">
        <div class="hd">åƒæ•¸è¼¸å…¥ [è¨‚è£½é¡ç‰‡]</div>
        <div class="bd">
          <div class="row"><label>é¡ç‰‡é¡å‹</label><select id="lensType"><option value="minus">è¿‘è¦–</option><option value="plus">é è¦–</option></select></div>
          <div class="row"><label>çƒé¡ D (Â±)</label><input id="D" type="number" step="0.25" value="-6" min="-20" max="20"></div>
          <div class="note" id="d_display">ç›®å‰ï¼š-6.00 D</div>
          <div class="row"><label>æŠ˜å°„ç‡ n</label>
            <select id="n">
              <option value="1.56">1.56</option>
              <option value="1.61">1.61</option>
              <option value="1.67" selected>1.67</option>
              <option value="1.74">1.74</option>
            </select>
          </div>
          <div class="row" data-for="minus"><label>æŒ‡å®šä¸­å¿ƒåš (mm)</label><input id="centerT" type="number" step="0.1" value="1.2" min="1.0" max="3.0"></div>
          <div class="row" data-for="plus" style="display:none"><label>è¨­å®šé‚Šç·£åš (mm)</label><input id="edgeT" type="number" step="0.1" value="2.0" min="0.2" max="3.0"></div>
          <div class="row"><label>é¡å¯ç‰‡å¾‘ (mm)</label><input id="blankDia" type="number" step="1" value="65" min="50" max="80"></div>
        </div>
      </div>

      <div class="card">
        <div class="hd">å¹³é¢è¦–åœ–ï¼ˆé¡å¯ / è£å‹ ï¼‰</div>
        <div class="bd">
          <div class="canvas"><svg id="topView" width="340" height="340"></svg></div>
          <p class="note">åœ–ç¤ºï¼šå¤–åœˆï¼é¡å¯ç‰‡å¾‘ï¼›å…§åœˆï¼è£å‹ç›´å¾‘ï¼ˆEDï¼‰ï¼›<br>ç¶ /ç´…ç’°ï¼é‚Šç·£åšé”æ¨™/ä¸è¶³ï¼›é¡å¯ä¸è¶³â†’å¤–åœˆç´…è‰²ã€‚</p>
        </div>
      </div>

      <div class="card">
        <div class="hd">è£å‹é‚Šç·£åšåº¦ï¼ˆå«åå¿ƒå½±éŸ¿ï¼‰</div>
        <div class="bd">
          <div class="canvas"><svg id="sectionView" width="340" height="340"></svg></div>
          <p class="note">æ©«åˆ‡é¢æ²¿æ°´å¹³æ–¹å‘ï¼šå·¦/å³é‚Šå› åå¿ƒï¼ˆPD â‰  A+DBLï¼‰<br>è€Œç”¢ç”Ÿä¸åŒé‚Šç·£åšåº¦ï¼Œè©•ä¼°æœ€è–„å´æ˜¯å¦å¯é–‹è»Šæºã€‚</p>
        </div>
      </div>
    </div>

    <div class="grid g-3" style="margin-top:16px">
      <div class="card">
        <div class="hd">åƒæ•¸è¼¸å…¥ [æ¡†åƒæ•¸] </div>
        <div class="bd">
          <div class="row"><label>æœ‰æ•ˆç›´å¾‘ ED (mm)</label><input id="ED" type="number" step="0.5" value="53" min="20" max="80"></div>
          <div class="row"><label>æ¡†å¯¬ A (mm)</label><input id="A" type="number" step="0.5" value="52" min="20" max="80"></div>
          <div class="row"><label>æ¡†é«˜ B (mm)</label><input id="B" type="number" step="0.5" value="35" min="20" max="80"></div>
          <div class="row"><label>ä¸­æ¨‘è· DBL (mm)</label><input id="DBL" type="number" step="0.5" value="18" min="10" max="40"></div>
          <div class="row"><label>ç³è· PD (mm)</label><input id="PD" type="number" step="0.5" value="62" min="40" max="80"></div>
          <div class="row"><label>é ç•™åŠ å·¥ (mm)</label><input id="allowance" type="number" step="0.5" value="2" min="0" max="4"></div>

          <div class="row"><label>æ¡†æºå¯¬/è»Šæºå¯¬ (mm)</label><input id="grooveDepth" type="number" step="0.1" value="0.8" min="0.3" max="3"></div>
          <div class="row"><label>æœ€å°å‰©é¤˜åšåº¦éœ€æ±‚ (mm)</label><input id="minTip" type="number" step="0.1" value="1.5" min="0.3" max="2"></div>
          <div class="row"><label>æ¡†å‹</label><select id="rimType"><option value="full">å…¨æ¡†</option><option value="groove">è»Šæºæ¡†</option></select></div>
        </div>
      </div>

      <div class="card">
        <div class="hd">3D åšåº¦è¦–è¦ºï¼ˆæ¦‚å¿µç¤ºæ„ï¼‰</div>
        <div class="bd">
          <div id="threeWrap" style="width:100%;height:340px;border-radius:12px;border:1px solid var(--border);background:#0a1322;overflow:hidden"></div>
          <p class="note">æ­¤ 3D ç‚ºæ—‹è½‰å°ç¨±æ¦‚å¿µç¤ºæ„ï¼šä¾åšåº¦å‡½å¼ç”¢ç”Ÿè»¸å°ç¨±é¡ç‰‡ï¼ˆåœ“å½¢ï¼‰ã€‚ä¸å½±éŸ¿è¨ˆç®—ï¼Œåƒ…ä¾›è¦–è¦ºåŒ–ã€‚</p>
        </div>
      </div>
     
      <div class="card">
        <div class="hd">è£å‹ / é¡å¯ & åšåº¦æª¢æ ¸</div>
        <div class="bd kpi-double">

          <!-- ä¸ŠåŠï¼šè£å‹ & é¡å¯è©•ä¼° -->
          <div class="kpi-subcard">
            <div class="kpi-subtitle">è£å‹ & é¡å¯è©•ä¼°</div>
            <div class="kpis">
              <div class="kpi">
                <div class="t">æ¡†å¿ƒè· (A+DBL)</div>
                <div id="k_framePD" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">å–®çœ¼åå¿ƒ</div>
                <div id="k_dec" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">è£å‹ç›´å¾‘ â‰ˆ</div>
                <div id="k_cutDia" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">é¡å¯éœ€æ±‚åŠå¾‘</div>
                <div id="k_reqR" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">é¡å¯æœ€å°å»ºè­°ç‰‡å¾‘</div>
                <div id="k_minBlank" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">é¡å¯æ˜¯å¦è¶³å¤ </div>
                <div id="k_blankOK" class="v"></div>
              </div>
            </div>
          </div>

          <!-- ä¸‹åŠï¼šåšåº¦ & æºå°–/è»Šæºæª¢æ ¸ï¼ˆè¿‘ä¼¼ï¼‰ -->
          <div class="kpi-subcard">
            <div class="kpi-subtitle">åšåº¦ & æºå°–/è»Šæºæª¢æ ¸ï¼ˆè¿‘ä¼¼ï¼‰</div>
            <div class="kpis">
              <div class="kpi">
                <div class="t">Î”ï¼ˆå¹¾ä½•è¿‘ä¼¼ï¼‰</div>
                <div id="k_delta" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">ä¸­å¿ƒåšä¼°</div>
                <div id="k_center" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">é‚Šç·£åšï¼ˆè–„å´ï¼‰</div>
                <div id="k_edge" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">ä¸å«æºå°–/è»Šæºé‚Šåšï¼ˆè–„å´ï¼‰</div>
                <div id="k_tip" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">è»Šæº/æºå°–å®‰å…¨ç·š</div>
                <div id="k_halfSafety" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">çµæœ</div>
                <div id="k_result" class="v"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>


<script>
(function(){
  const $ = (id)=>document.getElementById(id);
  const ids = ["lensType","D","n","centerT","edgeT","blankDia","ED","A","B","DBL","PD","allowance","grooveDepth","minTip","rimType"];
  ids.forEach(id=>$(id).addEventListener('input', update));
  $("lensType").addEventListener('change', ()=>{
    const t = $("lensType").value;
    document.querySelector('[data-for="minus"]').style.display = (t==='minus')?'' : 'none';
    document.querySelector('[data-for="plus"]').style.display  = (t==='plus') ?'' : 'none';
    update();
  });

  function clamp(v,min,max){ v=parseFloat(v); if(isNaN(v)) return min; return Math.min(Math.max(v,min),max); }

  function calc(){
    const lensType = $("lensType").value; // minus/plus
    const D  = parseFloat($("D").value);
    const n  = parseFloat($("n").value);
    const centerT = clamp($("centerT").value,1.0,3.0);
    const edgeT   = clamp($("edgeT").value,0.2,3.0);
    const blankDia= clamp($("blankDia").value,50,80);


    const ED = clamp($("ED").value,20,80);
    const A  = clamp($("A").value,20,80);
    const B  = clamp($("B").value,20,80);
    const DBL= clamp($("DBL").value,10,40);
    const PD = clamp($("PD").value,40,80);
    const allowance = clamp($("allowance").value,0,4);

    const grooveDepth = clamp($("grooveDepth").value,0.3,0.9);
    const minTip = clamp($("minTip").value,0.8,2);
    const rimType = $("rimType").value; // full/groove

    const framePD = A + DBL;
    const dec = Math.abs(framePD - PD)/2; // å–®çœ¼åå¿ƒ

    // æ°´å¹³æ–¹å‘ï¼šä»¥æ¡†å¯¬ A/2 ç‚ºåŸºæº–
    const halfA = A / 2;
    const rL = Math.max(0, halfA - dec); // å·¦é‚Šå¯¦éš›åˆ°å…‰å­¸ä¸­å¿ƒè·é›¢
    const rR = halfA + dec;              // å³é‚Šå¯¦éš›åˆ°å…‰å­¸ä¸­å¿ƒè·é›¢

    // æ–œé‚Š EDï¼šç”¨ä¾†ç®—æœ€å¤§åŠå¾‘èˆ‡é¡å¯éœ€æ±‚
    const cutR = ED/2;                  // è¦–è¦ºä¸Šçš„è£å‹ã€Œç­‰æ•ˆåœ“åŠå¾‘ã€
    const rMax = cutR + dec;           // æœ€é é‚£ä¸€é»ï¼ˆå°è§’ç·š + åå¿ƒï¼‰

    // é¡å¯éœ€æ±‚åŠå¾‘ã€ç‰‡å¾‘ï¼ˆæ²¿ç”¨åŸæœ¬æ¦‚å¿µï¼‰
    const hReq = rMax + allowance;
    const minBlank = 2 * hReq;
    const blankOK  = (blankDia/2) >= hReq;

    const absD = Math.abs(D);

    // ä»¥â€œè–„å´/æœ€å¤§åŠå¾‘â€ä½œç‚ºåƒè€ƒåŠå¾‘ä¾†è¨ˆç®— Î”
    const rRef = Math.max(rL, rR); // è¿‘è¦–ï¼šæœ€å¤§åŠå¾‘ï¼›é è¦–ï¼šè–„å´äº¦åœ¨è¼ƒå¤§åŠå¾‘
    const delta = (rRef*rRef*absD)/(2000*(n-1));

    function tMinus(r){ return centerT + (r*r*absD)/(2000*(n-1)); }
    function tPlus (r){ const rThin = Math.max(rL, rR); const center = edgeT + (rThin*rThin*absD)/(2000*(n-1)); return Math.max(0, center - (r*r*absD)/(2000*(n-1))); }

    let tL, tR, estCenter, estEdgeMin;
    if(lensType==='minus'){
      estCenter = centerT;
      tL = tMinus(rL); tR = tMinus(rR);
      estEdgeMin = Math.min(tL, tR);
    }else{
      // é è¦–ï¼šç”¨æœ€è–„å´åŠå¾‘æ¨å›ä¸­å¿ƒåšï¼Œç¢ºä¿è–„å´=è¼¸å…¥é‚Šç·£åš
      estCenter = edgeT + delta; // delta ä»¥ rRef è¨ˆ
      tL = tPlus(rL); tR = tPlus(rR);
      estEdgeMin = Math.min(tL, tR); // æ‡‰èˆ‡ edgeT æ¥µæ¥è¿‘
    }

    const tipRemain = estEdgeMin - grooveDepth; // è–„å´å°–ç«¯

    // è»Šæºæ¡†å®‰å…¨ï¼ˆå»ºè­° â‰¥1.0 æˆ–ä½¿ç”¨è€…è¨­å®šï¼‰
    const need = Math.max(1.0, minTip);
    const halfOK = tipRemain >= need;

    return {lensType,D,n,centerT,edgeT,blankDia,ED,A,B,DBL,PD,allowance,grooveDepth,minTip,rimType,
      framePD,dec,cutR,hReq,blankOK,delta,estCenter,estEdgeMin,tipRemain,halfOK,minBlank,rL,rR,rMax,need};
  }

  function drawTop(res){
    const svg = $("topView");
    const W=svg.viewBox.baseVal.width||340,H=svg.viewBox.baseVal.height||340; svg.setAttribute('viewBox',`0 0 ${W} ${H}`);
    svg.innerHTML='';
    const cx=W/2, cy=H/2;
    const blankR = Math.min(W,H)*0.42;
    const rBlankReal = res.blankDia / 2; 
    const scale = blankR / rBlankReal;    
    // æ¡†æ©¢åœ“ï¼ˆboxing systemï¼šAÃ—Bï¼‰
    const rxFrame = (res.A / 2) * scale;
    const ryFrame = (res.B / 2) * scale;
    const dx = (res.dec) * scale;
    // æ¡†å½¢ç‹€ï¼šæ©¢åœ“
    ellipse(svg, cx + dx, cy, rxFrame, ryFrame, 'none', '#4b5563', 2);
    // ED ç­‰æ•ˆåœ“ï¼ˆè™›ç·šï¼‰
    const rED = (res.ED / 2) * scale;
    circle(svg, cx + dx, cy, rED, 'none', '#6b7280', 1, '4 4');

    const rCut = (res.cutR / rBlankReal) * blankR; // è£å‹åŠå¾‘

    // é¡å¯å¤–åœˆï¼ˆä¸è¶³æ™‚ç´…è‰²ï¼‰
    circle(svg, cx, cy, blankR, 'none', res.blankOK ? '#cbd5e1' : '#ef4444', 2);

    // è£å‹åœˆï¼ˆä»¥æ¡†ä¸­å¿ƒç›¸å°é¡å¯ä¸­å¿ƒä¹‹åå¿ƒé¡¯ç¤ºï¼‰
    circle(svg,cx+dx,cy,rCut,'none','#374151',2);

    // æºæ§½é”æ¨™ï¼ˆè–„å´ï¼‰
    const edgeColor = res.tipRemain >= res.need
      ? 'rgba(34,197,94,0.4)'    
      : 'rgba(239,68,68,0.4)';  
    circle(svg, cx + dx, cy, rCut + 8, 'none', edgeColor, 8);

    // æ¨™è¨»
    text(svg,cx,cy-blankR-8,`é¡å¯ç‰‡å¾‘ ${res.blankDia.toFixed(0)} mm`,'#99B3C2');
    text(svg,cx+dx,cy-rCut+32,`è£å‹ç›´å¾‘ â‰ˆ ${ (res.cutR*2).toFixed(1) } mm`,'#839681','middle');
  }

  function drawSection(res){
    const svg=$("sectionView");
    const W=svg.viewBox.baseVal.width||340,H=svg.viewBox.baseVal.height||340; svg.setAttribute('viewBox',`0 0 ${W} ${H}`);
    svg.innerHTML='';
    const cx=W/2, baseY=H*0.75;

    // æ©«å‘æ¯”ä¾‹ï¼šä»¥æœ€å¤§åŠå¾‘ rR å°æ‡‰åˆ°è¦–åœ–å¯¬åº¦ 120px
    const scaleX = 120 / Math.max(res.rR, res.cutR);
    // åšåº¦æ¯”ä¾‹ï¼šåƒ…è¦–è¦ºåŒ–ç”¨ï¼ˆ1mmâ†’8pxï¼‰
    const scaleT = 8;

    // ä¸­å¤®åŸºæº–ç·š
    line(svg,cx-140,baseY,cx+140,baseY,'#e5e7eb',1);

    // å·¦å³é‚Šç·£ä½ç½®ï¼ˆç›¸å°é¡ç‰‡ä¸­å¿ƒï¼‰
    const xL = cx - res.rL*scaleX+20; const xR = cx + res.rR*scaleX-40;

    const tL = thicknessAt(res,'L');
    const tR = thicknessAt(res,'R');

    // ç¹ªè£½æˆªé¢ï¼ˆçŸ©å½¢ç¤ºæ„å±€éƒ¨åšåº¦ï¼‰
    rect(svg, xL-6, baseY - tL*scaleT, 12, tL*scaleT, '#93c5fd');
    rect(svg, xR-6, baseY - tR*scaleT, 12, tR*scaleT, '#93c5fd');

    // è»Šæºå¯¬
    rect(svg, xL-6, baseY - Math.max(0,tL-res.grooveDepth)*scaleT, 12, res.grooveDepth*scaleT, 'rgba(239,68,68,.6)');
    rect(svg, xR-6, baseY - Math.max(0,tR-res.grooveDepth)*scaleT, 12, res.grooveDepth*scaleT, 'rgba(239,68,68,.6)');

    // æ¨™è¨»
    text(svg, xL, baseY+14, `å·¦ r=${res.rL.toFixed(1)}mm\né‚Šåš=${tL.toFixed(2)}mm`, '#A9BED6', 'middle');
    text(svg, xR, baseY+14, `å³ r=${res.rR.toFixed(1)}mm\né‚Šåš=${tR.toFixed(2)}mm`, '#A9BED6', 'middle');
    text(svg, cx, baseY+52, `æºå°–å¯¬/è»Šæºå¯¬ ${res.grooveDepth.toFixed(1)}mmï¼›è–„å´å‰©é¤˜ ${(res.estEdgeMin-res.grooveDepth).toFixed(2)}mm`, '#4FABB8','middle');
  }


  function thicknessAtRadius(res, r){
    const absD = Math.abs(res.D);
    const term = (r*r*absD) / (2000*(res.n-1));

    if(res.lensType === 'minus'){
      return res.centerT + term;
    }else{
      // é è¦–ï¼šç”¨ã€Œè–„å´åŠå¾‘ã€å›æ¨ä¸­å¿ƒåšï¼Œç¢ºä¿è–„å´ = edgeT
      const rThin = Math.max(res.rL, res.rR); // æˆ–ç”¨ rMax ä¹Ÿè¡Œ
      const center = res.edgeT + (rThin*rThin*absD) / (2000*(res.n-1));
      return Math.max(0, center - term);
    }
  }

  function thicknessAt(res, side){
    const r = (side === 'L') ? res.rL : res.rR;
    return thicknessAtRadius(res, r);
  }

  function ellipse(svg, cx, cy, rx, ry, fill, stroke, sw, dash){
    const el = document.createElementNS('http://www.w3.org/2000/svg','ellipse');
    el.setAttribute('cx',cx);
    el.setAttribute('cy',cy);
    el.setAttribute('rx',rx);
    el.setAttribute('ry',ry);
    el.setAttribute('fill',fill);
    el.setAttribute('stroke',stroke);
    el.setAttribute('stroke-width',sw);
    if(dash) el.setAttribute('stroke-dasharray',dash);
    svg.appendChild(el);
  }

let _L3D = null;

function init3D(){
  if (_L3D || !window.THREE) return;
  const wrap = document.getElementById('threeWrap');
  if (!wrap) return;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0a1322);

  const camera = new THREE.PerspectiveCamera(35, wrap.clientWidth / wrap.clientHeight, 0.1, 1000);
  camera.position.set(0, 25, 85);

  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(wrap.clientWidth, wrap.clientHeight);
  wrap.innerHTML = '';
  wrap.appendChild(renderer.domElement);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  // lights
  const key = new THREE.DirectionalLight(0xffffff, 0.9); key.position.set(1,2,3);
  const fil = new THREE.DirectionalLight(0x88ccff, 0.6); fil.position.set(-2,1,0);
  const amb = new THREE.AmbientLight(0x334455, 0.6);
  scene.add(key, fil, amb);

  // subtle grid
  const grid = new THREE.GridHelper(200, 20, 0x1f3045, 0x182435);
  grid.position.y = -0.01; scene.add(grid);

  _L3D = {wrap, scene, camera, renderer, controls,
        mesh:null, ring:null, edge:null, slice:null, rim:null};

  window.addEventListener('resize', ()=>{
    if(!_L3D) return;
    const {wrap, camera, renderer} = _L3D;
    camera.aspect = wrap.clientWidth / wrap.clientHeight; 
    camera.updateProjectionMatrix();
    renderer.setSize(wrap.clientWidth, wrap.clientHeight);
  });

  (function loop(){ if(!_L3D) return; requestAnimationFrame(loop); _L3D.controls.update(); _L3D.renderer.render(_L3D.scene, _L3D.camera); })();
}

    // åšåº¦æ¨¡å‹
  // ä¾åšåº¦èˆ‡åº¦æ•¸å»ºç«‹ã€Œå¹³å‡¸ / å¹³å‡¹ã€å¯¦å¿ƒé¡ç‰‡
  function buildLensLatheGeometry(res){
    if (!window.THREE) return null;

    const n    = Number(res.n) || 0;
    const D    = Number(res.D) || 0;
    const absD = Math.abs(D);
    if (!n || !D) {
      // æ²’æœ‰åº¦æ•¸å°±ä¸ç•«
      return null;
    }
    const denom = 2000 * (n - 1) || 1;
    const sag   = r => (r * r * absD) / denom;   // r ä»¥ mm è¨ˆç®—å¹¾ä½•å¼§é«˜

    const rL    = Math.max(0, Number(res.rL)   || 0);
    const rR    = Math.max(0, Number(res.rR)   || 0);
    const cutR  = Math.max(0, Number(res.cutR) || 0);

    // é¡ç‰‡å¯¦éš›åŠå¾‘ï¼šä»¥é¡å¯ç‰‡å¾‘ç‚ºä¸»ï¼Œæ²’æœ‰å°±ç”¨è£å‹ / rL / rR è£œä¸Š
    let rEdgeReal = Number(res.blankDia) ? Number(res.blankDia)/2 : 0;
    if (!rEdgeReal) rEdgeReal = Math.max(rL, rR, cutR);

    // åšåº¦å‡½å¼ï¼šèˆ‡ calc() / 2D å¡ç‰‡é‚è¼¯ä¸€è‡´
    let tAt;
    if (res.lensType === 'minus') {
      // è² é¡ï¼šæŒ‡å®šä¸­å¿ƒåšï¼Œé‚Šåš = centerT + sag(r)
      const centerT = Number(res.centerT) || 0;
      tAt = r => centerT + sag(r);                 // ä¸­å¿ƒè–„ï¼Œé‚Šåš
    } else {
      // æ­£é¡ï¼šæŒ‡å®šé‚Šç·£åšï¼Œç”¨ã€Œæœ€è–„å´åŠå¾‘ã€å›æ¨ä¸­å¿ƒåš
      const edgeT = Number(res.edgeT) || 0;
      const rThin = Math.max(rL, rR);              // æœ€è–„å´æ‰€åœ¨åŠå¾‘
      const center = edgeT + sag(rThin);           // ç”±è–„å´æ¨å›ä¸­å¿ƒåš
      tAt = r => Math.max(0, center - sag(r));     // ä¸­å¿ƒåšï¼Œé‚Šè–„
    }

    // è¦–è¦ºç¸®æ”¾ï¼šåŠå¾‘ / åšåº¦
    const sR = 0.6;   // åŠå¾‘ç¸®æ”¾
    const sT = 0.8;   // åšåº¦ç¸®æ”¾ï¼ˆè¦ºå¾—å¤ªæ‰å¯ä»¥èª¿å¤§ï¼‰
    const N  = 96;
    const pts = [];

    if (res.lensType === 'minus') {
      // ğŸ”µ è² é€é¡ï¼šå‰è¡¨å¹³ / å¾Œè¡¨å‡¹
      // å‰è¡¨å¹³é¢ y=0ï¼šå¤–åœˆ -> ä¸­å¿ƒ
      for (let i = 0; i <= N; i++) {
        const rr = rEdgeReal * (1 - i / N);   // rEdge..0
        const X  = rr * sR;
        const Y  = 0;
        pts.push(new THREE.Vector2(X, Y));
      }
      // å‰è¡¨ä¸­å¿ƒ -> å¾Œè¡¨ä¸­å¿ƒï¼ˆå¾€ä¸‹ï¼‰
      const t0 = tAt(0);
      pts.push(new THREE.Vector2(0, -t0 * sT));
      // å¾Œè¡¨å‡¹é¢ï¼šä¸­å¿ƒ -> å¤–åœˆ
      for (let i = 0; i <= N; i++) {
        const rr = rEdgeReal * (i / N);       // 0..rEdge
        const t  = tAt(rr);
        const X  = rr * sR;
        const Y  = -t * sT;
        pts.push(new THREE.Vector2(X, Y));
      }
    } else {
      // ğŸŸ¢ æ­£é€é¡ï¼šå‰è¡¨å‡¸ / å¾Œè¡¨å¹³
      // å¾Œè¡¨å¹³é¢ y=0ï¼šå¤–åœˆ -> ä¸­å¿ƒ
      for (let i = 0; i <= N; i++) {
        const rr = rEdgeReal * (1 - i / N);
        const X  = rr * sR;
        const Y  = 0;
        pts.push(new THREE.Vector2(X, Y));
      }
      // å¾Œè¡¨ä¸­å¿ƒ -> å‰è¡¨ä¸­å¿ƒï¼ˆå¾€ä¸Šï¼‰
      const t0 = tAt(0);
      pts.push(new THREE.Vector2(0, t0 * sT));
      // å‰è¡¨å‡¸é¢ï¼šä¸­å¿ƒ -> å¤–åœˆ
      for (let i = 0; i <= N; i++) {
        const rr = rEdgeReal * (i / N);
        const t  = tAt(rr);
        const X  = rr * sR;
        const Y  = t * sT;
        pts.push(new THREE.Vector2(X, Y));
      }
    }

    const geom = new THREE.LatheGeometry(pts, 128);
    geom.computeVertexNormals();
    geom.userData = {
      rEdgeReal,  // çœŸå¯¦é¡ç‰‡åŠå¾‘ (mm)
      sR,         // åŠå¾‘ç¸®æ”¾
      sT          // åšåº¦ç¸®æ”¾
    };
    return geom;
  }

function update3D(res){
  if (!window.THREE) return;
  init3D();
  if (!_L3D) return;

  const scene = _L3D.scene;

  // ---------- æ¸…é™¤èˆŠç‰©ä»¶ ----------
  ["mesh","edge","ring","rim","slice"].forEach(key => {
    const obj = _L3D[key];
    if (!obj) { _L3D[key] = null; return; }

    if (Array.isArray(obj)) {
      obj.forEach(o => {
        if (!o) return;
        scene.remove(o);
        if (o.geometry) o.geometry.dispose();
        if (o.material) o.material.dispose();
      });
    } else {
      scene.remove(obj);
      if (obj.geometry) obj.geometry.dispose();
      if (obj.material) obj.material.dispose();
    }
    _L3D[key] = null;
  });

  // ---------- å»ºé¡ç‰‡å¹¾ä½• ----------
  const g = buildLensLatheGeometry(res);
  if (!g) return;

  const rEdgeReal =
    g.userData.rEdgeReal ||
    (Number(res.blankDia) ? Number(res.blankDia) / 2
                          : (Number(res.cutR) || (Number(res.ED) || 0) / 2 || 0));

  const sR = g.userData.sR || g.userData.rScale || 0.6;
  const sT = g.userData.sT || g.userData.tScale || 0.8;

  // åšåº¦å‡½å¼ï¼ˆè·Ÿ buildLensLatheGeometry å®Œå…¨ä¸€è‡´ï¼Œå¾Œé¢ rim / åå­—çª—ç°¾éƒ½æœƒç”¨åˆ°ï¼‰
  const n     = Number(res.n) || 0;
  const D     = Number(res.D) || 0;
  const absD  = Math.abs(D);
  const denom = 2000 * (n - 1) || 1;
  const sag   = r => (r * r * absD) / denom;

  let tAt;
  if (res.lensType === "minus") {
    const centerT = Number(res.centerT) || 0;
    tAt = r => centerT + sag(r);             // è² é¡ï¼šä¸­å¿ƒè–„ã€é‚Šåš
  } else {
    const edgeT = Number(res.edgeT) || 0;
    const rThin = Math.max(Number(res.rL) || 0, Number(res.rR) || 0);
    const center = edgeT + sag(rThin);
    tAt = r => Math.max(0, center - sag(r)); // æ­£é¡ï¼šä¸­å¿ƒåšã€é‚Šè–„
  }

  // ---------- 1. é¡ç‰‡æœ¬é«” + å¤–è¼ªå»“ ----------
  const lensMat = new THREE.MeshPhysicalMaterial({
    color: 0xaad9ff,   // æ·¡è—
    roughness: 0.25,
    metalness: 0.0,
    transmission: 0.4,
    transparent: true,
    opacity: 0.18,
    side: THREE.DoubleSide
  });
  const mesh = new THREE.Mesh(g, lensMat);
  mesh.position.y = 6;
  mesh.renderOrder = 0;
  scene.add(mesh);
  _L3D.mesh = mesh;

  const edgeGeo = new THREE.EdgesGeometry(g);
  const edgeMat = new THREE.LineBasicMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.2
  });
  const edgeLines = new THREE.LineSegments(edgeGeo, edgeMat);
  edgeLines.position.copy(mesh.position);
  edgeLines.renderOrder = 0;
  scene.add(edgeLines);
  _L3D.edge = edgeLines;

  // ---------- 2. å´é‚Šåœ“æŸ±ç‰† ----------
  if (rEdgeReal > 0) {
    let hVis = 0;
    let centerYOffset = 0;

    if (res.lensType === "minus") {
      // è¿‘è¦–ï¼šç¶­æŒä½ åŸæœ¬å–œæ­¡çš„æ•ˆæœ â†’ å¤šæ•¸æƒ…æ³ç”¨æ•´å€‹ boundingBox é«˜åº¦
      g.computeBoundingBox();
      const bb = g.boundingBox;
      if (bb) {
        hVis = bb.max.y - bb.min.y;
        centerYOffset = (bb.max.y + bb.min.y) / 2;
      }
    } else {
      // é è¦–ï¼šé«˜åº¦ç”¨ã€Œé‚Šç·£åšåº¦ã€ï¼Œè€Œä¸æ˜¯ä¸­å¿ƒæœ€å‡¸é»
      const tEdge = tAt(rEdgeReal);   // mm
      const tEdgeVis = tEdge * sT;    // å¹¾ä½•åº§æ¨™é«˜åº¦
      hVis = tEdgeVis;
      centerYOffset = tEdgeVis / 2;   // å¾Œè¡¨å¹³åœ¨ y=0ï¼Œå‰è¡¨åœ¨ +tEdge
    }

    if (hVis > 0.0001) {
      const rWorld = rEdgeReal * sR * 1.002; // ç¨å¾®æ”¾å¤§ï¼Œé¿å… Z-fighting
      const rimGeo = new THREE.CylinderGeometry(
        rWorld, rWorld, hVis, 64, 1, true   // openEnded=trueï¼Œåªè¦å´é‚Š
      );
      const rimMat = new THREE.MeshBasicMaterial({
        color: 0x7a9bcc,
        transparent: true,
        opacity: 0.15,
        side: THREE.DoubleSide,
        depthWrite: false
      });
      const rim = new THREE.Mesh(rimGeo, rimMat);
      rim.position.y = mesh.position.y + centerYOffset;
      rim.renderOrder = 1; 
      scene.add(rim);
      _L3D.rim = rim;
    }
  }

  // ---------- 3. è£å‹åœˆï¼ˆé«˜äº®ï¼Œä¸è¢«é¡ç‰‡åƒæ‰ï¼‰ ----------
  const cutRReal = Number(res.cutR) || (Number(res.ED) || 0) / 2;
  const decReal  = Math.abs(Number(res.dec) || 0);

  if (cutRReal > 0) {
    const ringRadius = cutRReal * sR;
    const ringGeo = new THREE.TorusGeometry(ringRadius, 0.6, 16, 160);
    const ringMat = new THREE.MeshBasicMaterial({
      color: 0x22c55e,
      transparent: true,
      opacity: 0.2,
      depthTest: false, 
      depthWrite: false
    });
    const ring = new THREE.Mesh(ringGeo, ringMat);
    ring.rotation.x = Math.PI / 2;
    ring.position.y = mesh.position.y;
    ring.position.x = decReal * sR;
    ring.renderOrder = 9;  
    scene.add(ring);
    _L3D.ring = ring;
  }

  // ---------- 4. åå­—å­åˆç·šã€Œçª—ç°¾ã€åšåº¦åˆ‡é¢ ----------
  const ringInside = (decReal + cutRReal) <= rEdgeReal + 1e-6;

  function buildCurtain(sMinReal, sMaxReal, mode){
    if (sMaxReal <= sMinReal) return null;

    const NX = 64;
    const top = [];
    const bottom = [];

    for (let i = 0; i <= NX; i++){
      const tt = i / NX;
      const sReal = sMinReal + (sMaxReal - sMinReal) * tt;

      let xReal, zReal;
      if (mode === "x") {
        // æ²¿åå¿ƒæ–¹å‘ï¼šx = dec + s, z = 0
        xReal = decReal + sReal;
        zReal = 0;
      } else {
        // å‚ç›´æ–¹å‘ï¼šx = dec, z = s
        xReal = decReal;
        zReal = sReal;
      }

      const rReal = Math.sqrt(xReal * xReal + zReal * zReal);
      const thick = tAt(rReal);     // mm
      const tVis  = thick * sT;     // å¹¾ä½•åº§æ¨™é«˜åº¦

      let yTopLocal, yBotLocal;
      if (res.lensType === "minus") {
        // è² é¡ï¼šå‰è¡¨å¹³åœ¨ y=0ï¼Œå¾Œè¡¨å¾€ä¸‹å‡¹
        yTopLocal = 0;
        yBotLocal = -tVis;
      } else {
        // æ­£é¡ï¼šå¾Œè¡¨å¹³åœ¨ y=0ï¼Œå‰è¡¨å¾€ä¸Šå‡¸
        yBotLocal = 0;
        yTopLocal = tVis;
      }

      const xWorld = xReal * sR;
      const zWorld = zReal * sR;

      top.push(   new THREE.Vector3(xWorld, yTopLocal,  zWorld));
      bottom.push(new THREE.Vector3(xWorld, yBotLocal, zWorld));
    }

    const verts = [];
    for (let i = 0; i < NX; i++){
      const t1 = top[i],   t2 = top[i+1];
      const b1 = bottom[i],b2 = bottom[i+1];

      // ä¸‰è§’å½¢ 1
      verts.push(
        t1.x, t1.y, t1.z,
        b1.x, b1.y, b1.z,
        t2.x, t2.y, t2.z
      );
      // ä¸‰è§’å½¢ 2
      verts.push(
        b1.x, b1.y, b1.z,
        b2.x, b2.y, b2.z,
        t2.x, t2.y, t2.z
      );
    }

    const sliceGeo = new THREE.BufferGeometry();
    sliceGeo.setAttribute(
      "position",
      new THREE.Float32BufferAttribute(verts, 3)
    );
    sliceGeo.computeVertexNormals();

    const sliceMat = new THREE.MeshBasicMaterial({
      color: ringInside ? 0x22c55e : 0xef4444, // ç¶ ï¼šé¡å¯è¶³å¤ ï¼›ç´…ï¼šé¡å¯ä¸è¶³
      transparent: true,
      opacity: 0.55,
      side: THREE.DoubleSide,
      depthTest: false,   // âœ… æ°¸é åœ¨é¡ç‰‡ / rim / è£å‹åœˆä¸Šé¢
      depthWrite: false
    });

    const slice = new THREE.Mesh(sliceGeo, sliceMat);
    slice.position.y = mesh.position.y;
    slice.renderOrder = 10;
    scene.add(slice);
    return slice;
  }

  const slices = [];

  // 4-1 æ²¿åå¿ƒæ–¹å‘çš„å­åˆç·š
  const xMinReal = Math.max(-rEdgeReal, decReal - cutRReal);
  const xMaxReal = Math.min( rEdgeReal, decReal + cutRReal);
  if (xMaxReal > xMinReal){
    const sMinX = xMinReal - decReal;
    const sMaxX = xMaxReal - decReal;
    const sliceX = buildCurtain(sMinX, sMaxX, "x");
    if (sliceX) slices.push(sliceX);
  }

  // 4-2 èˆ‡åå¿ƒæ–¹å‘å‚ç›´çš„å­åˆç·š
  const zLimitLens = Math.sqrt(Math.max(0, rEdgeReal * rEdgeReal - decReal * decReal));
  const zLimit = Math.min(cutRReal, zLimitLens);
  if (zLimit > 0){
    const sliceZ = buildCurtain(-zLimit, zLimit, "z");
    if (sliceZ) slices.push(sliceZ);
  }

  _L3D.slice = slices;
}
  // ç¹ªåœ–å°å·¥å…·
  function circle(svg,cx,cy,r,fill,stroke,sw, dash){
    const el=document.createElementNS('http://www.w3.org/2000/svg','circle');
    el.setAttribute('cx',cx);el.setAttribute('cy',cy);el.setAttribute('r',r);
    el.setAttribute('fill',fill);el.setAttribute('stroke',stroke);el.setAttribute('stroke-width',sw);
    if(dash) el.setAttribute('stroke-dasharray',dash);
    svg.appendChild(el);
  }
  function line(svg,x1,y1,x2,y2,stroke,sw){
    const el=document.createElementNS('http://www.w3.org/2000/svg','line');
    el.setAttribute('x1',x1);el.setAttribute('y1',y1);el.setAttribute('x2',x2);el.setAttribute('y2',y2);
    el.setAttribute('stroke',stroke);el.setAttribute('stroke-width',sw);svg.appendChild(el);
  }
  function rect(svg,x,y,w,h,fill){
    const el=document.createElementNS('http://www.w3.org/2000/svg','rect');
    el.setAttribute('x',x);el.setAttribute('y',y);el.setAttribute('width',w);el.setAttribute('height',h);el.setAttribute('fill',fill);svg.appendChild(el);
  }
  function text(svg, x, y, str, fill, anchor, lineHeight = 14) {
    const el = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    el.setAttribute('x', x);
    el.setAttribute('y', y);
    el.setAttribute('fill', fill || '#111');
    if (anchor) el.setAttribute('text-anchor', anchor);
    el.style.fontSize = '12px';

    const parts = String(str).split(/\n|\(æ›è¡Œ\)/g);
    parts.forEach((ln, i) => {
      const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
      tspan.setAttribute('x', x);
      tspan.setAttribute('dy', i === 0 ? '0' : String(lineHeight));
      tspan.textContent = ln;
      el.appendChild(tspan);
    });
    svg.appendChild(el);
  }

  function update(){
    const res = calc();

    // é¡¯ç¤ºåº¦æ•¸ï¼ˆ+/-ï¼‰
    $("d_display").textContent = 'ç›®å‰ï¼š' + ((res.D>0?'+':'') + (res.D||0).toFixed(2) + ' D');

    // KPI
    $("k_framePD").textContent = res.framePD.toFixed(1)+" mm";
    $("k_dec").textContent     = res.dec.toFixed(2)+" mm";
    $("k_cutDia").textContent  = (res.cutR*2).toFixed(1)+" mm";
    $("k_reqR").textContent    = res.hReq.toFixed(1)+" mm";
    $("k_minBlank").textContent= res.minBlank.toFixed(1)+" mm";
    $("k_minBlank").className  = 'v' + (res.blankOK?'':' danger');
    $("k_blankOK").textContent = (res.blankOK?"âœ… è¶³å¤ ":"âŒ ä¸è¶³");

    $("k_delta").textContent   = res.delta.toFixed(2)+" mm";
    $("k_center").textContent  = res.estCenter.toFixed(2)+" mm";
    $("k_edge").textContent    = res.estEdgeMin.toFixed(2)+" mm";
    $("k_tip").textContent     = (res.estEdgeMin - res.grooveDepth).toFixed(2)+" mm";

    $("k_halfSafety").textContent = (res.tipRemain>=res.need?`âœ… â‰¥ ${res.need} mm`:`âš ï¸ < ${res.need} mm`);

    const rimOK = $("rimType").value==='groove' ? res.halfOK : (res.estEdgeMin - res.grooveDepth >= res.minTip);
    $("k_result").textContent = rimOK?"âœ… å¯è¡Œ (è¿‘ä¼¼)":"âŒ é¢¨éšªï¼šåšåº¦å¯èƒ½ä¸è¶³";

    drawTop(res); drawSection(res);update3D(res);
  }

  update();init3D();
})();
</script>
</body>
</html>


