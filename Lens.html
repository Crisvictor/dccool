<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link rel="icon" href="img/optometry.png" type="image/x-icon">
<link rel="shortcut icon" href="img/optometry.png" type="image/x-icon">
<script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<title>鏡片厚度模擬器</title>
<style>
  :root{
    --bg:#0b1220;          /* 背景 */
    --ink:#e5e7eb;         /* 主要文字 */
    --muted:#94a3b8;       /* 次要文字 */
    --card:#0f172a;        /* 卡片底色 */
    --border:#1e293b;      /* 邊框色 */
    --pri:#38bdf8;         /* 重點/焦點色 */
    --ok:rgba(34, 197, 94, .4);
    --ng:rgba(248, 113, 113, .4);
  }
  html,body{height:100%}
  body{
    margin:0;
    font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans TC",Arial;
    background:radial-gradient(1200px 800px at 20% -10%,#0e1728 0%,#0b1220 55%),
               radial-gradient(800px 800px at 90% 10%,#0a1a2f 0%,transparent 60%),
               var(--bg);
    color:var(--ink);
  }
  .wrap{max-width:1200px;margin:24px auto;padding:0 16px}
  h1{font-size:22px;margin:0 0 12px;color:#f1f5f9}
  .grid{display:grid;gap:10px}
  .g-3{grid-template-columns:repeat(3,minmax(0,1fr))}
  .card{
    background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,.02));
    border:1px solid var(--border);
    border-radius:16px;
    box-shadow:0 10px 35px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.03);
    backdrop-filter:saturate(110%) blur(2px);
  }
  .card>.hd{
    padding:12px 16px;
    border-bottom:1px solid var(--border);
    font-weight:580;
    color:#cbd5e1;
  }
  .card>.bd{padding:8px 16px}
  .row{display:grid;grid-template-columns:1fr 160px;align-items:center;gap:8px;margin:8px 0}
  .row label{color:var(--muted);font-size:12px}
  input,select{
    width:100%;max-width:100%;box-sizing:border-box;
    padding:8px 10px;
    border:1px solid #334155;
    background:#0b1628;
    color:var(--ink);
    border-radius:10px;font-size:14px;outline:none;
    transition:border-color .15s, box-shadow .15s, background .15s;
  }
  input::placeholder{color:#71839a}
  select option{background:#0b1628;color:var(--ink)}
    input:focus,select:focus{
    border-color:#60a5fa;
    box-shadow:0 0 0 2px rgba(56,189,248,.25);
    background:#0c1a31;
  }
  .thick-vert{
    margin-top:4px;
    font-size:11px;
    color:var(--muted);
    line-height:1.4;
  }
  .kpis{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:6px}
  .kpi{
    border:1px solid var(--border);
    border-radius:8px;
    background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.02));
    padding:5px
  }
  .kpi .t{font-size:11px;color:var(--muted)}
  .kpi .v{font-weight:700;margin-top:2px;color:#e2e8f0}
  .tag-warn{
    display:inline-block;
    margin-left:4px;
    padding:1px 4px;
    border-radius:4px;
    font-size:10px;
    color:#b91c1c;
    background:#fee2e2;
  }
  .canvas{
    aspect-ratio:1/1;border-radius:16px;
    border:1px solid var(--border);
    background:radial-gradient(500px 400px at 60% 40%,rgba(148,163,184,.08),transparent 60%),
               #0b1324;
    display:flex;align-items:center;justify-content:center
  }
  .kpi-double{
    display:flex;
    flex-direction:column;
    gap:11px;
  }
  .kpi-subcard{
    padding-top:8px;
    border-top:1px solid var(--border);
  }
  .kpi-subcard:first-child{
    border-top:none;
  }
  .kpi-subtitle{
    font-size:12px;
    color:var(--muted);
    font-weight:600;
    margin-bottom:6px;
  }
  .note{font-size:12px;color:var(--muted)}
  .danger{color:var(--ng);font-weight:700}
  @media (max-width:980px){.g-3{grid-template-columns:1fr}}
  hr{border:0;border-top:1px dashed var(--border);margin:10px 0}
</style>
</head>
<body>
  <div class="wrap">
    <h1>鏡片厚度模擬器</h1>
    <p class="note">用途：在訂製前，輸入度數/折射率與框參數，估算裁型後邊緣厚度是否足夠做出溝尖與車溝，並檢查鏡坯片徑是否足夠。<br>聲明：本教學工具為厚度幾何近似值，未含前後表面彎度（BC）設定與折射面設計（如非球面與多焦）仍會產生誤差，實務仍需以加工經驗為準。</p>

    <div class="grid g-3">
      <div class="card">
        <div class="hd">參數輸入 [訂製鏡片]</div>
        <div class="bd">
          <div class="row"><label>鏡片類型</label><select id="lensType"><option value="minus">近視</option><option value="plus">遠視</option></select></div>
          <div class="row"><label>球鏡 D (±)</label><input id="D" type="number" step="0.25" value="-6" min="-20" max="20"></div>
          <div class="note" id="d_display">目前：-6.00 D</div>
          <div class="row"><label>折射率 n</label>
            <select id="n">
              <option value="1.50">1.50</option>
              <option value="1.56">1.56</option>
              <option value="1.61">1.61</option>
              <option value="1.67" selected>1.67</option>
              <option value="1.74">1.74</option>
            </select>
          </div>
          <div class="row" data-for="minus"><label>指定中心厚 (mm)</label><input id="centerT" type="number" step="0.1" value="1.2" min="1.0" max="3.0"></div>
          <div class="row" data-for="plus" style="display:none"><label>設定邊緣厚 (mm)</label><input id="edgeT" type="number" step="0.1" value="2.0" min="0.2" max="3.0"></div>
          <div class="row"><label>鏡坯片徑 (mm)</label><input id="blankDia" type="number" step="1" value="65" min="50" max="80"></div>
        </div>
      </div>

      <div class="card">
        <div class="hd">平面視圖（鏡坯 / 裁型 ）</div>
        <div class="bd">
          <div class="canvas"><svg id="topView" width="340" height="340"></svg></div>
          <p class="note">圖示：外圈＝鏡坯片徑；內圈＝裁型直徑（ED）；<br>綠/紅環＝邊緣厚達標/不足；鏡坯不足→外圈紅色。</p>
        </div>
      </div>

      <div class="card">
        <div class="hd">裁型邊緣厚度（含偏心影響）</div>
        <div class="bd">
          <div class="canvas"><svg id="sectionView" width="340" height="340"></svg></div>
          <p class="note">橫切面鏡片裁型偏心而產生不同邊緣厚度，<br>評估最薄側是否可開車溝。</p>
        </div>
      </div>
    </div>

    <div class="grid g-3" style="margin-top:16px">
      <div class="card">
        <div class="hd">參數輸入 [框參數] </div>
        <div class="bd">
          <div class="row"><label>有效直徑 ED (mm)</label><input id="ED" type="number" step="0.5" value="53" min="20" max="80"></div>
          <div class="row"><label>框寬 A (mm)</label><input id="A" type="number" step="0.5" value="52" min="20" max="80"></div>
          <div class="row"><label>框高 B (mm)</label><input id="B" type="number" step="0.5" value="40" min="15" max="80"></div>
          <div class="row"><label>中樑距 DBL (mm)</label><input id="DBL" type="number" step="0.5" value="18" min="10" max="40"></div>
          <div class="row"><label>瞳距 PD (mm)</label><input id="PD" type="number" step="0.5" value="62" min="40" max="80"></div>
          <div class="row"><label>瞳高 PH (mm)</label><input id="pupilH" type="number" step="0.5" value=""></div>
          <div class="note">若留空則預設為 B/1.7，視為瞳高約於框2/3高。</div>
          <div class="row"><label>預留加工 (mm)</label><input id="allowance" type="number" step="0.5" value="2" min="0" max="4"></div>

          <div class="row"><label>框溝寬/車溝寬 (mm)</label><input id="grooveDepth" type="number" step="0.1" value="0.8" min="0.3" max="3"></div>
          <div class="row"><label>最小剩餘厚度需求 (mm)</label><input id="minTip" type="number" step="0.1" value="1.5" min="0.3" max="2"></div>
          <div class="row"><label>框型</label><select id="rimType"><option value="full">全框</option><option value="groove">車溝框</option></select></div>
        </div>
      </div>

      <div class="card">
        <div class="hd">3D 厚度視覺（概念示意）</div>
        <div class="bd">
          <div id="threeWrap" style="width:100%;height:340px;border-radius:12px;border:1px solid var(--border);background:#0a1322;overflow:hidden"></div>
          <p class="note">此 3D 為旋轉對稱概念示意：依厚度函式產生鏡片（圓形）。<br>裁型厚度分布： 水平=綠，垂直=黃；超出鏡坯則為紅</p>
        </div>
      </div>
     
      <div class="card">
        <div class="hd">裁型 / 鏡坯 & 厚度檢核</div>
        <div class="bd kpi-double">

          <!-- 上半：裁型 & 鏡坯評估 -->
          <div class="kpi-subcard">
            <div class="kpi-subtitle">裁型 & 鏡坯評估</div>
            <div class="kpis">
              <div class="kpi">
                <div class="t">框心距 (A+DBL)</div>
                <div id="k_framePD" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">水平偏心</div>
                <div id="k_dec" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">鏡坯邊緣厚度(最厚)</div>
                <div id="k_cutDia" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">垂直偏心</div>
                <div id="k_reqR" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">鏡坯最小建議片徑</div>
                <div id="k_minBlank" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">鏡坯是否足夠</div>
                <div id="k_blankOK" class="v"></div>
              </div>
            </div>
          </div>

          <!-- 下半：厚度 & 溝尖/車溝檢核（近似） -->
          <div class="kpi-subcard">
            <div class="kpi-subtitle">厚度 & 溝尖/車溝檢核（近似）</div>
            <div class="kpis">
              <div class="kpi">
                <div class="t">厚度差值△</div>
                <div id="k_delta" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">中心厚估</div>
                <div id="k_center" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">邊緣厚（薄側）</div>
                <div id="k_edge" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">不含溝尖/車溝邊厚（薄側）</div>
                <div id="k_tip" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">車溝/溝尖安全線</div>
                <div id="k_halfSafety" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">結果</div>
                <div id="k_result" class="v"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>


<script>
(function(){
  const $ = (id)=>document.getElementById(id);
  const ids = ["lensType","D","n","centerT","edgeT","blankDia","ED","A","B","DBL","PD","allowance","grooveDepth","minTip","rimType","pupilH"];
  ids.forEach(id=>$(id).addEventListener('input', update));
  $("lensType").addEventListener('change', ()=>{
    const t = $("lensType").value;
    document.querySelector('[data-for="minus"]').style.display = (t==='minus')?'' : 'none';
    document.querySelector('[data-for="plus"]').style.display  = (t==='plus') ?'' : 'none';
    update();
  });

  function clamp(v,min,max){ v=parseFloat(v); if(isNaN(v)) return min; return Math.min(Math.max(v,min),max); }

  function calc(){
    const lensType = $("lensType").value; // minus/plus
    const D  = parseFloat($("D").value);
    const n  = parseFloat($("n").value);
    const centerT = clamp($("centerT").value,1.0,3.0);
    const edgeT   = clamp($("edgeT").value,0.2,3.0);
    const blankDia= clamp($("blankDia").value,50,80);

    
    const ED = clamp($("ED").value,20,80);
    const A  = clamp($("A").value,20,80);
    const B  = clamp($("B").value,20,80);
    const DBL= clamp($("DBL").value,10,40);
    const PD = clamp($("PD").value,40,80);
    const allowance = clamp($("allowance").value,0,4);
    let pupilH = $("pupilH").value;
        pupilH = pupilH === "" ? (B / 1.7) : clamp(pupilH, 0, B);

    const grooveDepth = clamp($("grooveDepth").value,0.3,0.9);
    const minTip = clamp($("minTip").value,0.8,2);
    const rimType = $("rimType").value; // full/groove

    const framePD = A + DBL;
    const dec = Math.abs(framePD - PD)/2; // 單眼偏心
    const decAbs = Math.abs(dec || 0); 

    // 水平方向：以框寬 A/2 為基準
    const halfA = A / 2;
    const rL = Math.max(0, halfA - dec); // 左邊實際到光學中心距離
    const rR = halfA + dec;              // 右邊實際到光學中心距離

    // 斜邊 ED：用來算最大半徑與鏡坯需求
    const cutR = ED/2;                  // 視覺上的裁型「等效圓半徑」
    const rMax = cutR + dec;           // 最遠那一點（對角線 + 偏心）

    // 鏡坯需求半徑、片徑（沿用原本概念）
    const hReq = rMax + allowance;
    const minBlank = 2 * hReq;
    const blankOK  = (blankDia/2) >= hReq;

    const absD  = Math.abs(D);
    const denom = 2000 * (n - 1) || 1;
    const sag   = r => (r * r * absD) / denom;

    const rThin   = Math.max(rL, rR);   // 水平薄側 / 最大半徑
    const blankR  = blankDia / 2;       // 鏡坯半徑
    const rDesign = Math.max(rThin, blankR);

    // Δ：以 rThin 為參考半徑，中心與該半徑的厚度差
    const rRef  = rThin;
    const delta = sag(rRef);            // 對近視/遠視都一樣是 sag(rRef)

    function tMinus(r){
      return centerT + sag(r);          // 近視：中心薄、邊緣厚
    }

    function tPlus(r){
      // 遠視：設計讓 rDesign 處厚度 = edgeT，鏡坯越大 → 中心越厚
      const center = edgeT + sag(rDesign);
      const rr     = Math.min(r, rDesign);
      return Math.max(0, center - sag(rr));
    }

    let tL, tR, estCenter, estEdgeMin;
    if (lensType === 'minus') {
      estCenter = centerT;
      tL = tMinus(rL);
      tR = tMinus(rR);
    } else {
      estCenter = tPlus(0);   // 中心厚估
      tL = tPlus(rL);
      tR = tPlus(rR);
    }
    estEdgeMin = Math.min(tL, tR);      // 左右最薄側邊厚

    const tipRemain = estEdgeMin - grooveDepth; // 薄側尖端剩餘厚度

    // 車溝框安全（建議 ≥1.0 或使用者設定）
    const need   = Math.max(1.0, minTip);
    const halfOK = tipRemain >= need;

    return {lensType,D,n,centerT,edgeT,blankDia,ED,A,B,DBL,PD,allowance,grooveDepth,minTip,rimType,pupilH,
      framePD,dec,cutR,hReq,blankOK,delta,estCenter,estEdgeMin,tipRemain,halfOK,minBlank,rL,rR,rMax,need};
  }

  function drawTop(res){
    const svg = $("topView");
    const W = svg.viewBox.baseVal.width  || 340;
    const H = svg.viewBox.baseVal.height || 340;
    svg.setAttribute("viewBox", `0 0 ${W} ${H}`);
    svg.innerHTML = "";

    const cx = W / 2;
    const cy = H / 2;

    const blankR = Math.min(W, H) * 0.42;
    const rBlankReal = res.blankDia / 2;
    if (!rBlankReal || !isFinite(rBlankReal)) return;

    const scale = blankR / rBlankReal;

    const A = Number(res.A) || 0;
    const B = Number(res.B) || 0;

    // --- 垂直偏心：由瞳高 H 與 B 算出 ---
    let pupilH = Number(res.pupilH);
    if (!isFinite(pupilH)) {
      // 若沒填，就用你現在的預設：B / 1.7
      pupilH = B ? B / 1.7 : 0;
    }
    pupilH = Math.min(Math.max(pupilH, 0), B);

    const halfB = B / 2;
    const vDecY = pupilH - halfB;   // mm：光學中心→框中心 垂直偏心
    const dy    = vDecY * scale;    // px
    const dx    = (Number(res.dec) || 0) * scale;  // 水平偏心

    // 框橢圓（boxing system：A×B）
    const rxFrame = (A / 2) * scale;
    const ryFrame = (B / 2) * scale;

    // 框形狀：橢圓（以框中心為圓心，受 dx, dy 影響）
    ellipse(svg, cx + dx, cy + dy, rxFrame, ryFrame, "none", "#4b5563", 2);

    // ED 等效圓（虛線）
    const rED = (res.ED / 2) * scale;
    circle(svg, cx + dx, cy + dy, rED, "none", "#6b7280", 1, "4 4");

    // 裁型半徑
    const rCut = (res.cutR / rBlankReal) * blankR;

    // 鏡坯外圈（不足時紅色）－以光學中心為圓心
    circle(svg, cx, cy, blankR, "none", res.blankOK ? "#cbd5e1" : "#ef4444", 2);

    // ★ 光學中心標示（鏡坯圓心）
    // 黃色小十字＋小圓點
    line(svg, cx - 6, cy, cx + 6, cy, "#facc15", 1.2);
    line(svg, cx, cy - 6, cx, cy + 6, "#facc15", 1.2);
    circle(svg, cx, cy, 2.5, "#facc15", "none", 0);

    // 裁型圈（以框中心相對鏡坯中心之偏心顯示）
    circle(svg, cx + dx, cy + dy, rCut, "none", "#374151", 2);

    // 溝槽達標（薄側）外圈
    const edgeColor =
      res.tipRemain >= res.need
        ? "rgba(34,197,94,0.4)"   // 綠：厚度足夠
        : "rgba(239,68,68,0.4)";  // 紅：厚度不足
    circle(svg, cx + dx, cy + dy, rCut + 8, "none", edgeColor, 8);

    // 標註文字
    text(svg, cx, cy - blankR - 8,
         `鏡坯片徑 ${res.blankDia.toFixed(0)} mm`,
         "#99B3C2");
    text(svg,
         cx + dx,
         cy + dy - rCut + 32,
         `裁型直徑 ≈ ${(res.cutR * 2).toFixed(1)} mm`,
         "#839681",
         "middle");
  }

function drawSection(res){
  const svg = $("sectionView");
  const W = svg.viewBox.baseVal.width || 340;
  const H = svg.viewBox.baseVal.height || 340;
  svg.setAttribute("viewBox", `0 0 ${W} ${H}`);
  svg.innerHTML = "";

  const cx    = W / 2;
  const baseY = H * 0.75;   // 底下：左右厚條基準線
  const baseYTop = H * 0.29; // 上面：上下緣厚條基準線

  // 橫向比例：以最大半徑 rR 對應到視圖寬度 120px
  const scaleX = 120 / Math.max(res.rR, res.cutR);
  // 厚度比例：僅視覺化用（1mm→8px）
  const scaleT = 8;

  // ===== 下層：左右邊緣厚度（你原本的內容） =====

  // 中央基準線
  line(svg, cx - 140, baseY, cx + 140, baseY, "#e5e7eb", 1);

  // 左右邊緣位置（相對鏡片中心）
  const xL = cx - res.rL * scaleX + 20;
  const xR = cx + res.rR * scaleX - 40;

  const tL = thicknessAt(res, "L");
  const tR = thicknessAt(res, "R");

  // 繪製截面（矩形示意局部厚度）
  rect(svg, xL - 6, baseY - tL * scaleT, 12, tL * scaleT, "#93c5fd");
  rect(svg, xR - 6, baseY - tR * scaleT, 12, tR * scaleT, "#93c5fd");

  // 車溝寬（紅色頂端）
  rect(
    svg,
    xL - 6,
    baseY - Math.max(0, tL - res.grooveDepth) * scaleT,
    12,
    res.grooveDepth * scaleT,
    "rgba(239,68,68,.6)"
  );
  rect(
    svg,
    xR - 6,
    baseY - Math.max(0, tR - res.grooveDepth) * scaleT,
    12,
    res.grooveDepth * scaleT,
    "rgba(239,68,68,.6)"
  );

  // 標註：左右
  text(
    svg,
    xL,
    baseY + 14,
    `左 r=${res.rL.toFixed(1)}mm\n邊厚=${tL.toFixed(2)}mm`,
    "#A9BED6",
    "middle"
  );
  text(
    svg,
    xR,
    baseY + 14,
    `右 r=${res.rR.toFixed(1)}mm\n邊厚=${tR.toFixed(2)}mm`,
    "#A9BED6",
    "middle"
  );
  text(
    svg,
    cx,
    baseY + 52,
    `溝尖寬/車溝寬 ${res.grooveDepth.toFixed(1)}mm；薄側剩餘 ${(res.estEdgeMin - res.grooveDepth).toFixed(2)}mm`,
    "#4FABB8",
    "middle"
  );

  // ===== 上層：上下緣厚度（新加的兩條） =====

  const B = Number(res.B) || 0;
  if (B > 0) {
    // 瞳高：若沒輸入就用 B/2 視為在框中心
    let pupilH = res.pupilH;
    if (!(typeof pupilH === "number" && isFinite(pupilH))) {
      pupilH = B / 2;
    }

    const halfB = B / 2;

    // 以鏡片幾何中心為原點：
    // 底緣 y = -halfB，上緣 y = +halfB，瞳孔 yP = -halfB + pupilH
    const yP = -halfB + pupilH;

    const vTop = Math.max(0, halfB - yP); // 往上到上緣距離
    const vBot = Math.max(0, pupilH);     // 往下到下緣距離 (自下緣量)

    const decAbs = Math.abs(res.dec || 0); // 水平偏心
    const rTop   = Math.sqrt(decAbs * decAbs + vTop * vTop);
    const rBot   = Math.sqrt(decAbs * decAbs + vBot * vBot);

    const tTop = thicknessAtRadius(res, rTop);
    const tBot = thicknessAtRadius(res, rBot);

    // 上層基準線
    line(svg, cx - 140, baseYTop, cx + 140, baseYTop, "#C6E398", 1);

    // 上/下 緣柱子位置
    const topGap = 120;           
    const xTop = cx - topGap/2;   // 上緣
    const xBot = cx + topGap/2; 

    // 上緣厚條
    rect(svg, xTop - 6, baseYTop - tTop * scaleT, 12, tTop * scaleT, "#bfdbfe");
    rect(
      svg,
      xTop - 6,
      baseYTop - Math.max(0, tTop - res.grooveDepth) * scaleT,
      12,
      res.grooveDepth * scaleT,
      "rgba(239,68,68,.5)"
    );

    // 下緣厚條
    rect(svg, xBot - 6, baseYTop - tBot * scaleT, 12, tBot * scaleT, "#bfdbfe");
    rect(
      svg,
      xBot - 6,
      baseYTop - Math.max(0, tBot - res.grooveDepth) * scaleT,
      12,
      res.grooveDepth * scaleT,
      "rgba(239,68,68,.5)"
    );

    // 標註：上 / 下
    text(
      svg,
      xTop,
      baseYTop + 14,
      `上 r≈${rTop.toFixed(1)}mm\n厚度≈${tTop.toFixed(2)}mm`,
      "#A9BED6",
      "middle"
    );
    text(
      svg,
      xBot,
      baseYTop + 14,
      `下 r≈${rBot.toFixed(1)}mm\n厚度≈${tBot.toFixed(2)}mm`,
      "#A9BED6",
      "middle"
    );
  }
}
  // 瞳高造成的「垂直偏心」也納入厚度 & 鏡坯檢核
  function applyVerticalDec(res){
    const B = Number(res.B) || 0;
    if (!B) return res;

    // 瞳高：自下緣量
    let pupilH = Number(res.pupilH);
    if (!isFinite(pupilH)) {
      pupilH = B / 1.7;
    }
    pupilH = Math.min(Math.max(pupilH, 0), B);   // 0～B 之間

    const decAbs = Math.abs(res.dec || 0);       // 水平偏心 (mm)

    // 從光學中心(瞳孔)到上/下緣的垂直距離：
    //  bottom -> pupil = pupilH
    //  pupil -> top   = B - pupilH
    const vTop = Math.max(0, B - pupilH);
    const vBot = Math.max(0, pupilH);

    // 光學中心到上/下緣的「半徑」
    const rTop    = Math.sqrt(decAbs * decAbs + vTop * vTop);
    const rBottom = Math.sqrt(decAbs * decAbs + vBot * vBot);

    // 左右原本就有的半徑
    const rL = Number(res.rL) || 0;
    const rR = Number(res.rR) || 0;

    // 四個方向的厚度
    const tL     = thicknessAt(res, "L");
    const tR     = thicknessAt(res, "R");
    const tTop   = thicknessAtRadius(res, rTop);
    const tBot   = thicknessAtRadius(res, rBottom);

    // 真正最薄的邊緣厚度：左右 + 上 + 下 一起比
    const estEdgeMin = Math.min(tL, tR, tTop, tBot);

    // 溝尖 / 車溝檢核
    const grooveDepth = Number(res.grooveDepth) || 0;
    const minTip      = Number(res.minTip)      || 1.0;
    const need        = Math.max(1.0, minTip);
    const tipRemain   = estEdgeMin - grooveDepth;
    const halfOK      = tipRemain >= need;
    const halfB   = B / 2;
    const vDecY   = pupilH - halfB; 
    // 鏡坯片徑檢核：也用四個方向的「最大半徑」來算
    const allowance = Number(res.allowance) || 0;
    const blankDia  = Number(res.blankDia)  || 0;  
    const rMax = Math.max(rL, rR, rTop, rBottom);     // 四向最大半徑
    const hReq = rMax + allowance;                   // 需要的半徑
    const minBlank = hReq * 2;                       // 需要的片徑
    const blankOK  = blankDia >= minBlank;
    const blankR = blankDia ? blankDia / 2 : rMax; let maxBlankThick;
    if (res.lensType === "minus") {
      // 近視：最厚在鏡坯外緣
      maxBlankThick = thicknessAtRadius(res, blankR);
    } else {
      // 遠視：最厚在中心 (r=0)
      maxBlankThick = thicknessAtRadius(res, 0);
    }
    // 寫回 res 給 KPI / 顯示用
    res.vDecY         = vDecY;
    res.pupilH        = pupilH;
    res.rTop          = rTop;
    res.rBottom       = rBottom;
    res.tTop          = tTop;
    res.estEdgeMin    = estEdgeMin;
    res.tipRemain     = tipRemain;
    res.halfOK        = halfOK;
    res.need          = need;
    res.rMax          = rMax;
    res.hReq          = hReq;
    res.minBlank      = minBlank;
    res.blankOK       = blankOK;
    res.maxBlankThick = maxBlankThick; 
    return res;
  }

  function thicknessAtRadius(res, r){
    const n    = Number(res.n) || 0;
    const D    = Number(res.D) || 0;
    const absD = Math.abs(D);
    const denom = 2000 * (n - 1) || 1;
    const sag   = radius => (radius * radius * absD) / denom;

    if (res.lensType === 'minus') {
      // 近視：中心薄、邊厚
      return Number(res.centerT) + sag(r);
    } else {
      // 遠視：薄側邊厚 edgeT；鏡坯越大 → 中心越厚，邊緣不會比 edgeT 更薄
      const edgeT  = Number(res.edgeT) || 0;
      const rThin  = Math.max(res.rL, res.rR);
      const blankR = res.blankDia ? res.blankDia / 2 : rThin;
      const rDesign = Math.max(rThin, blankR);

      const center = edgeT + sag(rDesign);
      const rr     = Math.min(r, rDesign);
      return Math.max(0, center - sag(rr));
    }
  }

  function thicknessAt(res, side){
    const r = (side === 'L') ? res.rL : res.rR;
    return thicknessAtRadius(res, r);
  }

  function ellipse(svg, cx, cy, rx, ry, fill, stroke, sw, dash){
    const el = document.createElementNS('http://www.w3.org/2000/svg','ellipse');
    el.setAttribute('cx',cx);
    el.setAttribute('cy',cy);
    el.setAttribute('rx',rx);
    el.setAttribute('ry',ry);
    el.setAttribute('fill',fill);
    el.setAttribute('stroke',stroke);
    el.setAttribute('stroke-width',sw);
    if(dash) el.setAttribute('stroke-dasharray',dash);
    svg.appendChild(el);
  }

let _L3D = null;

function init3D(){
  if (_L3D || !window.THREE) return;
  const wrap = document.getElementById('threeWrap');
  if (!wrap) return;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0a1322);

  const camera = new THREE.PerspectiveCamera(35, wrap.clientWidth / wrap.clientHeight, 0.1, 1000);
  camera.position.set(0, 25, 85);

  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(wrap.clientWidth, wrap.clientHeight);
  wrap.innerHTML = '';
  wrap.appendChild(renderer.domElement);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  // lights
  const key = new THREE.DirectionalLight(0xffffff, 0.9); key.position.set(1,2,3);
  const fil = new THREE.DirectionalLight(0x88ccff, 0.6); fil.position.set(-2,1,0);
  const amb = new THREE.AmbientLight(0x334455, 0.6);
  scene.add(key, fil, amb);

  // subtle grid
  const grid = new THREE.GridHelper(200, 20, 0x1f3045, 0x182435);
  grid.position.y = -0.01; scene.add(grid);

  _L3D = {wrap, scene, camera, renderer, controls,
        mesh:null, ring:null, edge:null, slice:null, rim:null};

  window.addEventListener('resize', ()=>{
    if(!_L3D) return;
    const {wrap, camera, renderer} = _L3D;
    camera.aspect = wrap.clientWidth / wrap.clientHeight; 
    camera.updateProjectionMatrix();
    renderer.setSize(wrap.clientWidth, wrap.clientHeight);
  });

  (function loop(){ if(!_L3D) return; requestAnimationFrame(loop); _L3D.controls.update(); _L3D.renderer.render(_L3D.scene, _L3D.camera); })();
}

    // 厚度模型
  // 依厚度與度數建立「平凸 / 平凹」實心鏡片
function buildLensLatheGeometry(res){
  // ---- 基本參數 ----
  const n     = Number(res.n) || 0;
  const D     = Number(res.D) || 0;
  const absD  = Math.abs(D);
  const denom = 2000 * (n - 1) || 1;        
  const sag   = r => (r * r * absD) / denom;

  const rL    = Number(res.rL)    || 0;           // 左側框半徑
  const rR    = Number(res.rR)    || 0;           // 右側框半徑
  const cutR  = Number(res.cutR)  || ((Number(res.ED) || 0) / 2);
  const blankR= Number(res.blankDia) ? Number(res.blankDia) / 2 : cutR;

  // 鏡片實際邊緣半徑：取鏡坯 / 裁型 / 框中較大者
  const rEdgeReal = Math.max(blankR, cutR, rL, rR);
  if (!isFinite(rEdgeReal) || rEdgeReal <= 0){
    return null;
  }

  // ---- 厚度函式 thicknessAt(r)：mm 單位 ----
  function thicknessAt(r){
    if (res.lensType === 'minus'){
      // 近視：中心薄、邊緣厚
      const centerT = Number(res.centerT) || 0;   // 中央最薄厚度
      return centerT + sag(r);                    // 越外圈越厚
    } else {
      // 遠視：設定「薄側邊緣厚度 edgeT」
      // 鏡坯越大 → 中心要跟著變厚，邊緣不能比 edgeT 更薄
      const edgeT = Number(res.edgeT) || 0;

      const rThin   = Math.max(rL, rR);           // 框中真正「薄側」半徑
      const rDesign = Math.max(rThin, blankR);    // 設計半徑：外圈用到的較大者

      const center  = edgeT + sag(rDesign);       // 讓 rDesign 處厚度剛好 = edgeT
      const rr      = Math.min(r, rDesign);       // 超出去就當 rDesign
      return Math.max(0, center - sag(rr));       // 中央厚、邊緣不小於 edgeT
    }
  }

  // ---- 3D 尺度：把 mm 轉成 three.js 座標 ----
  const sR = 0.6;   // 半徑縮放
  const sT = 0.8;   // 厚度縮放（要跟 update3D 裡 sT 預設一致）

  const profile = [];
  const STEPS   = 64;

  if (res.lensType === 'minus'){
    // 負透鏡：前表平 (y=0)，後表凹到負方向

    // 1) 前表面：從中心 → 邊緣，都是平面 y=0
    for (let i = 0; i <= STEPS; i++){
      const u = i / STEPS;
      const r = rEdgeReal * u;
      const x = r * sR;
      const y = 0;
      profile.push(new THREE.Vector2(x, y));
    }

    // 2) 後表面：從邊緣 → 中心，依 thicknessAt(r) 畫出凹面
    for (let i = STEPS; i >= 0; i--){
      const u = i / STEPS;
      const r = rEdgeReal * u;
      const x = r * sR;
      const t = thicknessAt(r);          // mm
      const y = -t * sT;                 // 往下凹
      profile.push(new THREE.Vector2(x, y));
    }

  } else {
    // 正透鏡：後表平 (y=0)，前表凸到正方向

    // 1) 前表面：從中心 → 邊緣，凸面 y = +thicknessAt(r)
    for (let i = 0; i <= STEPS; i++){
      const u = i / STEPS;
      const r = rEdgeReal * u;
      const x = r * sR;
      const t = thicknessAt(r);          // mm
      const y = t * sT;                  // 往上凸
      profile.push(new THREE.Vector2(x, y));
    }

    // 2) 後表面：從邊緣 → 中心，平面 y=0
    for (let i = STEPS; i >= 0; i--){
      const u = i / STEPS;
      const r = rEdgeReal * u;
      const x = r * sR;
      const y = 0;
      profile.push(new THREE.Vector2(x, y));
    }
  }

  // ---- 生成 Lathe 幾何 ----
  const geom = new THREE.LatheGeometry(profile, 96);
  geom.computeVertexNormals();

  // 給 update3D 用的參考資訊
  geom.userData.rEdgeReal = rEdgeReal;
  geom.userData.sR        = sR;
  geom.userData.sT        = sT;
  geom.userData.rScale    = sR;
  geom.userData.tScale    = sT;

  return geom;
}

function update3D(res){
  if (!window.THREE) return;
  init3D();
  if (!_L3D) return;

  const scene = _L3D.scene;

  // ---------- 先清掉舊物件 ----------
  ["mesh","edge","rim","ring","slice"].forEach(key => {
    const obj = _L3D[key];
    if (!obj){ _L3D[key] = null; return; }

    if (Array.isArray(obj)){
      obj.forEach(o => {
        if (!o) return;
        scene.remove(o);
        if (o.geometry) o.geometry.dispose();
        if (o.material) o.material.dispose();
      });
    }else{
      scene.remove(obj);
      if (obj.geometry) obj.geometry.dispose();
      if (obj.material) obj.material.dispose();
    }
    _L3D[key] = null;
  });

  // ---------- 建立鏡片幾何 ----------
  const g = buildLensLatheGeometry(res);
  if (!g) return;

  const rEdgeReal =
    g.userData.rEdgeReal ||
    (Number(res.blankDia) ? Number(res.blankDia)/2
                          : Math.max(
                              Number(res.rL) || 0,
                              Number(res.rR) || 0,
                              Number(res.cutR) || 0,
                              (Number(res.ED) || 0)/2
                            ));

  const sR = g.userData.sR || g.userData.rScale || 0.6;
  const sT = g.userData.sT || g.userData.tScale || 0.8;

  // 厚度函式（跟 2D/3D 共用邏輯）
  const nVal   = Number(res.n) || 0;
  const DVal   = Number(res.D) || 0;
  const absD   = Math.abs(DVal);
  const denom  = 2000 * (nVal - 1) || 1;
  const sag    = r => (r * r * absD) / denom;

  function thicknessAt(r){
    if (res.lensType === "minus"){
      const centerT = Number(res.centerT) || 0;
      return centerT + sag(r);                // 近視：中心薄、邊厚
    }else{
      const edgeT   = Number(res.edgeT) || 0; // 遠視：薄側邊厚
      const rL      = Number(res.rL) || 0;
      const rR      = Number(res.rR) || 0;
      const rThin   = Math.max(rL, rR);
      const blankR  = Number(res.blankDia) ? Number(res.blankDia)/2 : rThin;
      const rDesign = Math.max(rThin, blankR);

      const center = edgeT + sag(rDesign);
      const rr     = Math.min(r, rDesign);
      return Math.max(0, center - sag(rr));
    }
  }

  // ---------- 1. 鏡片本體 ----------
  const lensMat = new THREE.MeshPhysicalMaterial({
    color: 0xaad9ff,
    roughness: 0.30,
    metalness: 0.0,
    transmission: 0.25,
    transparent: true,
    opacity: 0.2,
    side: THREE.DoubleSide
  });

  const mesh = new THREE.Mesh(g, lensMat);
  mesh.position.y = 6;
  mesh.renderOrder = 0;
  scene.add(mesh);
  _L3D.mesh = mesh;

  const edgeGeo = new THREE.EdgesGeometry(g);
  const edgeMat = new THREE.LineBasicMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.08
  });
  const edgeLines = new THREE.LineSegments(edgeGeo, edgeMat);
  edgeLines.position.copy(mesh.position);
  edgeLines.renderOrder = 0;
  scene.add(edgeLines);
  _L3D.edge = edgeLines;

  // ---------- 2. 側邊圓柱牆（讓鏡片像「實心」） ----------
  if (rEdgeReal > 0){
    let hVis = 0;
    let centerYOffset = 0;

    if (res.lensType === "minus"){
      g.computeBoundingBox();
      const bb = g.boundingBox;
      if (bb){
        hVis = bb.max.y - bb.min.y;
        centerYOffset = (bb.max.y + bb.min.y) / 2;
      }
    }else{
      const tEdge = thicknessAt(rEdgeReal);
      const tVis  = tEdge * sT;
      hVis = tVis;
      centerYOffset = tVis / 2;
    }

    if (hVis > 0.0001){
      const rWorld = rEdgeReal * sR * 1.002;
      const rimGeo = new THREE.CylinderGeometry(
        rWorld, rWorld, hVis, 64, 1, true
      );
      const rimMat = new THREE.MeshBasicMaterial({
        color: 0xaad9ff,
        transparent: true,
        opacity: 0.22,
        side: THREE.DoubleSide,
        depthTest: true,
        depthWrite: true
      });
      const rim = new THREE.Mesh(rimGeo, rimMat);
      rim.position.y = mesh.position.y + centerYOffset;
      rim.renderOrder = 0;
      scene.add(rim);
      _L3D.rim = rim;
    }
  }

  // ---------- 3. 偏心（水平 dec + 瞳高造成的垂直 dec） ----------
  const B = Number(res.B) || 0;
  let pupilH = Number(res.pupilH);
  if (!isFinite(pupilH)) {
    pupilH = B ? B / 1.7 : 0;
  }
  const halfB   = B / 2;
  const vDecReal = B ? (pupilH - halfB) : 0;          // 垂直偏心 mm
  const hDecReal = Number(res.dec) || 0;              // 水平偏心 mm

  const cutRReal = Number(res.cutR) || (Number(res.ED) || 0) / 2;
  const offsetDist = Math.sqrt(hDecReal*hDecReal + vDecReal*vDecReal);

  const ringInside =
    cutRReal > 0 && (offsetDist + cutRReal <= rEdgeReal + 1e-6);

  // ---------- 4. 裁型圈（高亮） ----------
  if (cutRReal > 0){
    const ringRadius = cutRReal * sR;
    const ringGeo = new THREE.TorusGeometry(ringRadius, 0.6, 16, 160);
    const ringMat = new THREE.MeshBasicMaterial({
      color: 0x22c55e,
      transparent: true,
      opacity: 0.2,
      depthTest: false,
      depthWrite: false
    });
    const ring = new THREE.Mesh(ringGeo, ringMat);
    ring.rotation.x = Math.PI / 2;
    ring.position.y = mesh.position.y;
    ring.position.x = hDecReal * sR;  // 水平偏心
    ring.position.z = vDecReal * sR;  // 垂直偏心
    ring.renderOrder = 9;
    scene.add(ring);
    _L3D.ring = ring;
  }

  // ---------- 5. 十字子午線「窗簾」厚度切面 ----------
  function buildCurtain(sMinReal, sMaxReal, mode){
    if (!isFinite(sMinReal) || !isFinite(sMaxReal) || sMaxReal <= sMinReal) {
      return null;
    }

    const NX = 64;
    const top = [];
    const bottom = [];

    for (let i=0; i<=NX; i++){
      const tt = i / NX;
      const sReal = sMinReal + (sMaxReal - sMinReal) * tt;

      let xReal, zReal;
      if (mode === "x"){
        // 水平窗簾：沿 x 方向
        xReal = hDecReal + sReal;
        zReal = vDecReal;
      }else{
        // 垂直窗簾：沿 z 方向
        xReal = hDecReal;
        zReal = vDecReal + sReal;
      }

      const rReal = Math.sqrt(xReal*xReal + zReal*zReal);
      const thick = thicknessAt(rReal);
      const tVis  = thick * sT;

      let yTopLocal, yBotLocal;
      if (res.lensType === "minus"){
        yTopLocal = 0;
        yBotLocal = -tVis;
      }else{
        yBotLocal = 0;
        yTopLocal = tVis;
      }

      const xWorld = xReal * sR;
      const zWorld = zReal * sR;
      top.push(   new THREE.Vector3(xWorld, yTopLocal,  zWorld));
      bottom.push(new THREE.Vector3(xWorld, yBotLocal, zWorld));
    }

    const verts = [];
    for (let i=0; i<NX; i++){
      const t1 = top[i],   t2 = top[i+1];
      const b1 = bottom[i],b2 = bottom[i+1];

      verts.push(
        t1.x,t1.y,t1.z,
        b1.x,b1.y,b1.z,
        t2.x,t2.y,t2.z
      );
      verts.push(
        b1.x,b1.y,b1.z,
        b2.x,b2.y,b2.z,
        t2.x,t2.y,t2.z
      );
    }

    const sliceGeo = new THREE.BufferGeometry();
    sliceGeo.setAttribute(
      "position",
      new THREE.Float32BufferAttribute(verts,3)
    );
    sliceGeo.computeVertexNormals();

    // 顏色：水平 = 綠，垂直 = 淡黃色；超出鏡坯則為紅色
    const okColor = (mode === "x" ? 0x22c55e : 0xE0FC53);
    const color   = ringInside ? okColor : 0xef4444;

    const sliceMat = new THREE.MeshBasicMaterial({
      color,
      transparent: true,
      opacity: 0.4,
      side: THREE.DoubleSide,
      depthTest: false,
      depthWrite: false
    });

    const slice = new THREE.Mesh(sliceGeo, sliceMat);
    slice.position.y = mesh.position.y;
    slice.renderOrder = 10;
    scene.add(slice);
    return slice;
  }

  const slices = [];

  if (cutRReal > 0){
    const rEdge2 = rEdgeReal * rEdgeReal;

    // --- 水平窗簾（沿 x 軸）---
    const z0 = vDecReal;
    if (z0*z0 <= rEdge2){
      const lensHalfX = Math.sqrt(rEdge2 - z0*z0);
      const x0 = hDecReal;
      const xMinLens = -lensHalfX;
      const xMaxLens =  lensHalfX;
      const xMinCut  = x0 - cutRReal;
      const xMaxCut  = x0 + cutRReal;

      const xMin = Math.max(xMinLens, xMinCut);
      const xMax = Math.min(xMaxLens, xMaxCut);

      if (xMax > xMin){
        const sMinX = xMin - x0;
        const sMaxX = xMax - x0;
        const sliceX = buildCurtain(sMinX, sMaxX, "x");
        if (sliceX) slices.push(sliceX);
      }
    }

    // --- 垂直窗簾（沿 z 軸）---
    const x0 = hDecReal;
    if (x0*x0 <= rEdge2){
      const lensHalfZ = Math.sqrt(rEdge2 - x0*x0);
      const z0v       = vDecReal;
      const zMinLens  = -lensHalfZ;
      const zMaxLens  =  lensHalfZ;
      const zMinCut   = z0v - cutRReal;
      const zMaxCut   = z0v + cutRReal;

      const zMin = Math.max(zMinLens, zMinCut);
      const zMax = Math.min(zMaxLens, zMaxCut);

      if (zMax > zMin){
        const sMinZ = zMin - z0v;
        const sMaxZ = zMax - z0v;
        const sliceZ = buildCurtain(sMinZ, sMaxZ, "z");
        if (sliceZ) slices.push(sliceZ);
      }
    }
  }

  _L3D.slice = slices;
}

  // 繪圖小工具
  function circle(svg,cx,cy,r,fill,stroke,sw, dash){
    const el=document.createElementNS('http://www.w3.org/2000/svg','circle');
    el.setAttribute('cx',cx);el.setAttribute('cy',cy);el.setAttribute('r',r);
    el.setAttribute('fill',fill);el.setAttribute('stroke',stroke);el.setAttribute('stroke-width',sw);
    if(dash) el.setAttribute('stroke-dasharray',dash);
    svg.appendChild(el);
  }
  function line(svg,x1,y1,x2,y2,stroke,sw){
    const el=document.createElementNS('http://www.w3.org/2000/svg','line');
    el.setAttribute('x1',x1);el.setAttribute('y1',y1);el.setAttribute('x2',x2);el.setAttribute('y2',y2);
    el.setAttribute('stroke',stroke);el.setAttribute('stroke-width',sw);svg.appendChild(el);
  }
  function rect(svg,x,y,w,h,fill){
    const el=document.createElementNS('http://www.w3.org/2000/svg','rect');
    el.setAttribute('x',x);el.setAttribute('y',y);el.setAttribute('width',w);el.setAttribute('height',h);el.setAttribute('fill',fill);svg.appendChild(el);
  }
  function text(svg, x, y, str, fill, anchor, lineHeight = 14) {
    const el = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    el.setAttribute('x', x);
    el.setAttribute('y', y);
    el.setAttribute('fill', fill || '#111');
    if (anchor) el.setAttribute('text-anchor', anchor);
    el.style.fontSize = '12px';

    const parts = String(str).split(/\n|\(換行\)/g);
    parts.forEach((ln, i) => {
      const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
      tspan.setAttribute('x', x);
      tspan.setAttribute('dy', i === 0 ? '0' : String(lineHeight));
      tspan.textContent = ln;
      el.appendChild(tspan);
    });
    svg.appendChild(el);
  }

  function update(){
    const res = calc();
    applyVerticalDec(res);
    const thickDanger =
    (res.lensType === "minus") && (res.maxBlankThick > 12);    const thickText   = res.maxBlankThick.toFixed(2) + " mm";
    const vDec = res.vDecY || 0;
    const vDecText = (vDec > 0 ? "+" : (vDec < 0 ? "−" : "")) + Math.abs(vDec).toFixed(1) + " mm";
    // 顯示度數（+/-）
    $("d_display").textContent =
      "目前：" + ((res.D > 0 ? "+" : "") + (res.D || 0).toFixed(2) + " D");
    // ===== 1：裁型 / 鏡坯 & 厚度檢核 =====
    $("k_framePD").textContent  = res.framePD.toFixed(1) + " mm";
    $("k_dec").textContent      = res.dec.toFixed(2)     + " mm";
    $("k_cutDia").innerHTML =
      thickDanger
        ? `${thickText} <span class="tag-warn">⚠️ 易出現光圈平台</span>`
        : thickText;
    $("k_reqR").textContent = vDecText;
    $("k_minBlank").textContent = res.minBlank.toFixed(1)  + " mm"; 
    $("k_minBlank").className   = "v" + (res.blankOK ? "" : " danger");
    $("k_blankOK").textContent  = res.blankOK ? "✅ 足夠" : "❌ 不足";
    // ===== 2：厚度 & 溝尖/車溝檢核（近似） =====
    $("k_delta").textContent  = res.delta.toFixed(2)     + " mm"; 
    $("k_center").textContent = res.estCenter.toFixed(2) + " mm"; 
    $("k_edge").textContent   = res.estEdgeMin.toFixed(2)+ " mm"; 
    // 溝尖剩餘厚度（薄側）
    $("k_tip").textContent = res.tipRemain.toFixed(2) + " mm";    // = estEdgeMin - grooveDepth

    $("k_halfSafety").textContent =
      res.tipRemain >= res.need
        ? `✅ ≥ ${res.need} mm`
        : `⚠️ < ${res.need} mm`;
    const rimType = $("rimType").value;
    const rimOK =
      rimType === "groove"
        ? res.halfOK                             // ★ 已含上下偏心
        : (res.estEdgeMin - res.grooveDepth >= res.minTip);
    $("k_result").textContent =
      rimOK ? "✅ 可行 (近似)" : "❌ 風險：厚度可能不足";
    drawTop(res);
    drawSection(res);
    update3D(res);
  }

  update();init3D();
})();
</script>
</body>
</html>



