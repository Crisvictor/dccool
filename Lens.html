<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link rel="icon" href="img/optometry.png" type="image/x-icon">
<link rel="shortcut icon" href="img/optometry.png" type="image/x-icon">
<script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<title>鏡片厚度模擬器</title>
<style>
  :root{
    --bg:#0b1220;          /* 背景 */
    --ink:#e5e7eb;         /* 主要文字 */
    --muted:#94a3b8;       /* 次要文字 */
    --card:#0f172a;        /* 卡片底色 */
    --border:#1e293b;      /* 邊框色 */
    --pri:#38bdf8;         /* 重點/焦點色 */
    --ok:rgba(34, 197, 94, .4);
    --ng:rgba(248, 113, 113, .4);
  }
  html,body{height:100%}
  body{
    margin:0;
    font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans TC",Arial;
    background:radial-gradient(1200px 800px at 20% -10%,#0e1728 0%,#0b1220 55%),
               radial-gradient(800px 800px at 90% 10%,#0a1a2f 0%,transparent 60%),
               var(--bg);
    color:var(--ink);
  }
  .wrap{max-width:1200px;margin:24px auto;padding:0 16px}
  h1{font-size:22px;margin:0 0 12px;color:#f1f5f9}
  .grid{display:grid;gap:10px}
  .g-3{grid-template-columns:repeat(3,minmax(0,1fr))}
  .card{
    background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,.02));
    border:1px solid var(--border);
    border-radius:16px;
    box-shadow:0 10px 35px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.03);
    backdrop-filter:saturate(110%) blur(2px);
  }
  .card>.hd{
    padding:12px 16px;
    border-bottom:1px solid var(--border);
    font-weight:580;
    color:#cbd5e1;
  }
  .card>.bd{padding:8px 16px}
  .row{display:grid;grid-template-columns:1fr 160px;align-items:center;gap:8px;margin:8px 0}
  .row label{color:var(--muted);font-size:12px}
  input,select{
    width:100%;max-width:100%;box-sizing:border-box;
    padding:8px 10px;
    border:1px solid #334155;
    background:#0b1628;
    color:var(--ink);
    border-radius:10px;font-size:14px;outline:none;
    transition:border-color .15s, box-shadow .15s, background .15s;
  }
  input::placeholder{color:#71839a}
  select option{background:#0b1628;color:var(--ink)}
    input:focus,select:focus{
    border-color:#60a5fa;
    box-shadow:0 0 0 2px rgba(56,189,248,.25);
    background:#0c1a31;
  }
  .thick-vert{
    margin-top:4px;
    font-size:11px;
    color:var(--muted);
    line-height:1.4;
  }
  .kpis{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:6px;margin-bottom:4px;}
  .kpi{
    border:1px solid var(--border);
    border-radius:8px;
    background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.02));
    padding:5px
  }
  .kpi .t{font-size:11px;color:var(--muted)}
  .kpi .v{font-weight:700;margin-top:2px;color:#e2e8f0}
  .tag-warn{
    display:inline-block;
    margin-left:4px;
    padding:1px 4px;
    border-radius:4px;
    font-size:10px;
    color:#b91c1c;
    background:#fee2e2;
  }
  .canvas{
    aspect-ratio:1/1;border-radius:16px;
    border:1px solid var(--border);
    background:radial-gradient(500px 400px at 60% 40%,rgba(148,163,184,.08),transparent 60%),
               #0b1324;
    display:flex;align-items:center;justify-content:center
  }
  .kpi-double{
    display:flex;
    flex-direction:column;
    gap:11px;
  }
  .kpi-subcard{
    padding-top:8px;
    border-top:1px solid var(--border);
  }
  .kpi-subcard:first-child{
    border-top:none;
  }
  .kpi-subtitle{
    font-size:12px;
    color:var(--muted);
    font-weight:600;
    margin-bottom:6px;
  }
  .note{font-size:12px;color:var(--muted)}
  .danger{color:var(--ng);font-weight:700}
  @media (max-width:980px){.g-3{grid-template-columns:1fr}}
  hr{border:0;border-top:1px dashed var(--border);margin:10px 0}
</style>
</head>
<body>
  <div class="wrap">
    <h1>鏡片厚度模擬器</h1>
    <p class="note">用途：在訂製前，輸入度數/折射率與框參數，估算裁型後邊緣厚度是否足夠做出溝尖與車溝，並檢查鏡坯片徑是否足夠。<br>聲明：本教學工具為厚度幾何近似值，前表面彎度設定與折射面設計（如非球面與多焦）仍會產生誤差，實務仍需以加工經驗為準。</p>

    <div class="grid g-3">
      <div class="card">
        <div class="hd">參數輸入 [訂製鏡片]</div>
        <div class="bd">
          <div class="row"><label>鏡片類型</label><select id="lensType"><option value="minus">近視</option><option value="plus">遠視</option></select></div>
          <div class="row"><label>球鏡 S (±)</label><input id="D" type="number" step="0.25" value="-6" min="-20" max="15"></div>
          <div class="row"><label>散光 C</label><input id="Cyl" type="number" step="0.25" value="0" min="-10" max="0"></div>
          <div class="row"><label>軸度 A</label><input id="Axis" type="number" step="1" value="0" min="0" max="180"></div>
          <div class="row"><label>折射率 n</label>
            <select id="n">
              <option value="1.50">1.50</option>
              <option value="1.56">1.56</option>
              <option value="1.61">1.61</option>
              <option value="1.67" selected>1.67</option>
              <option value="1.74">1.74</option>
            </select>
          </div>
          <div class="row" data-for="plusBC"><label>前彎 (D)</label><input id="BC" type="number" step="0.25" value="1" min="0" max="15"></div>
          <div class="note" id="bc_display"></div>
          <div class="row" data-for="minus"><label>指定中心厚 (mm)</label><input id="centerT" type="number" step="0.1" value="1.2" min="1.0" max="5.0"></div>
          <div class="row" data-for="plus" style="display:none"><label>設定邊緣厚 (mm)</label><input id="edgeT" type="number" step="0.1" value="2.0" min="0.2" max="3.0"></div>
          <div class="row"><label>鏡坯片徑 (mm)</label><input id="blankDia" type="number" step="1" value="65" min="50" max="80"></div>
          <div class="note" id="fieldHelp">提示：點擊欄位標題可以查看說明。</div>
        </div>
      </div>

      <div class="card">
        <div class="hd">平面視圖（鏡坯 / 裁型 ）</div>
        <div class="bd">
          <div class="canvas"><svg id="topView" width="340" height="340"></svg></div>
          <p class="note">圖示：外圈＝鏡坯片徑；內圈＝裁型直徑（ED）；<br>綠/紅環＝邊緣厚達標/不足；鏡坯不足→外圈紅色。</p>
        </div>
      </div>

      <div class="card">
        <div class="hd">裁型邊緣厚度（含偏心影響）</div>
        <div class="bd">
          <div class="canvas"><svg id="sectionView" width="340" height="340"></svg></div>
          <p class="note">橫切面鏡片裁型偏心而產生不同邊緣厚度，<br>評估最薄側是否可開車溝。</p>
        </div>
      </div>
    </div>

    <div class="grid g-3" style="margin-top:16px">
      <div class="card">
        <div class="hd">參數輸入 [框參數] </div>
        <div class="bd">
          <div class="row"><label>有效直徑 ED (mm)</label><input id="ED" type="number" step="0.5" value="53" min="20" max="80"></div>
          <div class="row"><label>框寬 A (mm)</label><input id="A" type="number" step="0.5" value="52" min="20" max="80"></div>
          <div class="row"><label>框高 B (mm)</label><input id="B" type="number" step="0.5" value="40" min="15" max="80"></div>
          <div class="row"><label>中樑距 DBL (mm)</label><input id="DBL" type="number" step="0.5" value="18" min="10" max="40"></div>
          <div class="row"><label>瞳距 PD (mm)</label><input id="PD" type="number" step="0.5" value="62" min="40" max="80"></div>
          <div class="row"><label>瞳高 PH (mm)</label><input id="pupilH" type="number" step="0.5" value=""></div>
          <div class="note">若留空則預設為 B/1.7，視為瞳高約於框2/3高。</div>
          <div class="row"><label>預留加工 (mm)</label><input id="allowance" type="number" step="0.5" value="2" min="0" max="4"></div>
          <div class="row"><label id="grooveLabel">框溝寬 (mm)</label><input id="grooveDepth" type="number" step="0.1" value="1.0" min="0.5" max="2"></div>
          <div class="row"><label>最小剩餘厚度需求 (mm)</label><input id="minTip" type="number" step="0.1" value="0" min="0" max="2"></div>
          <div class="row"><label>框類</label><select id="rimType"><option value="full">全框</option><option value="groove">車溝框</option><option value="rimless">無邊框</option></select></div>
        </div>
      </div>

      <div class="card">
        <div class="hd">3D 厚度視覺（概念示意）</div>
        <div class="bd">
          <div id="threeWrap" style="width:100%;height:340px;border-radius:12px;border:1px solid var(--border);background:#0a1322;overflow:hidden"></div>
          <p class="note">此 3D 為旋轉對稱概念示意：依厚度函式產生鏡片（圓形）。<br>裁型厚度分布： 水平=綠，垂直=黃；超出鏡坯則為紅</p>
        </div>
      </div>
     
      <div class="card">
        <div class="hd">裁型 / 鏡坯 & 厚度檢核</div>
        <div class="bd kpi-double">

          <!-- 上半：裁型 & 鏡坯評估 -->
          <div class="kpi-subcard">
            <div class="kpi-subtitle">裁型 & 鏡坯評估</div>
            <div class="kpis">
              <div class="kpi">
                <div class="t">框心距 (A+DBL)</div>
                <div id="k_framePD" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">水平偏心</div>
                <div id="k_dec" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">鏡坯最厚厚度</div>
                <div id="k_cutDia" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">垂直偏心</div>
                <div id="k_reqR" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">鏡坯最小建議片徑</div>
                <div id="k_minBlank" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">鏡坯是否足夠</div>
                <div id="k_blankOK" class="v"></div>
              </div>
            </div>
          </div>

          <!-- 下半：厚度 & 溝尖/車溝檢核/SM放大倍率（近似） -->
          <div class="kpi-subcard">
            <div class="kpi-subtitle">厚度 & 溝尖/車溝檢核（近似）</div>
            <div class="kpis">
              <div class="kpi">
                <div class="t">中心/邊緣厚度差值△</div>
                <div id="k_delta" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">中心厚估</div>
                <div id="k_center" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">車溝/溝尖安全線</div>
                <div id="k_halfSafety" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">結果</div>
                <div id="k_result" class="v"></div>
              </div>
            </div>
          </div> 
          <div class="kpi-subcard">
            <div class="kpi-subtitle">SM放大倍率（近似）VD:12mm</div>
            <div class="kpis">
              <div class="kpi">
                <div class="t">像倍率</div>
                <div id="k_SM" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">像倍率變化</div>
                <div id="k_SMpct" class="v"></div>
              </div> 
            </div> 
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(function(){
  const $ = (id)=>document.getElementById(id);
  function updateGrooveLabel(rimType){
    const lbl = $("grooveLabel");
    if (!lbl) return;
    if (rimType === "groove") {
      lbl.textContent = "車溝寬 (mm)";
    } else if (rimType === "rimless") {
      lbl.textContent = "邊緣寬度 (mm)";
    } else {
      lbl.textContent = "框溝寬 (mm)";
    }
  }
  function syncRimDefaults(){
    const rim = $("rimType")?.value;
    const grooveInput = $("grooveDepth");
    const minTipInput = $("minTip");
    if (!rim || !grooveInput || !minTipInput) return;

    if (rim === "groove") {
      grooveInput.value = "0.5";
      minTipInput.value = "1.5";
    } else if (rim === "rimless") {
      // 無邊框：只看邊緣厚度，不檢核「最小剩餘厚度需求」
      grooveInput.value = "0.5";
      minTipInput.value = "0";
    } else {
      grooveInput.value = "1.0";
      minTipInput.value = "0";
    }
  }
  function toggleRimUI(){
    const rim = $("rimType")?.value;
    const minTipRow = $("minTip")?.closest(".row");
    if (minTipRow){
      minTipRow.style.display = (rim === "rimless") ? "none" : "";
    }
  }

  const ids = [
    "lensType","D","Cyl","Axis","n","centerT","edgeT","BC","blankDia",
    "ED","A","B","DBL","PD","allowance","grooveDepth","minTip","rimType","pupilH"
  ];
  ids.forEach(id=>$(id).addEventListener('input', update));
  $("lensType").addEventListener('change', ()=>{
    const t = $("lensType").value;
  document.querySelector('[data-for="minus"]').style.display = (t==='minus')?'' : 'none';
  document.querySelector('[data-for="plus"]').style.display  = (t==='plus') ?'' : 'none';
  const bcRow = document.querySelector('[data-for="plusBC"]');
  if (bcRow) bcRow.style.display = '';
  const dInput = $("D");
  let v = parseFloat(dInput.value);
  if (!isNaN(v)) {
    const mag = Math.abs(v);
    dInput.value = (t === 'minus' ? -mag : mag);
  }
  update();
});
  $("rimType").addEventListener('change', ()=>{
    syncRimDefaults();
    updateGrooveLabel($("rimType").value);
    toggleRimUI();
    update();
  });
  updateGrooveLabel($("rimType").value);
  toggleRimUI();
  function clamp(v,min,max){ v=parseFloat(v); if(isNaN(v)) return min; return Math.min(Math.max(v,min),max); }
  function calc(){
    const lensType = $("lensType").value; // minus/plus
    const D  = parseFloat($("D").value);
    const CylRaw = parseFloat($("Cyl").value);
    const Cyl = isNaN(CylRaw) ? 0 : Math.min(0, CylRaw);
    const axisRaw = parseFloat($("Axis").value);
    let Axis = isNaN(axisRaw) ? 0 : axisRaw;
    Axis = ((Axis % 180) + 180) % 180;
    const n  = parseFloat($("n").value);
    const centerT = clamp($("centerT").value,1.0,3.0);
    const edgeT   = clamp($("edgeT").value,0.2,3.0);
    const blankDia= clamp($("blankDia").value,50,80);
    const BCraw   = parseFloat($("BC")?.value ?? "");
    let bcWarn = ""; 
    // 遠視：自動給一個合理的前弧
    function autoBCForPlus(Dval){
      const a = Math.abs(Dval || 0);
      if (a <= 2) return 6;
      if (a <= 4) return 7;
      if (a <= 6) return 8;
      if (a <= 8) return 9;
      return 10;        
    }
    // 近視：你說的「初始 BC +1.00D」
    function autoBCForMinus(Dval){
      return 1; // 1.00D ≈ 100 彎，當成預設前表彎度
    }
    let BC;
    if (lensType === "plus"){
      // 遠視：BC 不能亂填，負值或 0 就自動帶
      BC = isNaN(BCraw) ? autoBCForPlus(D) : BCraw;
      if (!isFinite(BC) || BC <= 0) BC = autoBCForPlus(D); 
      // 遠視：BC 必須 ≥ 球鏡度數 D，且不超過 15D 
      const absD = Math.abs(D || 0);
      const minBC = absD;  // BC 最低限制 = 球鏡度數
      const maxBC = 15;    // BC 最高限制 = 15D
      if (BC < minBC){
        bcWarn = `遠視前彎必須 ≥ ${absD.toFixed(2)}D（球鏡度數），已自動調整。`;
        BC = minBC;
      }
      if (BC > maxBC){
        bcWarn = `遠視前彎不能超過 15.00D，已自動限制。`;
        BC = maxBC;
      }
    }else{
      // 近視：允許調 BC，但至少要 >= 0，並依度數限制上限避免厚度過誇張
      BC = isNaN(BCraw) ? autoBCForMinus(D) : BCraw;
      if (!isFinite(BC)){
        BC = autoBCForMinus(D);
      }
      if (BC < 0){
        BC = 0;
        bcWarn = "近視前彎不可為負值，已調整為 0D。";
      }
      const absD = Math.abs(D || 0);
      // 近視 BC 全域最高 8D
      let maxBC = 8;
      // 高於 -4D：BC ≤ 6D
      if (absD > 4)  maxBC = 6;
      // 高於 -5D：BC ≤ 5D
      if (absD > 4.75)  maxBC = 5;
      // 高於 -6D：BC ≤ 4D
      if (absD > 5.75)  maxBC = 4;
      // 高於 -8D：BC ≤ 2D
      if (absD > 7.75)  maxBC = 2;
      // 高於 -10D：BC ≤ 1D
      if (absD > 9.75) maxBC = 1;
      // 高於 -12D：BC ≤ 0D（不建議前彎）
      if (absD > 11.75) maxBC = 0;

      if (BC > maxBC){
        if (maxBC === 0){
          bcWarn = "近視度數高於 -12.00D，為避免厚度過重，前彎已鎖定為 0D（平前表）。";
        }else if (absD > 9.75){
          bcWarn = `近視度數高於 -10.00D，建議前彎  ≤ ${maxBC.toFixed(1)}D，已自動限制。`;
        }else if (absD > 7.75){
          bcWarn = `近視度數高於 -8.00D，建議前彎  ≤ ${maxBC.toFixed(1)}D，已自動限制。`;
        }else if (absD > 5.75){
          bcWarn = `近視度數高於 -6.00D，建議前彎  ≤ ${maxBC.toFixed(1)}D，已自動限制。`;
        }else if (absD > 4.75){
          bcWarn = `近視度數高於 -5.00D，建議前彎  ≤ ${maxBC.toFixed(1)}D，已自動限制。`;
        }else if (absD > 4){
          bcWarn = `近視度數高於 -4.00D，建議前彎  ≤ ${maxBC.toFixed(1)}D，已自動限制。`;
        }else{
          bcWarn = "近視前彎不建議超過 8.00D，已自動限制。";
        }
        BC = maxBC;
      }
    }
    // 依 BC 換算前後表折射力（以柱軸方向為基準）
    const frontPower     = BC;                   
    const backAxisPower  = (D || 0) - frontPower; 
    const backPerpPower  = backAxisPower + (Cyl || 0);
    const ED = clamp($("ED").value,20,80);
    const A  = clamp($("A").value,20,80);
    const B  = clamp($("B").value,20,80);
    const DBL= clamp($("DBL").value,10,40);
    const PD = clamp($("PD").value,40,80);
    const allowance = clamp($("allowance").value,0,4);
    let pupilH = $("pupilH").value;
        pupilH = pupilH === "" ? (B / 1.7) : clamp(pupilH, 0, B);
    // 邊緣幾何：共用一個輸入做「寬度」，依框型解讀不同
    const spanVal = clamp($("grooveDepth").value, 0.5, 2); // UI: 框溝寬 / 車溝寬 (mm)
    let minTip      = clamp($("minTip").value,0,3);
    const rimType = $("rimType").value; // "full" / "groove" / "rimless" / "rimless"
    if (rimType === "rimless") minTip = 0;
    // 深度（X 方向）：固定值
    const tipHeight   = 0.5; // 全框溝尖高：0.5 mm
    const grooveDepth = 0.6; // 車溝深度：0.6 mm
     // 寬度（Y 方向）：由 spanVal 控制
    let tipWidth, grooveWidth;
    if (rimType === "full") {
      // 全框：使用者調整「尖寬」（Y）
      tipWidth    = spanVal;
      grooveWidth = grooveDepth;   // 只給預設，實務較少用
    } else {
      // 車溝框：使用者調整「溝寬」（Y）
      grooveWidth = spanVal;
      tipWidth    = tipHeight;     // 只給預設，實務較少用
    }
    const tipSpan    = tipWidth;
    const grooveSpan = grooveWidth;
    const framePD = A + DBL;
    const dec = Math.abs(framePD - PD)/2; // 單眼偏心
    const decAbs = Math.abs(dec || 0); 
    // 全框模式邊緣縮減量：視為溝尖高 ≈ 0.5mm，車溝則不縮
    const shrink = (rimType === "full") ? tipHeight : 0;
    // 水平方向：以框寬 A/2 為基準，往內縮一圈 shrink
    const halfA = A / 2;
    const rL = Math.max(0, halfA - dec - shrink); // 左邊有效到溝尖內緣距離
    const rR = Math.max(0, halfA + dec - shrink); // 右邊有效到溝尖內緣距離
    // 斜邊 ED：用來算最大半徑與鏡坯需求，同樣往內縮 shrink
    const cutR = Math.max(0, ED/2 - shrink);  // 有效裁型「等效圓半徑」
    const rMax = cutR + dec;                  // 最遠那一點（對角線 + 偏心）
    // 鏡坯需求半徑、片徑（沿用原本概念）
    const hReq = rMax + allowance;
    const minBlank = 2 * hReq;
    const blankOK  = (blankDia/2) >= hReq;
    let res = {
      lensType,D,Cyl,Axis,n,centerT,edgeT,blankDia,BC,
      frontPower, backAxisPower, backPerpPower, bcWarn,
      ED,A,B,DBL,PD,allowance,
      grooveDepth,grooveWidth,minTip,rimType,pupilH,
      tipHeight,tipWidth,tipSpan,grooveSpan,
      framePD,dec,cutR,rL,rR,rMax
    };
    // 水平薄側半徑 rThin：用來計算 Δ
    const rThin = Math.max(rL, rR);
    // 中心厚（沿水平經線）
    const estCenter = thicknessAtRadius(res, 0, "horizontal");
    res.estCenter   = estCenter;
    const tRef      = thicknessAtRadius(res, rThin, "horizontal");
    // 車溝框安全（建議 ≥1.0 或使用者設定）
    return {
      lensType,D,Cyl,Axis,n,centerT,edgeT,blankDia,BC,
      frontPower, backAxisPower, backPerpPower, bcWarn,
      ED,A,B,DBL,PD,allowance,
      grooveDepth,grooveWidth,minTip,rimType,pupilH,
      tipHeight,tipWidth,tipSpan,grooveSpan,
      framePD,dec,cutR,hReq,blankOK,estCenter,
      minBlank,rL,rR,rMax
    };
  }
  // 以水平 0°、逆時針為正，計算該經線方向的總度數 F(θ)
  function meridionalPower(res, thetaDeg){
    const S = Number(res.D)   || 0;
    const C = Number(res.Cyl) || 0;
    const axis = Number(res.Axis) || 0;
    const rad = (thetaDeg - axis) * Math.PI / 180;
    const s   = Math.sin(rad);
    const sin2 = s * s;
    return S + C * sin2;
  }
  // 將「方向文字」映射成角度
  function thetaForMeridian(tag){
    switch(tag){
      case "horizontal":
      case "L":
      case "R":
        return 0;    // 水平經線
      case "vertical":
      case "Top":
      case "Bottom":
        return 90;   // 垂直經線
      default:
        return 0;
    }
  }
  function drawTop(res){
    const svg = $("topView");
    const W = svg.viewBox.baseVal.width  || 340;
    const H = svg.viewBox.baseVal.height || 340;
    svg.setAttribute("viewBox", `0 0 ${W} ${H}`);
    svg.innerHTML = "";
    const cx = W / 2;
    const cy = H / 2;
    const blankR = Math.min(W, H) * 0.42;
    const rBlankReal = res.blankDia / 2;
    if (!rBlankReal || !isFinite(rBlankReal)) return;
    const scale = blankR / rBlankReal;
    const A = Number(res.A) || 0;
    const B = Number(res.B) || 0;
    // --- 垂直偏心：由瞳高 H 與 B 算出 ---
    let pupilH = Number(res.pupilH);
    if (!isFinite(pupilH)) {
      // 若沒填，就用你現在的預設：B / 1.7
      pupilH = B ? B / 1.7 : 0;
    }
    pupilH = Math.min(Math.max(pupilH, 0), B);
    const halfB = B / 2;
    const vDecY = pupilH - halfB;   // mm：光學中心→框中心 垂直偏心
    const dy    = vDecY * scale;    // px
    const dx    = (Number(res.dec) || 0) * scale;  // 水平偏心
    // 框橢圓（boxing system：A×B）
    const rxFrame = (A / 2) * scale;
    const ryFrame = (B / 2) * scale;
    // 框形狀：橢圓（以框中心為圓心，受 dx, dy 影響）
    ellipse(svg, cx + dx, cy + dy, rxFrame, ryFrame, "none", "#4b5563", 2);
    // ED 等效圓（虛線）
    const rED = (res.ED / 2) * scale;
    circle(svg, cx + dx, cy + dy, rED, "none", "#6b7280", 1, "4 4");
    // 裁型半徑
    const rCut = (res.cutR / rBlankReal) * blankR;
    // 鏡坯外圈（不足時紅色）－以光學中心為圓心
    circle(svg, cx, cy, blankR, "none", res.blankOK ? "#cbd5e1" : "#ef4444", 2);
    // ★ 光學中心標示（鏡坯圓心）
    // 黃色小十字＋小圓點
    line(svg, cx - 6, cy, cx + 6, cy, "#facc15", 1.2);
    line(svg, cx, cy - 6, cx, cy + 6, "#facc15", 1.2);
    circle(svg, cx, cy, 2.5, "#facc15", "none", 0);
    // 裁型圈（以框中心相對鏡坯中心之偏心顯示）
    circle(svg, cx + dx, cy + dy, rCut, "none", "#374151", 2);
    // 溝槽達標（薄側）外圈
    const rimType = (res.rimType || "").toLowerCase();
    const edgeColor =
      (rimType === "rimless")
        ? "rgba(148,163,184,0.25)"  // 無邊框：不做達標/不足判定，給中性色
        : (res.tipRemain >= res.need
            ? "rgba(34,197,94,0.4)"   // 綠：厚度足夠
            : "rgba(239,68,68,0.4)");  // 紅：厚度不足
    circle(svg, cx + dx, cy + dy, rCut + 8, "none", edgeColor, 8);
    // 標註文字
    text(svg, cx, cy - blankR - 8,
         `鏡坯片徑 ${res.blankDia.toFixed(0)} mm`,
         "#99B3C2");
    text(svg,
         cx + dx,
         cy + dy - rCut + 32,
         `裁型直徑 ≈ ${(res.cutR * 2).toFixed(1)} mm`,
         "#839681",
         "middle");
  }

function drawSection(res){
  const svg = $("sectionView");
  const W = svg.viewBox.baseVal.width || 340;
  const H = svg.viewBox.baseVal.height || 340;
  svg.setAttribute("viewBox", `0 0 ${W} ${H}`);
  svg.innerHTML = "";

  const cx       = W / 2;
  const baseY    = H * 0.75;   // 下層：左右厚條基準線
  const baseYTop = H * 0.29;   // 上層：上下緣厚條基準線

  // 橫向比例：以最大半徑 rR 或裁型 cutR 對應到視圖寬度 120px
  const maxR   = Math.max(res.rR, res.cutR);
  const scaleX = 120 / maxR;
  // 厚度比例：僅視覺化用（1mm→8px）
  const scaleT = 8;
  const rimType     = (res.rimType || "").toLowerCase(); // "full" / "groove"
  const tipHeight   = Number(res.tipHeight)   || 0.5;     // 尖高 (mm) —— 只用在剩餘厚度
  const tipWidth    = Number(res.tipWidth)    || 1.0;     // 尖寬 (mm) —— 控制 Y 高度
  const grooveDepth = Number(res.grooveDepth) || 0.6;     // 溝深 (mm) —— 只用在剩餘厚度
  const grooveWidth = Number(res.grooveWidth) || 0.6;     // 溝寬 (mm) —— 控制 Y 高度
  const minTip      = Number(res.minTip)      || 0;
  const need        = Math.max(0, Number(res.minTip) || 0);        // 最小剩餘厚度需求 (mm)
  // 在某個基準線上畫出一支厚度柱＋側面溝尖 / 車溝示意
  function drawEdgeBar(baseLineY, xCenter, tEdge){
    if (!isFinite(tEdge) || tEdge <= 0) return;
    const barW   = 12;                 // 柱子的畫面寬度 (px)
    const hPx    = tEdge * scaleT;     // 柱高 (px)
    const yBot   = baseLineY;
    const yTop   = yBot - hPx;
    const rectX  = xCenter - barW / 2;
    // 先畫藍色切面柱(垂直代表厚度)
    rect(svg, rectX, yTop, barW, hPx, "#93c5fd");
    // 判定外側方向：左邊柱外側在左，右邊柱外側在右
    const isLeft  = xCenter < cx;
    const xOuter  = isLeft ? rectX : (rectX + barW);
    // notch 垂直位置：從頂部往下固定比例（你原本的寫法）
    const needPx     = need * scaleT;
    let   fromTopPx  = hPx / 2.4;
    const maxFromTop = (hPx * 1.7) / 3;
    if (fromTopPx > maxFromTop) fromTopPx = maxFromTop;
    // notch 中心高度
    const notchCenterY = yTop + fromTopPx;
    // 全框尖寬 / 車溝寬：控制 Y 高度
    const triHPx    = Math.min(hPx, tipWidth    * scaleT);
    const grooveHPx = Math.min(hPx, grooveWidth * scaleT);
    if (rimType === "full"){
      // 全框：使用者調整「尖寬」（垂直 Y），尖高 0.5mm 為固定向外深度（水平 X）
      const depthRatioTip = 0.5;               // 用柱寬 50% 表示 0.5mm 視覺深度
      const depthPx       = barW * depthRatioTip;
      const yTriTop = notchCenterY - triHPx / 2;
      const yTriBot = notchCenterY + triHPx / 2;
      const xEdge   = xOuter;                                       // 柱子外側
      const xApex   = isLeft ? (xEdge - depthPx) : (xEdge + depthPx); // 向外尖端
      polygon(
        svg,
        [
          [xEdge, yTriTop],
          [xEdge, yTriBot],
          [xApex, notchCenterY]
        ],
        "#93c5fd",
        null,
        null
      );

    } else if (rimType === "groove") {
      // 車溝框：側邊「方形」凹槽示意
      // grooveWidth = 使用者調的「溝寬」(mm) → 控制 Y 高度
      // grooveDepth = 固定的「溝深」(mm)     → 控制 X 深度
      // 垂直高度：依 grooveWidth 決定
      const gHeightPx = Math.min(hPx, grooveWidth * scaleT);
      // 水平深度：用 grooveDepth 換算，限制在柱寬 80% 以內
      const gDepthPx  = Math.min(barW * 0.8, grooveDepth * scaleX);
      // 溝中心高度用 notchCenterY（跟全框尖同一條高度線）
      const yMid   = notchCenterY;
      const yRect  = yMid - gHeightPx / 2;
      // 方形靠在外側邊，向內吃 gDepthPx
      const xRect = isLeft
        ? xOuter                     // 左邊柱：從外側往右切
        : (xOuter - gDepthPx);       // 右邊柱：從外側往左切
      rect(
        svg,
        xRect,
        yRect,
        gDepthPx,                    // 水平寬度：溝深
        gHeightPx,                   // 垂直高度：溝寬
        "rgba(2, 8, 23,0.85)"        // 紅色方塊示意車溝
      );
    }
  }
  // ===== 下層：左右邊緣厚度 =====
  line(svg, cx - 140, baseY, cx + 140, baseY, "#e5e7eb", 1);
  const span = 60;
  const xL   = cx - span;
  const xR   = cx + span;
  const tL = thicknessAt(res, "L");
  const tR = thicknessAt(res, "R");
  drawEdgeBar(baseY, xL, tL);
  drawEdgeBar(baseY, xR, tR);
  // 標註：左右
  text(svg, xL, baseY + 14,
       `左 r=${res.rL.toFixed(1)}mm\n邊厚=${tL.toFixed(2)}mm`,
       "#A9BED6","middle");
  text(svg, xR, baseY + 14,
       `右 r=${res.rR.toFixed(1)}mm\n邊厚=${tR.toFixed(2)}mm`,
       "#A9BED6","middle");
  // ===== 上層：上下緣厚度 =====
  const B = Number(res.B) || 0;
  if (B > 0) {
    let pupilH = res.pupilH;
    if (!(typeof pupilH === "number" && isFinite(pupilH))) {
      pupilH = B / 2;
    }
    const halfB = B / 2;
    const yP   = -halfB + pupilH;
    const vTop = Math.max(0, halfB - yP);
    const vBot = Math.max(0, pupilH);
    const decAbs = Math.abs(res.dec || 0);
    const rTop = Math.sqrt(decAbs * decAbs + vTop * vTop);
    const rBot = Math.sqrt(decAbs * decAbs + vBot * vBot);
    const tTop = thicknessAtRadius(res, rTop, "vertical");
    const tBot = thicknessAtRadius(res, rBot, "vertical");
    line(svg, cx - 140, baseYTop, cx + 140, baseYTop, "#C6E398", 1);
    const topGap = 120;
    const xTop = cx - topGap/2;
    const xBot = cx + topGap/2;
    drawEdgeBar(baseYTop, xTop, tTop);
    drawEdgeBar(baseYTop, xBot, tBot);
    text(svg, xTop, baseYTop + 14,
         `上 r≈${rTop.toFixed(1)}mm\n厚度≈${tTop.toFixed(2)}mm`,
         "#A9BED6","middle");
    text(svg, xBot, baseYTop + 14,
         `下 r≈${rBot.toFixed(1)}mm\n厚度≈${tBot.toFixed(2)}mm`,
         "#A9BED6","middle");
  }
  // ===== 底部說明：溝尖 / 車溝寬度與剩餘厚度 =====
  const estEdgeMin = Number(res.estEdgeMin);
  const cutDepth   = (rimType === "full") ? tipHeight : (rimType === "groove") ? grooveDepth : 0;
  const tipRemain  = estEdgeMin - cutDepth;
  let label;
  if (rimType === "full") {
    label =
      `尖寬 ${tipWidth.toFixed(1)}mm；尖高約 ${tipHeight.toFixed(2)}mm\n` +
      `薄側剩餘 ${tipRemain.toFixed(2)}mm（需求 ≥ ${need.toFixed(2)}mm）`;
  } else if (rimType === "groove") {
    label =
      `溝寬 ${grooveWidth.toFixed(1)}mm；溝深約 ${grooveDepth.toFixed(2)}mm\n` +
      `薄側剩餘 ${tipRemain.toFixed(2)}mm（需求 ≥ ${need.toFixed(2)}mm）`;
  } else if (rimType === "rimless") {
    label = `薄側厚度 ${estEdgeMin.toFixed(2)}mm`;
  } else {
    label =
      `薄側剩餘 ${tipRemain.toFixed(2)}mm
` +
      `（需求 ≥ ${need.toFixed(2)}mm）`;
  }
  text(svg, cx, baseY + 52, label, "#4FABB8","middle");
}
  function applyVerticalDec(res){
    const B = Number(res.B) || 0;
    if (!B) return res;
    let pupilH = Number(res.pupilH);
    if (!isFinite(pupilH)) {
      pupilH = B / 1.7;
    }
    pupilH = Math.min(Math.max(pupilH, 0), B);
    const decAbs = Math.abs(res.dec || 0);
    const vTop = Math.max(0, B - pupilH);
    const vBot = Math.max(0, pupilH);
    const rTop    = Math.sqrt(decAbs * decAbs + vTop * vTop);
    const rBottom = Math.sqrt(decAbs * decAbs + vBot * vBot);
    const rL = Number(res.rL) || 0;
    const rR = Number(res.rR) || 0;
    // 四方位計算
    const tL   = thicknessAt(res, "L");                  // 水平左
    const tR   = thicknessAt(res, "R");                  // 水平右
    const tTop = thicknessAtRadius(res, rTop, "vertical");   // 垂直上
    const tBot = thicknessAtRadius(res, rBottom, "vertical"); // 垂直下
    //處理資料與呼叫整合
    const estEdgeMin = Math.min(tL, tR, tTop, tBot);
    const estCenter =
      (typeof res.estCenter === "number" && isFinite(res.estCenter))
        ? res.estCenter
        : thicknessAtRadius(res, 0, "horizontal");
    const delta = Math.abs(estCenter - estEdgeMin);
    const rimType     = (res.rimType || "").toLowerCase();
    const grooveDepth = Number(res.grooveDepth) || 0.8; // 車溝深
    const tipHeight   = Number(res.tipHeight)   || 0.5; // 溝尖高
    const tipSpan     = Number(res.tipSpan)     || tipHeight;
    const grooveSpan  = Number(res.grooveSpan)  || grooveDepth;
    const minTip      = (typeof res.minTip === "number" && isFinite(res.minTip))
          ? res.minTip
          : 0;
    let cutDepth = 0;
    if (rimType === "full") {
      cutDepth = tipHeight;
    } else if (rimType === "groove") {
      cutDepth = grooveDepth;
    } else {
      cutDepth = 0; // rimless / 其他：不扣深度
    }
    const need        = (rimType === "rimless") ? 0 : Math.max(0, minTip);
    const tipRemain   = estEdgeMin - cutDepth;
    const halfOK      = tipRemain >= need;
    const halfB = B / 2;
    const vDecY = pupilH - halfB;
    const allowance = Number(res.allowance) || 0;
    const blankDia  = Number(res.blankDia)  || 0;
    const rMax    = Math.max(rL, rR, rTop, rBottom);
    const hReq    = rMax + allowance;
    const minBlank= hReq * 2;
    const blankOK = blankDia >= minBlank;
    const blankR = blankDia ? blankDia / 2 : rMax;
    let maxBlankThick;
    if (res.lensType === "minus") {
      maxBlankThick = thicknessAtRadius(res, blankR, "horizontal");
    } else {
      maxBlankThick = thicknessAtRadius(res, 0, "horizontal");
    }
    let effectiveRemain;
    if (rimType === "full") {
      effectiveRemain = estEdgeMin - tipHeight;
    } else if (rimType === "groove") {
      effectiveRemain = estEdgeMin - grooveDepth;
    } else {
      effectiveRemain = estEdgeMin;
    }
    res.vDecY         = vDecY;
    res.pupilH        = pupilH;
    res.rTop          = rTop;
    res.rBottom       = rBottom;
    res.tTop          = tTop;
    res.tBottom       = tBot;
    res.estEdgeMin    = estEdgeMin;
    res.tipRemain     = tipRemain;
    res.halfOK        = halfOK;
    res.need          = need;
    res.rMax          = rMax;
    res.hReq          = hReq;
    res.minBlank      = minBlank;
    res.blankOK       = blankOK;
    res.maxBlankThick = maxBlankThick;
    res.delta         = delta;
    res.estCenter     = estCenter; 
    return res;
  }
  // ---- 統一的環曲面模型：在 r, θ 位置回傳前表 / 後表 sag 與厚度 ----
  function lensSurfacesAt(res, r, thetaRad){
    const n = Number(res.n) || 1.5;
    const denom = 2000 * (n - 1) || 1;
    const thetaDeg = thetaRad * 180 / Math.PI;
    if (!isFinite(r) || r < 0) {
      return { t: 0, sagFront: 0, sagBack: 0 };
    }
    // 近視：前表 = 基弧 BC（純球面），後表 = F_total − BC（含散光）
    if (res.lensType === "minus") {
      const S    = Number(res.D)   || 0;
      const C    = Number(res.Cyl) || 0;
      const Axis = Number(res.Axis) || 0;
      let BC = Number(res.BC);
      if (!isFinite(BC) || BC < 0) {
        BC = 0;  // 當作平前表
      }
      // 前表：基弧 BC 球面
      const F_front  = BC;
      const sagFront = (r * r * Math.abs(F_front)) / denom;
      // 總度數 + 後表度數
      const F_total = meridionalPower(res, thetaDeg);
      const F_back  = F_total - F_front;
      const sagBack = (r * r * Math.abs(F_back)) / denom;
      // ★ 厚度改由 thicknessAtPolar 統一決定（與 3D 完全一致）
      const t = Math.max(0, thicknessAtPolar(res, r, thetaRad) || 0);
      return { t, sagFront, sagBack };
    }
    // ===== 遠視：前表 = 基弧 BC 球面，後表 = (S-BC) 球面 + C 散光（標準後散形式） =====
    // 在這裡只負責「前 / 後表的 sag 幾何拆解」，厚度一律交給 thicknessAtPolar 統一決定
    const S    = Number(res.D)   || 0;   // 處方球鏡（多半為 +）
    const C    = Number(res.Cyl) || 0;   // 處方散光 (0 或負)
    const Axis = Number(res.Axis) || 0;  // 散光軸度（度）
    let   BC   = Number(res.BC);         // 使用者指定基弧（前表）
    // 若沒輸入基弧，視為前表球鏡 = S（單純凸平遠視鏡）
    if (!isFinite(BC) || BC === 0) {
      BC = S;
    }
    // ---- 前表：基弧 BC，與軸度無關（純球面） ----
    const F_front  = BC;
    const sagFront = (r * r * Math.abs(F_front)) / denom;
    // ---- 後表：拆成「基弧球面 + 散光」 ----
    // 條件：
    //   子午線沿柱軸：   F_front + F2_axis      = S
    //   子午線與柱軸垂直：F_front + F2_axis + C = S + C
    //   => F2_axis = S - F_front   （後表在柱軸方向的球面成分）
    const F2_axis = S - F_front;
    // 某一方向 θ 的後表折射力：F_back(θ) = F2_axis + C·sin²(θ − Axis)
    const radAxis = (thetaDeg - Axis) * Math.PI / 180;
    const sin2    = Math.sin(radAxis) * Math.sin(radAxis);
    const F_back  = F2_axis + C * sin2;
    const sagBack = (r * r * Math.abs(F_back)) / denom;
    // ---- 厚度：改由 thicknessAtPolar 統一決定，這裡不再重新設計 centerT / edgeT ----
    const tPolar = thicknessAtPolar(res, r, thetaRad);
    const t      = isFinite(tPolar) ? Math.max(0, tPolar) : 0;
    return { t, sagFront, sagBack };
  }

  // ---- 只需要「厚度」時的 helper：統一走 lensSurfacesAt ----
  // 近視：中薄邊厚；遠視：中心最厚、邊緣最薄 ≈ edgeT
  function thicknessAtPolar(res, r, thetaRad){
    if (!isFinite(r) || r < 0) return 0;
    const n = Number(res.n) || 1.5;
    const denom = 2000 * (n - 1) || 1;     // = (n-1)/(R=1000mm) 的倒數
    const thetaDeg = thetaRad * 180 / Math.PI;
    // ===== 近視：厚度 = 單面等效 sag + 一部分 BC 造成的額外厚度 =====
    if (res.lensType === "minus"){
      const S    = Number(res.D)   || 0;   // 球鏡（多半為負）
      const C    = Number(res.Cyl) || 0;   // 散光
      const Axis = Number(res.Axis) || 0;
      // 總度數（含散光）：S + C·sin²(θ − Axis)
      const F_total = meridionalPower(res, thetaDeg);
      // 基弧 BC：不合法或負值就當作 0（平前表）
      let BC = Number(res.BC);
      if (!isFinite(BC) || BC < 0) BC = 0;
      const F_front = BC;              // 前表
      const F_back  = F_total - F_front; // 後表
      const sagTotal = (r * r * Math.abs(F_total)) / denom;
      const sagFront = (r * r * Math.abs(F_front)) / denom;
      const sagBack  = (r * r * Math.abs(F_back))  / denom;
      // k 控制 BC 對厚度的影響比例（0~1）
      const k = 0.35;  // 你覺得還是太誇張就改小，例如 0.25
      const sagMix = sagTotal + k * ((sagFront + sagBack) - sagTotal);
      const centerT = Number(res.centerT) || 0;
      const tRaw    = centerT + sagMix;
      return Math.max(0, tRaw);
    }

    // ===== 遠視：前表球面 + 後表散光（標準後散） =====
    const S    = Number(res.D)   || 0;   // 處方球鏡（多半為 +）
    const C    = Number(res.Cyl) || 0;   // 處方散光（0 或負）
    const Axis = Number(res.Axis) || 0;
    // 前表基弧：優先採用 BC；未填則退回 S
    let BC = Number(res.BC);
    if (!isFinite(BC) || BC === 0) {
      BC = S;
    }
    const F_front = BC;          // 前表折射力
    // 幾何邊界：實際鏡坯 / 裁型 / 偏心的最大半徑
    const rL     = Math.max(Number(res.rL)   || 0, 0);
    const rR     = Math.max(Number(res.rR)   || 0, 0);
    const cutR   = Number(res.cutR) || ((Number(res.ED) || 0) / 2);
    const blankR = Number(res.blankDia) ? Number(res.blankDia) / 2 : cutR;
    const rEdgeReal = Math.max(blankR, cutR, rL, rR);
    const edgeT = Number(res.edgeT) || 0;
    // sag 幫助函式
    const sagSphere = (radius, F) => (radius * radius * Math.abs(F)) / denom;
    // 後表軸向球鏡成分：例如 S=+6, F_front=+9 → F_back_axis=-3
    const F_back_axis = S - F_front;
    // 前表在 rEdgeReal 的 sag（與 θ 無關）
    const sagFrontMax = sagSphere(rEdgeReal, F_front);
    // 後表「參考子午線」（軸向）的 sag
    const sagBackAxisMax = sagSphere(rEdgeReal, F_back_axis);
    // ★ 這裡只用「軸向」來決定中心厚，避免中心厚度跟 θ 變動
    const centerBase = sagFrontMax - sagBackAxisMax + edgeT;
    // ----- 以下才是與 θ 有關的散光部分 -----
    const rad  = (thetaDeg - Axis) * Math.PI / 180;
    const sin2 = Math.sin(rad) * Math.sin(rad);
    // 該方向的後表折射力：F_back(θ) = F_back_axis + C·sin²(θ − Axis)
    const F_back_theta = F_back_axis + C * sin2;
    // 任意半徑 r 的前 / 後表 sag
    const sagFront_r = sagSphere(r, F_front);
    const sagBack_r  = sagSphere(r, F_back_theta);
    // 厚度：t(r,θ) = centerBase − [ sagFront(r) − sagBack(r,θ) ]
    let tBase = centerBase - (sagFront_r - sagBack_r);
    if (!isFinite(tBase)) tBase = 0;
    return Math.max(0, tBase);
  }

  // 在半徑 r、指定子午線方向計算厚度：
  // merTag = "horizontal" | "vertical" | "L" | "R" | "Top" | "Bottom"
  function thicknessAtRadius(res, r, merTag){
    if (!isFinite(r) || r < 0) return 0;
    let thetaDeg;
    switch(merTag){
      case "vertical":
      case "Top":
      case "Bottom":
        thetaDeg = 90;  // 垂直經線
        break;
      case "horizontal":
      case "L":
      case "R":
      default:
        thetaDeg = 0;   // 水平經線
        break;
    }
    const thetaRad = thetaDeg * Math.PI / 180;
    // ★ 新增：遠視鏡片改用 thicknessAtPolar 的厚度模型，
    // 讓 KPI / 2D / 3D 在遠視時全部走同一套幾何厚度
    if (res.lensType === "plus") {
      return thicknessAtPolar(res, r, thetaRad);
    }
    // 近視仍然沿用 lensSurfacesAt（你現在的 BC + 後表設計）
    const surf = lensSurfacesAt(res, r, thetaRad);
    return surf && isFinite(surf.t) ? surf.t : 0;
  }
  // 方便左右 / 上下呼叫用的小幫手
  function thicknessAt(res, side){
    switch(side){
      case "L":
        return thicknessAtRadius(res, res.rL, "L");
      case "R":
        return thicknessAtRadius(res, res.rR, "R");
      case "Top":
        return thicknessAtRadius(res, res.rTop, "Top");
      case "Bottom":
        return thicknessAtRadius(res, res.rBottom, "Bottom");
      default:
        return thicknessAtRadius(res, res.rL, "horizontal");
    }
  }
  function spectacleMagnification(res){
    const n  = Number(res.n) || 1.5;
    const t  = (Number(res.centerT) || 0) / 1000;   // mm → m
    const F1 = Number(res.frontPower) || 0;         // 前表度數（BC）
    // 後頂點度數：先用球等效當粗略 Fv
    const S   = Number(res.D)   || 0;
    const C   = Number(res.Cyl) || 0;
    const Fse = S + C / 2;                          // 球等效 D
    // 鏡眼距 h（mm → m），若沒輸入就預設 12 mm
    const h_mm = Number(res.vertex) || 12;
    const h    = h_mm / 1000;
    // Power factor & Shape factor
    const PF = 1 / (1 - h * Fse);
    const SF = 1 / (1 - (t / n) * F1);
    const SM = PF * SF;
    if (!isFinite(SM) || SM <= 0) return 1;      
    return SM;
  }
  function ellipse(svg, cx, cy, rx, ry, fill, stroke, sw, dash){
    const el = document.createElementNS('http://www.w3.org/2000/svg','ellipse');
    el.setAttribute('cx',cx);
    el.setAttribute('cy',cy);
    el.setAttribute('rx',rx);
    el.setAttribute('ry',ry);
    el.setAttribute('fill',fill);
    el.setAttribute('stroke',stroke);
    el.setAttribute('stroke-width',sw);
    if(dash) el.setAttribute('stroke-dasharray',dash);
    svg.appendChild(el);
  }
  function addEdgeProfile3D(res, scene, baseMesh, rEdgeReal, sR, sT, centerYOffset=0){
    if (!res || !scene || !baseMesh || !window.THREE) return null;

    const rimType = String(res.rimType || "").toLowerCase();
    if (rimType !== "full" && rimType !== "groove") return null;

    // 以薄側厚度作為參考，決定溝尖/車溝在厚度方向（Y）的大致置中位置
    let tRef = Number(res.estEdgeMin);
    if (!isFinite(tRef) || tRef <= 0){
      // 後備：用外緣半徑、水平經線估一個厚度
      try{
        tRef = thicknessAtPolar(res, rEdgeReal, 0);
      }catch(e){
        tRef = 2;
      }
    }
    tRef = Math.max(0.4, tRef);

    // lens 本體：local y=0 為前表、local y<0 為往後表
    const yFront = 0;
    const yBack  = -tRef * sT;
    const yMid   = (yFront + yBack) / 2;

    const tipHeight   = Math.max(0.05, Number(res.tipHeight)   || 0.5); // mm (徑向 X)
    const grooveDepth = Math.max(0.05, Number(res.grooveDepth) || 0.6); // mm (徑向 X)
    const tipSpan     = Math.max(0.10, Number(res.tipSpan)     || Number(res.tipWidth)   || 1.0); // mm (厚度 Y)
    const grooveSpan  = Math.max(0.10, Number(res.grooveSpan)  || Number(res.grooveWidth)|| 1.0); // mm (厚度 Y)

    const group = new THREE.Group();
    group.position.y = baseMesh.position.y + centerYOffset;
    group.renderOrder = 9;

    // 外緣半徑（world）
    const rBase = rEdgeReal * sR * 1.002;

    const makeLathe = (pts, opacity=0.75) => {
      const geo = new THREE.LatheGeometry(pts, 128);
      const mat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        wireframe: true,
        transparent: true,
        opacity,
        depthTest: false,
        depthWrite: false,
        polygonOffset: true,
        polygonOffsetFactor: -1,
        polygonOffsetUnits: -1,
        side: THREE.DoubleSide
      });
      const m = new THREE.Mesh(geo, mat);
      m.renderOrder = 9;
      return m;
    };

    if (rimType === "full"){
      // 全框：外凸三角形溝尖（尖寬 = tipSpan, 尖高 = tipHeight）
      const h = (tipSpan * sT) / 2;
      const rTip = rBase + tipHeight * sR;

      const pts = [
        new THREE.Vector2(rBase, yMid - h),
        new THREE.Vector2(rTip,  yMid),
        new THREE.Vector2(rBase, yMid + h),
        new THREE.Vector2(rBase, yMid - h)
      ];
      group.add(makeLathe(pts, 0.85));
    } else if (rimType === "groove"){
      // 車溝框：方形內凹槽（溝寬 = grooveSpan, 溝深 = grooveDepth）
      const h = (grooveSpan * sT) / 2;
      const rIn = Math.max(0.1, rBase - grooveDepth * sR);

      const pts = [
        new THREE.Vector2(rBase, yMid - h),
        new THREE.Vector2(rBase, yMid + h),
        new THREE.Vector2(rIn,   yMid + h),
        new THREE.Vector2(rIn,   yMid - h),
        new THREE.Vector2(rBase, yMid - h)
      ];
      group.add(makeLathe(pts, 0.80));
    }

    scene.add(group);
    return group;
  }
  let _L3D = null;

  function init3D(){
    if (_L3D || !window.THREE) return;
    const wrap = document.getElementById('threeWrap');
    if (!wrap) return;
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a1322);
    const camera = new THREE.PerspectiveCamera(35, wrap.clientWidth / wrap.clientHeight, 0.1, 1000);
    camera.position.set(0, 25, 85);
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(wrap.clientWidth, wrap.clientHeight);
    wrap.innerHTML = '';
    wrap.appendChild(renderer.domElement);
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    // lights
    const key = new THREE.DirectionalLight(0xffffff, 1.2); key.position.set(1,2,3);
    const fil = new THREE.DirectionalLight(0x88ccff, 0.8); fil.position.set(-2,1,0);
    const amb = new THREE.AmbientLight(0x334455, 1.4);
    scene.add(key, fil, amb);
    // subtle grid
    const grid = new THREE.GridHelper(200, 20, 0x1f3045, 0x182435);
    grid.position.y = -0.01; scene.add(grid);

    _L3D = {wrap, scene, camera, renderer, controls,
          mesh:null, ring:null, edge:null, slice:null, rim:null};

    window.addEventListener('resize', ()=>{
      if(!_L3D) return;
      const {wrap, camera, renderer} = _L3D;
      camera.aspect = wrap.clientWidth / wrap.clientHeight; 
      camera.updateProjectionMatrix();
      renderer.setSize(wrap.clientWidth, wrap.clientHeight);
    });

    (function loop(){ if(!_L3D) return; requestAnimationFrame(loop); _L3D.controls.update(); _L3D.renderer.render(_L3D.scene, _L3D.camera); })();
  }

// 厚度模型：依 2D 厚度 + 度數場，建立「前表 / 後表 + 側邊圍牆」的實心鏡片
function buildLensLatheGeometry(res){
  const rL     = Number(res.rL)    || 0;
  const rR     = Number(res.rR)    || 0;
  const cutR   = Number(res.cutR)  || ((Number(res.ED) || 0) / 2);
  const blankR = Number(res.blankDia) ? Number(res.blankDia) / 2 : cutR;
  const rEdgeReal = Math.max(blankR, cutR, rL, rR);
  if (!isFinite(rEdgeReal) || rEdgeReal <= 0){
    return null;
  }
  // 給 3D 用的縮放：半徑 / 厚度
  const sR = 0.6;   // 半徑 → 3D 尺度
  const sT = 0.8;   // 厚度 → 3D 尺度
  // ===== 取樣 front / back 兩層點 =====
  const segTheta = 96; // 角度切片
  const segRad   = 32; // 半徑切片
  const positions = [];
  const indices   = [];
  // 給「遠視前表球面」用的參數
  const n3     = Number(res.n) || 1.5;
  const denom3 = 2000 * (n3 - 1) || 1;
  const BCval  = Number(res.BC);
  const Sval   = Number(res.D) || 0;
  // baseF：用來畫前表面球面的度數
  //  - 遠視：優先用 BC；沒填 BC 就用球鏡 S
  //  - 近視：目前先維持平面前表（baseF = 0）
  let baseF;
  if (res.lensType === "plus"){
    baseF = isFinite(BCval) && BCval !== 0 ? BCval : Sval;
  } else {
    baseF = (isFinite(BCval) && BCval > 0) ? BCval : 0;
  }
  baseF = Number(baseF) || 0;
  // 以「毛坯最大半徑」算出前表球面在邊緣的最大 sag
  // 注意：這邊用的是「前表球鏡 baseF」，不是整體 S/C 度數
  const sagFrontMax = (rEdgeReal * rEdgeReal * Math.abs(baseF)) / denom3;
  // 取樣 front / back 兩層點
  for (let j = 0; j <= segRad; j++){
    const v = j / segRad;
    const r = rEdgeReal * v;
    for (let i = 0; i <= segTheta; i++){
      const u = i / segTheta;
      const theta = u * Math.PI * 2;
      const x = r * Math.cos(theta);
      const z = r * Math.sin(theta);
      // 厚度：用 2D 模組算出該方向的厚度（含散光）
      const t = Math.max(0, thicknessAtPolar(res, r, theta) || 0);
      let yFront, yBack;
      if (res.lensType === "minus"){
        // 近視：有 BC 時，用 BC 畫前表球面；沒有 BC 時維持平前表
        if (isFinite(baseF) && baseF > 0){
          const sagFront = (r * r * Math.abs(baseF)) / denom3;
          // 跟遠視一樣：中心最高、邊緣接近 0
          yFront = (sagFrontMax - sagFront) * sT;
        } else {
          yFront = 0;
        }
        // 後表 = 前表往內縮 t（t 已經在 thicknessAtPolar 裡吃到 BC）
        yBack  = yFront - t * sT;
      } else {
        // 遠視：前表依照 BC 畫成「中心最高、邊緣最低」的球面
        const sagFront = (r * r * Math.abs(baseF)) / denom3;
        // r = 0 時 yFront ≈ sagFrontMax；r = rEdge 時 yFront ≈ 0 → 看起來是凸的
        yFront = (sagFrontMax - sagFront) * sT;
        // 後表 = 前表往內縮 t（這樣前後表距離 = 厚度函數）
        yBack  = yFront - t * sT;
      }
      const X = x * sR;
      const Z = z * sR;
      // 依序 push：front / back
      positions.push(X, yFront, Z); // front vertex
      positions.push(X, yBack,  Z); // back vertex
    }
  }
  // ===== 建面（front / back / 側邊） =====
  const rowSize = segTheta + 1;
  // front / back 面
  for (let j = 0; j < segRad; j++){
    for (let i = 0; i < segTheta; i++){
      const a = j       * rowSize + i;
      const b = j       * rowSize + i + 1;
      const c = (j + 1) * rowSize + i;
      const d = (j + 1) * rowSize + i + 1;
      const aF = a * 2;
      const bF = b * 2;
      const cF = c * 2;
      const dF = d * 2;
      // front（朝外）
      indices.push(aF, cF, bF);
      indices.push(bF, cF, dF);
      // back（反向）
      const aB = aF + 1;
      const bB = bF + 1;
      const cB = cF + 1;
      const dB = dF + 1;
      indices.push(aB, bB, cB);
      indices.push(bB, dB, cB);
    }
  }

  // 側邊圓柱牆：把半徑最外圈的 front / back 用三角形連起來，包成一圈
  for (let i = 0; i < segTheta; i++){
    const iNext = (i + 1) % (segTheta + 1);
    const topIdxFront = (segRad * rowSize + i)     * 2;
    const topIdxBack  = (segRad * rowSize + i)     * 2 + 1;
    const nxtIdxFront = (segRad * rowSize + iNext) * 2;
    const nxtIdxBack  = (segRad * rowSize + iNext) * 2 + 1;
    indices.push(topIdxFront, nxtIdxFront, topIdxBack);
    indices.push(nxtIdxFront, nxtIdxBack, topIdxBack);
  }
  const geo = new THREE.BufferGeometry();
  geo.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3));
  geo.setIndex(indices);
  geo.computeVertexNormals();
  geo.userData = { rEdgeReal };
  return geo;
}
function update3D(res){
  if (!window.THREE) return;
  init3D();
  if (!_L3D) return;
  const scene = _L3D.scene;
  // ---------- 先清掉舊物件 ----------
  ["mesh","edge","rim","ring","slice","edgeStyle"].forEach(key => {
    const obj = _L3D[key];
    if (!obj){ _L3D[key] = null; return; }

    if (Array.isArray(obj)){
      obj.forEach(o => {
        if (!o) return;
        scene.remove(o);
        if (o.geometry) o.geometry.dispose();
        if (o.material) o.material.dispose();
      });
    }else{
      scene.remove(obj);
      if (obj.geometry) obj.geometry.dispose();
      if (obj.material) obj.material.dispose();
    }
    _L3D[key] = null;
  });
  // ---------- 建立鏡片幾何 ----------
  const g = buildLensLatheGeometry(res);
  if (!g) return;
  const rEdgeReal =
    g.userData.rEdgeReal ||
    (Number(res.blankDia) ? Number(res.blankDia)/2
                          : Math.max(
                              Number(res.rL) || 0,
                              Number(res.rR) || 0,
                              Number(res.cutR) || 0,
                              (Number(res.ED) || 0)/2
                            ));
  const sR = g.userData.sR || g.userData.rScale || 0.6;
  const sT = g.userData.sT || g.userData.tScale || 0.8;
  const edgeStyles = [];
  // ---------- 1. 鏡片本體 ----------
  const lensMat = new THREE.MeshPhysicalMaterial({
    color: 0xaad9ff,
    roughness: 0.3,
    metalness: 0.0,
    transmission: 0.25,
    transparent: true,
    opacity: 0.08,
    side: THREE.DoubleSide
  });
  const mesh = new THREE.Mesh(g, lensMat);
  mesh.position.y = 6;
  mesh.renderOrder = 0;
  scene.add(mesh);
  _L3D.mesh = mesh;
  // ---------- 反光膜 ----------
  // 先清掉舊的 highlight
  if (_L3D.highlight) {
    scene.remove(_L3D.highlight);
    if (_L3D.highlight.geometry) _L3D.highlight.geometry.dispose();
    if (_L3D.highlight.material) _L3D.highlight.material.dispose();
    _L3D.highlight = null;
  }
  // 用跟鏡片同一套幾何，當作反光膜的形狀
  const highlightGeo = g.clone();
  const highlightMat = new THREE.MeshPhysicalMaterial({
    color: 0xffffff,          // 反光偏白
    transmission: 1.0,        // 玻璃感
    transparent: true,
    opacity: 0.05,            // 不要太實心，像薄薄一層膜
    roughness: 0.04,          // 越小越銳利的高光
    metalness: 0.0,
    reflectivity: 0.9,        // 反射感強一點
    clearcoat: 1.0,           // 清漆層
    clearcoatRoughness: 0.1,
    depthWrite: false,        // 蓋掉裡面的骨架線
    blending: THREE.AdditiveBlending // 疊加在鏡片上看起來更亮
  });
  const highlight = new THREE.Mesh(highlightGeo, highlightMat);
  highlight.position.copy(mesh.position);
  highlight.scale.set(1.002, 1.002, 1.002);
  highlight.renderOrder = 3;
  scene.add(highlight);
  _L3D.highlight = highlight;
  // ---------- 1. 鏡片骨架線 ----------
  const edgeGeo = new THREE.EdgesGeometry(g);
  const edgeMat = new THREE.LineBasicMaterial({
    color: 0x7f8ca3,
    transparent: true,
    depthWrite: false,  
    opacity: 0.008
  });
  const edgeLines = new THREE.LineSegments(edgeGeo, edgeMat);
  edgeLines.position.copy(mesh.position);
  edgeLines.renderOrder = 0;
  scene.add(edgeLines);
  // 之後要一起清掉，所以用陣列包起來
  const edgeObjects = [edgeLines];
  // ---------- 1-1. 前 / 後表「真實厚度」外圈輪廓線 ----------
  if (rEdgeReal > 0) {
  const rimSteps = 96;              // 圓周取樣密度
  const frontPts = [];
  const backPts  = [];
  for (let i = 0; i <= rimSteps; i++) {
    const u     = i / rimSteps;
    const theta = u * Math.PI * 2;   // 弧度
    // ★ 用 toric 厚度，會吃到散光和軸度
    const t = thicknessAtPolar(res, rEdgeReal, theta) || 0;
    const xReal = rEdgeReal * Math.cos(theta);
    const zReal = rEdgeReal * Math.sin(theta);
    const xWorld = xReal * sR;
    const zWorld = zReal * sR;
    // 與 buildLensLatheGeometry 一致：
    // 最外圈：前表 y = 0，後表 y = -t * sT（不分近視 / 遠視）
    const yFrontLocal = 0;
    const yBackLocal  = -t * sT;
    frontPts.push(new THREE.Vector3(xWorld, yFrontLocal, zWorld));
    backPts.push (new THREE.Vector3(xWorld, yBackLocal,  zWorld));
  }
  const frontGeo = new THREE.BufferGeometry().setFromPoints(frontPts);
  const backGeo  = new THREE.BufferGeometry().setFromPoints(backPts);
    const frontMat = new THREE.LineBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.35         // 上表邊界線：亮一點
    });
    const backMat  = new THREE.LineBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.30         // 下表邊界線：淡一點
    });
    const frontLoop = new THREE.LineLoop(frontGeo, frontMat);
    const backLoop  = new THREE.LineLoop(backGeo,  backMat);
    frontLoop.position.y = mesh.position.y;
    backLoop.position.y  = mesh.position.y;
    frontLoop.renderOrder = 1;
    backLoop.renderOrder  = 1;
    scene.add(frontLoop);
    scene.add(backLoop);
    edgeObjects.push(frontLoop, backLoop);
  }
  _L3D.edge = edgeObjects;
  const Cyl = Number(res.Cyl) || 0;
  let centerYOffset = 0; // 供 rim 與 edgeProfile 共用（避免區塊外 ReferenceError）
  // ---------- 2. 側邊圓柱牆（讓鏡片像「實心」） ----------
  if (rEdgeReal > 0 && Math.abs(Cyl) < 0.01){
    let hVis = 0;
    if (res.lensType === "minus") {
      // 近視（無散光）：
      // 圓柱高度 = 鏡坯最厚厚度（maxBlankThick），不要被前表凸弧影響
      const tMax = Number(res.maxBlankThick) || 0; // 單位 mm
      if (tMax > 0){
        hVis = tMax * sT;      // 轉成 3D y 高度
        // 前表我們是放在 y = 0，後表在 y = -tMax * sT
        // 圓柱中心取在中間 → -tMax*sT/2
        centerYOffset = -hVis / 2;
      }
    } else {
      // 遠視（無散光）：圓柱高度 = 「邊緣厚度」，不要被前表凸透鏡拉高
      const edgeT = Number(res.edgeT) || 0;  // 使用者設定的邊緣厚度（mm）
      if (edgeT > 0){
        hVis = edgeT * sT;          // 厚度轉成 3D y 軸縮放後的高度
        // 前表在邊緣被我們放在 y = 0，後表在 y = -edgeT * sT
        // 所以圓柱中心在兩者中間：-edgeT*sT/2
        centerYOffset = -hVis / 2;
      }
    }
    if (hVis > 0.0001){
      const rWorld = rEdgeReal * sR * 1.002;
      const rimGeo = new THREE.CylinderGeometry(
        rWorld, rWorld, hVis, 64, 1, true
      );
      const rimMat = new THREE.MeshBasicMaterial({
        color: 0xaad9ff,
        transparent: true,
        opacity: 0.12,
        side: THREE.DoubleSide,
        depthTest: true,
        depthWrite: true
      });
      const rim = new THREE.Mesh(rimGeo, rimMat);
      rim.position.y = mesh.position.y + centerYOffset;
      rim.renderOrder = 0;
      scene.add(rim);
      _L3D.rim = rim;
    }
  }
  // ---------- 2.5 邊緣樣式（全框/車溝/無邊框） ----------
  // 已移除「外圈線框/Lathe wireframe」以避免出現一圈方框 XX。

// ---------- 3. 偏心（水平 dec + 瞳高造成的垂直 dec） ----------
  const B = Number(res.B) || 0;
  let pupilH = Number(res.pupilH);
  if (!isFinite(pupilH)) {
    pupilH = B ? B / 1.7 : 0;
  }
  const halfB   = B / 2;
  const vDecReal = B ? (pupilH - halfB) : 0;          // 垂直偏心 mm
  const hDecReal = Number(res.dec) || 0;              // 水平偏心 mm
  const cutRReal = Number(res.cutR) || (Number(res.ED) || 0) / 2;
  const offsetDist = Math.sqrt(hDecReal*hDecReal + vDecReal*vDecReal);
  const ringInside =
    cutRReal > 0 && (offsetDist + cutRReal <= rEdgeReal + 1e-6);
  // ---------- 4. 裁型圈（高亮） ----------
  if (cutRReal > 0){
    const ringRadius = cutRReal * sR;
    const ringGeo = new THREE.TorusGeometry(ringRadius, 0.6, 16, 160);
    const ringMat = new THREE.MeshBasicMaterial({
      color: 0x22c55e,
      transparent: true,
      opacity: 0.2,
      depthTest: false,
      depthWrite: false
    });
    const ring = new THREE.Mesh(ringGeo, ringMat);
    ring.rotation.x = Math.PI / 2;
    ring.position.y = mesh.position.y;
    ring.position.x = hDecReal * sR;  // 水平偏心
    ring.position.z = vDecReal * sR;  // 垂直偏心
    ring.renderOrder = 9;
    scene.add(ring);
    _L3D.ring = ring;
  }

  // ---------- 5. 十字子午線「窗簾」厚度切面 ----------
  // sMinReal / sMaxReal：沿該軸方向（x 或 z）的實際座標 mm
  // mode: "x" = 水平窗簾, "z" = 垂直窗簾
  function buildCurtain(sMinReal, sMaxReal, mode){
    if (!isFinite(sMinReal) || !isFinite(sMaxReal) || sMaxReal <= sMinReal) {
      return null;
    }

    const NX   = 64;
    const verts = [];

    // 跟 3D 主體一致的幾何參數
    const cutR   = Number(res.cutR) || ((Number(res.ED) || 0) / 2);
    const blankR = Number(res.blankDia) ? Number(res.blankDia) / 2 : cutR;
    const rEdgeReal = Math.max(blankR, cutR, Number(res.rL) || 0, Number(res.rR) || 0);

    const n3     = Number(res.n) || 1.5;
    const denom3 = 2000 * (n3 - 1) || 1;
    const BCval  = Number(res.BC);
    const Sval   = Number(res.D) || 0;
    let baseF    = isFinite(BCval) && BCval !== 0 ? BCval : Sval;
    baseF        = Number(baseF) || 0;

    const sagFrontMax = (rEdgeReal * rEdgeReal * Math.abs(baseF)) / denom3;

    // 取一個 s 位置，回傳前表 / 後表在世界座標的點
    function pointOnCurtain(sReal){
      let xReal, zReal;
      if (mode === "x"){
        // 水平窗簾：沿 x 方向
        xReal = hDecReal + sReal;
        zReal = vDecReal;
      } else {
        // 垂直窗簾：沿 z 方向
        xReal = hDecReal;
        zReal = vDecReal + sReal;
      }

      const rReal    = Math.sqrt(xReal * xReal + zReal * zReal);
      const thetaRad = Math.atan2(zReal, xReal);

      const t = Math.max(0, thicknessAtPolar(res, rReal, thetaRad) || 0);

      let yFront, yBack;
      if (res.lensType === "minus"){
        // 近視：有 BC 時前表球面，無 BC 則平面
        if (isFinite(baseF) && baseF > 0){
          const sagFront = (rReal * rReal * Math.abs(baseF)) / denom3;
          yFront = (sagFrontMax - sagFront) * sT;
        } else {
          yFront = 0;
        }
        yBack = yFront - t * sT;
      } else {
        // 遠視：前表球面
        const sagFront = (rReal * rReal * Math.abs(baseF)) / denom3;
        yFront = (sagFrontMax - sagFront) * sT;
        yBack  = yFront - t * sT;
      }

      const xWorld = xReal * sR;
      const zWorld = zReal * sR;

      return {
        front: new THREE.Vector3(xWorld, yFront, zWorld),
        back:  new THREE.Vector3(xWorld, yBack,  zWorld)
      };
    }

    // 沿著裁型圈範圍，切成 NX 小片，每片兩個三角形
    for (let i = 0; i < NX; i++){
      const tt1 = i / NX;
      const tt2 = (i + 1) / NX;

      const s1 = sMinReal + (sMaxReal - sMinReal) * tt1;
      const s2 = sMinReal + (sMaxReal - sMinReal) * tt2;

      const p1 = pointOnCurtain(s1);
      const p2 = pointOnCurtain(s2);

      // 兩個三角形組成一小段窗簾（front ↔ back）
      verts.push(
        p1.front.x, p1.front.y, p1.front.z,
        p1.back.x,  p1.back.y,  p1.back.z,
        p2.front.x, p2.front.y, p2.front.z,

        p1.back.x,  p1.back.y,  p1.back.z,
        p2.back.x,  p2.back.y,  p2.back.z,
        p2.front.x, p2.front.y, p2.front.z
      );
    }

    const sliceGeo = new THREE.BufferGeometry();
    sliceGeo.setAttribute(
      "position",
      new THREE.Float32BufferAttribute(verts, 3)
    );
    sliceGeo.computeVertexNormals();

    // 顏色：水平 = 綠，垂直 = 淡黃色；超出鏡坯則為紅色
    const okColor  = (mode === "x" ? 0x22c55e : 0xE0FC53);
    const color    = ringInside ? okColor : 0xef4444;
    const sliceMat = new THREE.MeshBasicMaterial({
      color,
      transparent: true,
      opacity: 0.4,
      side: THREE.DoubleSide,
      depthTest: false,
      depthWrite: false
    });

    const slice = new THREE.Mesh(sliceGeo, sliceMat);
    slice.position.y = mesh.position.y;
    slice.renderOrder = 10;
    scene.add(slice);

    // --- 邊緣樣式（對應 2D：全框溝尖 / 車溝凹槽 / 無邊框不顯示） ---
    const rimType = String(res.rimType || "").toLowerCase();
    if (rimType === "full" || rimType === "groove"){
      const pMinEnd = pointOnCurtain(sMinReal);
      const pMaxEnd = pointOnCurtain(sMaxReal);

      const tipHeight   = Math.max(0.05, Number(res.tipHeight)   || 0.5);
      const grooveDepth = Math.max(0.05, Number(res.grooveDepth) || 0.6);

      // 尖寬/溝寬：只控制「垂直高度」（Y 軸），垂直位置比照 2D
      const span = (rimType === "full"
        ? (Number(res.tipSpan) || Number(res.tipWidth) || 1.0)
        : (Number(res.grooveSpan) || Number(res.grooveWidth) || 1.0)
      );
      const h = (Math.max(0.10, span) * sT) / 2;

      // 軸向配色：水平綠 / 垂直黃
      const axisColor = (mode === "x") ? 0x22c55e : 0xE0FC53;

      const edgeGroup = new THREE.Group();
      edgeGroup.position.y = mesh.position.y; // 與 slice 一致
      edgeGroup.renderOrder = 11;

      const fullLineMat = new THREE.LineBasicMaterial({
        color: axisColor,
        transparent: true,
        opacity: 0.4,
        depthTest: false,
        depthWrite: false
      });
      const fullFillMat = new THREE.MeshBasicMaterial({
        color: axisColor,
        transparent: true,
        opacity: 0.4,
        side: THREE.DoubleSide,
        depthTest: false,
        depthWrite: false
      });

      const grooveLineMat = new THREE.LineBasicMaterial({
        color: 0xA9BED6,
        transparent: true,
        opacity: 0.04,
        depthTest: false,
        depthWrite: false
      });
      const grooveFillMat = new THREE.MeshBasicMaterial({
        color: 0x020817,
        transparent: true,
        opacity: 0.4,
        side: THREE.DoubleSide,
        depthTest: false,
        depthWrite: false
      });

      const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

      function addEndShape(pEnd, sEnd){
        if (!pEnd) return;

        // sEnd 代表此端在「窗簾軸」上的方向：負端 / 正端
        const sign = (sEnd >= 0 ? 1 : -1);

        const yF = pEnd.front.y;
        const yB = pEnd.back.y;
        const yTop = Math.max(yF, yB);
        const yBot = Math.min(yF, yB);

        const yMin = yBot + 0.01;
        const yMax = yTop - 0.01;
        const tLocal = Math.max(0.0001, yMax - yMin);

        // 垂直位置：比照 2D（從上緣往下 1/2.4 的位置）
        const yNotch = clamp(yTop - (tLocal / 2.4), yMin, yMax);

        const y1 = clamp(yNotch - h, yMin, yMax);
        const y2 = clamp(yNotch + h, yMin, yMax);

        const x0 = pEnd.front.x;
        const z0 = pEnd.front.z;

        if (rimType === "full"){
          // 全框：外凸三角形尖（顏色符合軸向：垂直黃、水平綠）
          let tri;
          if (mode === "x"){
            const xApex = x0 + sign * tipHeight * sR;
            tri = [
              [x0,    y1,     z0],
              [xApex, yNotch, z0],
              [x0,    y2,     z0]
            ];
          } else {
            const zApex = z0 + sign * tipHeight * sR;
            tri = [
              [x0,    y1,     z0],
              [x0,    yNotch, zApex],
              [x0,    y2,     z0]
            ];
          }

          // fill
          const g = new THREE.BufferGeometry();
          g.setAttribute('position', new THREE.Float32BufferAttribute(tri.flat(), 3));
          g.setIndex([0, 1, 2]);
          const mFill = new THREE.Mesh(g, fullFillMat);
          mFill.renderOrder = edgeGroup.renderOrder;
          edgeGroup.add(mFill);

        } else {
          // 車溝框：方形內凹槽（背景深藍）
          let quad;
          if (mode === "x"){
            const xIn = x0 - sign * grooveDepth * sR; // 往中心
            quad = [
              [x0,  y1, z0],
              [x0,  y2, z0],
              [xIn, y2, z0],
              [xIn, y1, z0]
            ];
          } else {
            const zIn = z0 - sign * grooveDepth * sR; // 往中心
            quad = [
              [x0, y1, z0],
              [x0, y2, z0],
              [x0, y2, zIn],
              [x0, y1, zIn]
            ];
          }

          // fill
          const g = new THREE.BufferGeometry();
          g.setAttribute('position', new THREE.Float32BufferAttribute(quad.flat(), 3));
          g.setIndex([0, 1, 2, 0, 2, 3]);
          const mFill = new THREE.Mesh(g, grooveFillMat);
          mFill.renderOrder = edgeGroup.renderOrder;
          edgeGroup.add(mFill);

          // outline
          const pts = [
            new THREE.Vector3(quad[0][0], quad[0][1], quad[0][2]),
            new THREE.Vector3(quad[1][0], quad[1][1], quad[1][2]),
            new THREE.Vector3(quad[2][0], quad[2][1], quad[2][2]),
            new THREE.Vector3(quad[3][0], quad[3][1], quad[3][2]),
            new THREE.Vector3(quad[0][0], quad[0][1], quad[0][2])
          ];
          const geo = new THREE.BufferGeometry().setFromPoints(pts);
          const line = new THREE.Line(geo, grooveLineMat);
          line.renderOrder = edgeGroup.renderOrder;
          edgeGroup.add(line);
        }
      }

      addEndShape(pMinEnd, sMinReal);
      addEndShape(pMaxEnd, sMaxReal);

      scene.add(edgeGroup);
      edgeStyles.push(edgeGroup);
    }
    return slice;
  }

  const slices = [];
  if (cutRReal > 0) {
    // 水平：沿 x 方向，從 -cutR 到 +cutR
    const sMinX  = -cutRReal;
    const sMaxX  =  cutRReal;
    const sliceX = buildCurtain(sMinX, sMaxX, "x");
    if (sliceX) slices.push(sliceX);

    // 垂直：沿 z 方向，從 -cutR 到 +cutR
    const sMinZ  = -cutRReal;
    const sMaxZ  =  cutRReal;
    const sliceZ = buildCurtain(sMinZ, sMaxZ, "z");
    if (sliceZ) slices.push(sliceZ);
  }
  // 存起來方便之後清理
  _L3D.slice = slices;
  _L3D.edgeStyle = edgeStyles.length ? edgeStyles : null;
}
  // 繪圖小工具
  function circle(svg,cx,cy,r,fill,stroke,sw, dash){
    const el=document.createElementNS('http://www.w3.org/2000/svg','circle');
    el.setAttribute('cx',cx);el.setAttribute('cy',cy);el.setAttribute('r',r);
    el.setAttribute('fill',fill);el.setAttribute('stroke',stroke);el.setAttribute('stroke-width',sw);
    if(dash) el.setAttribute('stroke-dasharray',dash);
    svg.appendChild(el);
  }
  function line(svg,x1,y1,x2,y2,stroke,sw){
    const el=document.createElementNS('http://www.w3.org/2000/svg','line');
    el.setAttribute('x1',x1);el.setAttribute('y1',y1);el.setAttribute('x2',x2);el.setAttribute('y2',y2);
    el.setAttribute('stroke',stroke);el.setAttribute('stroke-width',sw);svg.appendChild(el);
  }
  function rect(svg,x,y,w,h,fill){
    const el=document.createElementNS('http://www.w3.org/2000/svg','rect');
    el.setAttribute('x',x);el.setAttribute('y',y);el.setAttribute('width',w);el.setAttribute('height',h);el.setAttribute('fill',fill);svg.appendChild(el);
  }
  function text(svg, x, y, str, fill, anchor, lineHeight = 14) {
    const el = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    el.setAttribute('x', x);
    el.setAttribute('y', y);
    el.setAttribute('fill', fill || '#111');
    if (anchor) el.setAttribute('text-anchor', anchor);
    el.style.fontSize = '12px';
    const parts = String(str).split(/\n|\(換行\)/g);
    parts.forEach((ln, i) => {
      const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
      tspan.setAttribute('x', x);
      tspan.setAttribute('dy', i === 0 ? '0' : String(lineHeight));
      tspan.textContent = ln;
      el.appendChild(tspan);
    });
    svg.appendChild(el);
  }
    function polygon(svg, points, fill, stroke, sw){
    const el = document.createElementNS('http://www.w3.org/2000/svg','polygon');
    const pts = points.map(p => p[0] + "," + p[1]).join(" ");
    el.setAttribute("points", pts);
    if (fill)   el.setAttribute("fill", fill);
    if (stroke) el.setAttribute("stroke", stroke);
    if (sw != null) el.setAttribute("stroke-width", sw);
    svg.appendChild(el);
  }
  const FIELD_HELP = {
    D:   "球鏡 S (±)：-20.00~ +15.00 DS。正/負(近/遠視)請由鏡片類型切換",
    Cyl: "散光 C：輸入負散，決定後表散光量（環曲面後散形式）。",
    Axis:"軸度 A：0–180°，以水平為180°或0°皆可運算",
    BC:  "前表面彎弧（1.00D≈100彎）。近視可設置0~8D，≧-5.00DS建議前彎0~1D；而遠視可設置0~15D，此系統遠視鏡片會設計成後散形式所以限制前彎≧DS",
    centerT: "近視鏡坯中心厚度（mm）。最小1~最大5.0mm，綜合度數-1.00D內建議2~3mm、高於-6.00D建議1~1.5mm",
    edgeT:   "遠視鏡坯邊緣厚度（mm）。最小0.3~最大3.0mm，調控基底厚度不可過薄、易在鏡框裝合上有問題",
    blankDia: "鏡坯直徑設定50~80 (mm)"
  };
  function bindFieldHelp(){
    const helpEl = $("fieldHelp");
    if (!helpEl) return;

    Object.keys(FIELD_HELP).forEach(id => {
      const input = $(id);
      if (!input) return;
      const row = input.closest(".row");
      if (!row) return;
      const label = row.querySelector("label");
      if (!label) return;

      label.style.cursor = "help";
      label.addEventListener("click", () => {
        helpEl.textContent = FIELD_HELP[id];
      });
    });
  }
  function update(){
    const res = calc();
    applyVerticalDec(res);
    const SM = spectacleMagnification(res);
    res.SM   = SM;
    res.SM_pct = (SM - 1) * 100;
    const thickDanger =
    (res.lensType === "minus") && (res.maxBlankThick > 12);    const thickText   = res.maxBlankThick.toFixed(2) + " mm";
    const vDec = res.vDecY || 0;
    const vDecText = (vDec > 0 ? "+" : (vDec < 0 ? "−" : "")) + Math.abs(vDec).toFixed(1) + " mm";
    // 顯示度數（+/-）
    /*$("d_display").textContent =
      "目前球鏡：" + ((res.D > 0 ? "+" : "") + (res.D || 0).toFixed(2) + " DS");*/
    // 顯示 BC 前後表度數換算
    const bcNote = $("bc_display");
    if (bcNote){
      const fmtD = v => {
        if (!isFinite(v)) return "—";
        const s = v > 0 ? "+" : (v < 0 ? "−" : "±0");
        return s + Math.abs(v).toFixed(2) + " D";
      };
      let html = "";
      if (isFinite(res.BC)){
        if (Math.abs(res.Cyl || 0) < 0.01){
          // 無散光：只顯示前表 & 後表軸上
          html =
            `前表：${fmtD(res.frontPower)}　後表：約 ${fmtD(res.backAxisPower)}`;
        } else {
          // 有散光：顯示軸向 / 垂直柱軸兩個子午線
          html =
            `前表：${fmtD(res.frontPower)}(球弧)　` +
            `後表：約 ${fmtD(res.backAxisPower)}（基弧） / ${fmtD(res.backPerpPower)}（正交弧）`;
        }
      }
      if (res.bcWarn){
        html += ` <span class="tag-warn">⚠️ ${res.bcWarn}</span>`;
      }
      bcNote.innerHTML = html;
    } 
    // ===== 1：裁型 / 鏡坯 & 厚度檢核 =====
    $("k_framePD").textContent  = res.framePD.toFixed(1) + " mm";
    $("k_dec").textContent      = res.dec.toFixed(2)     + " mm";
    $("k_cutDia").innerHTML =
      thickDanger
        ? `${thickText} <span class="tag-warn">⚠️ 易出現光圈平台</span>`
        : thickText;
    $("k_reqR").textContent = vDecText;
    $("k_minBlank").textContent = res.minBlank.toFixed(1)  + " mm"; 
    $("k_minBlank").className   = "v" + (res.blankOK ? "" : " danger");
    $("k_blankOK").textContent  = res.blankOK ? "✅ 足夠" : "❌ 不足";
    // ===== 2：厚度 & 溝尖/車溝檢核（近似） =====
    $("k_delta").textContent  = res.delta.toFixed(2)     + " mm"; 
    $("k_center").textContent = res.estCenter.toFixed(2) + " mm"; 
    /*$("k_edge").textContent   = res.estEdgeMin.toFixed(2)+ " mm"; */
    /*$("k_tip").textContent = res.tipRemain.toFixed(2) + " mm";    // = estEdgeMin - grooveDepth */
    // 溝尖檢測
    const rimType = $("rimType").value;
    if (rimType === "rimless") {
      $("k_halfSafety").textContent = "—";
      $("k_result").textContent     = "—";
    } else {
      $("k_halfSafety").textContent =
        res.tipRemain >= res.need
          ? `✅ ≥ ${res.need} mm`
          : `⚠️ < ${res.need} mm`;

      const rimOK =
        rimType === "groove"
          ? res.halfOK                             // ★ 已含上下偏心
          : (rimType === "full"
              ? (res.estEdgeMin - res.tipHeight >= res.minTip)
              : res.halfOK);

      $("k_result").textContent =
        rimOK ? "✅ 可行 (近似)" : "❌ 風險：厚度可能不足";
    }
    // ===== SM放大率 =====
    $("k_SM").textContent     = `${res.SM.toFixed(3)} ×`;
    $("k_SMpct").textContent  =
      (res.SM_pct >= 0 ? "+" : "") + res.SM_pct.toFixed(1) + " %"; 
    function debugBackSurface(res){
      const S  = Number(res.D)   || 0;
      const C  = Number(res.Cyl) || 0;
      const Ax = Number(res.Axis) || 0;
      let BC = Number(res.BC);
      if (!isFinite(BC) || BC === 0) {
        BC = S;
      }
      const F_front      = BC;              
      const F_back_axis  = S - F_front;     
      const F_back_cross = F_back_axis + C;
      console.table({
        S,
        C,
        Axis: Ax,
        F_front,
        F_back_axis,
        F_back_cross
      });
      return {
        S,
        C,
        Axis: Ax,
        F_front,
        F_back_axis,
        F_back_cross
      };
    }
    window.__lensRes = res;
    debugBackSurface(res);
    drawTop(res);
    drawSection(res);
    update3D(res);
  }
  (function initLensTypeUI(){
    const t = $("lensType").value;
    const minusRow = document.querySelector('[data-for="minus"]');
    const plusRow  = document.querySelector('[data-for="plus"]');
    const bcRow    = document.querySelector('[data-for="plusBC"]');
    if (minusRow) minusRow.style.display = (t === 'minus') ? '' : 'none';
    if (plusRow)  plusRow.style.display  = (t === 'plus')  ? '' : 'none';
    if (bcRow)    bcRow.style.display    = '';
  })();
  syncRimDefaults();bindFieldHelp();update();init3D();
})();
</script>
</body>
</html>

