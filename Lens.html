<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link rel="icon" href="img/optometry.png" type="image/x-icon">
<link rel="shortcut icon" href="img/optometry.png" type="image/x-icon">
<script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<title>鏡片厚度模擬器</title>
<style>
  :root{
    --bg:#0b1220;          /* 背景 */
    --ink:#e5e7eb;         /* 主要文字 */
    --muted:#94a3b8;       /* 次要文字 */
    --card:#0f172a;        /* 卡片底色 */
    --border:#1e293b;      /* 邊框色 */
    --pri:#38bdf8;         /* 重點/焦點色 */
    --ok:rgba(34, 197, 94, .4);
    --ng:rgba(248, 113, 113, .4);
  }
  html,body{height:100%}
  body{
    margin:0;
    font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans TC",Arial;
    background:radial-gradient(1200px 800px at 20% -10%,#0e1728 0%,#0b1220 55%),
               radial-gradient(800px 800px at 90% 10%,#0a1a2f 0%,transparent 60%),
               var(--bg);
    color:var(--ink);
  }
  .wrap{max-width:1200px;margin:24px auto;padding:0 16px}
  h1{font-size:22px;margin:0 0 12px;color:#f1f5f9}
  .grid{display:grid;gap:10px}
  .g-3{grid-template-columns:repeat(3,minmax(0,1fr))}
  .card{
    background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,.02));
    border:1px solid var(--border);
    border-radius:16px;
    box-shadow:0 10px 35px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.03);
    backdrop-filter:saturate(110%) blur(2px);
  }
  .card>.hd{
    padding:12px 16px;
    border-bottom:1px solid var(--border);
    font-weight:580;
    color:#cbd5e1;
  }
  .card>.bd{padding:8px 16px}
  .row{display:grid;grid-template-columns:1fr 160px;align-items:center;gap:8px;margin:8px 0}
  .row label{color:var(--muted);font-size:12px}
  input,select{
    width:100%;max-width:100%;box-sizing:border-box;
    padding:8px 10px;
    border:1px solid #334155;
    background:#0b1628;
    color:var(--ink);
    border-radius:10px;font-size:14px;outline:none;
    transition:border-color .15s, box-shadow .15s, background .15s;
  }
  input::placeholder{color:#71839a}
  select option{background:#0b1628;color:var(--ink)}
    input:focus,select:focus{
    border-color:#60a5fa;
    box-shadow:0 0 0 2px rgba(56,189,248,.25);
    background:#0c1a31;
  }
  .kpis{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:6px}
  .kpi{
    border:1px solid var(--border);
    border-radius:8px;
    background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.02));
    padding:5px
  }
  .kpi .t{font-size:11px;color:var(--muted)}
  .kpi .v{font-weight:700;margin-top:2px;color:#e2e8f0}
  .canvas{
    aspect-ratio:1/1;border-radius:16px;
    border:1px solid var(--border);
    background:radial-gradient(500px 400px at 60% 40%,rgba(148,163,184,.08),transparent 60%),
               #0b1324;
    display:flex;align-items:center;justify-content:center
  }
  .kpi-double{
    display:flex;
    flex-direction:column;
    gap:11px;
  }
  .kpi-subcard{
    padding-top:8px;
    border-top:1px solid var(--border);
  }
  .kpi-subcard:first-child{
    border-top:none;
  }
  .kpi-subtitle{
    font-size:12px;
    color:var(--muted);
    font-weight:600;
    margin-bottom:6px;
  }
  .note{font-size:12px;color:var(--muted)}
  .danger{color:var(--ng);font-weight:700}
  @media (max-width:980px){.g-3{grid-template-columns:1fr}}
  hr{border:0;border-top:1px dashed var(--border);margin:10px 0}
</style>
</head>
<body>
  <div class="wrap">
    <h1>鏡片厚度模擬器</h1>
    <p class="note">用途：在訂製前，輸入度數/折射率與框參數，估算裁型後邊緣厚度是否足夠做出溝尖與車溝，並檢查鏡坯片徑是否足夠。<br>聲明：本教學工具為厚度幾何近似值，未含前後表面彎度（BC）設定與折射面設計（如非球面與多焦）仍會產生誤差，實務仍需以加工經驗為準。</p>

    <div class="grid g-3">
      <div class="card">
        <div class="hd">參數輸入 [訂製鏡片]</div>
        <div class="bd">
          <div class="row"><label>鏡片類型</label><select id="lensType"><option value="minus">近視</option><option value="plus">遠視</option></select></div>
          <div class="row"><label>球鏡 D (±)</label><input id="D" type="number" step="0.25" value="-6" min="-20" max="20"></div>
          <div class="note" id="d_display">目前：-6.00 D</div>
          <div class="row"><label>折射率 n</label>
            <select id="n">
              <option value="1.50">1.50</option>
              <option value="1.56">1.56</option>
              <option value="1.61">1.61</option>
              <option value="1.67" selected>1.67</option>
              <option value="1.74">1.74</option>
            </select>
          </div>
          <div class="row" data-for="minus"><label>指定中心厚 (mm)</label><input id="centerT" type="number" step="0.1" value="1.2" min="1.0" max="3.0"></div>
          <div class="row" data-for="plus" style="display:none"><label>設定邊緣厚 (mm)</label><input id="edgeT" type="number" step="0.1" value="2.0" min="0.2" max="3.0"></div>
          <div class="row"><label>鏡坯片徑 (mm)</label><input id="blankDia" type="number" step="1" value="65" min="50" max="80"></div>
        </div>
      </div>

      <div class="card">
        <div class="hd">平面視圖（鏡坯 / 裁型 ）</div>
        <div class="bd">
          <div class="canvas"><svg id="topView" width="340" height="340"></svg></div>
          <p class="note">圖示：外圈＝鏡坯片徑；內圈＝裁型直徑（ED）；<br>綠/紅環＝邊緣厚達標/不足；鏡坯不足→外圈紅色。</p>
        </div>
      </div>

      <div class="card">
        <div class="hd">裁型邊緣厚度（含偏心影響）</div>
        <div class="bd">
          <div class="canvas"><svg id="sectionView" width="340" height="340"></svg></div>
          <p class="note">橫切面沿水平方向：左/右邊因偏心（PD ≠ A+DBL）<br>而產生不同邊緣厚度，評估最薄側是否可開車溝。</p>
        </div>
      </div>
    </div>

    <div class="grid g-3" style="margin-top:16px">
      <div class="card">
        <div class="hd">參數輸入 [框參數] </div>
        <div class="bd">
          <div class="row"><label>有效直徑 ED (mm)</label><input id="ED" type="number" step="0.5" value="53" min="20" max="80"></div>
          <div class="row"><label>框寬 A (mm)</label><input id="A" type="number" step="0.5" value="52" min="20" max="80"></div>
          <div class="row"><label>框高 B (mm)</label><input id="B" type="number" step="0.5" value="35" min="20" max="80"></div>
          <div class="row"><label>中樑距 DBL (mm)</label><input id="DBL" type="number" step="0.5" value="18" min="10" max="40"></div>
          <div class="row"><label>瞳距 PD (mm)</label><input id="PD" type="number" step="0.5" value="62" min="40" max="80"></div>
          <div class="row"><label>預留加工 (mm)</label><input id="allowance" type="number" step="0.5" value="2" min="0" max="4"></div>

          <div class="row"><label>框溝寬/車溝寬 (mm)</label><input id="grooveDepth" type="number" step="0.1" value="0.8" min="0.3" max="3"></div>
          <div class="row"><label>最小剩餘厚度需求 (mm)</label><input id="minTip" type="number" step="0.1" value="1.5" min="0.3" max="2"></div>
          <div class="row"><label>框型</label><select id="rimType"><option value="full">全框</option><option value="groove">車溝框</option></select></div>
        </div>
      </div>

      <div class="card">
        <div class="hd">3D 厚度視覺（概念示意）</div>
        <div class="bd">
          <div id="threeWrap" style="width:100%;height:340px;border-radius:12px;border:1px solid var(--border);background:#0a1322;overflow:hidden"></div>
          <p class="note">此 3D 為旋轉對稱概念示意：依厚度函式產生軸對稱鏡片（圓形）。不影響計算，僅供視覺化。</p>
        </div>
      </div>
     
      <div class="card">
        <div class="hd">裁型 / 鏡坯 & 厚度檢核</div>
        <div class="bd kpi-double">

          <!-- 上半：裁型 & 鏡坯評估 -->
          <div class="kpi-subcard">
            <div class="kpi-subtitle">裁型 & 鏡坯評估</div>
            <div class="kpis">
              <div class="kpi">
                <div class="t">框心距 (A+DBL)</div>
                <div id="k_framePD" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">單眼偏心</div>
                <div id="k_dec" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">裁型直徑 ≈</div>
                <div id="k_cutDia" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">鏡坯需求半徑</div>
                <div id="k_reqR" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">鏡坯最小建議片徑</div>
                <div id="k_minBlank" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">鏡坯是否足夠</div>
                <div id="k_blankOK" class="v"></div>
              </div>
            </div>
          </div>

          <!-- 下半：厚度 & 溝尖/車溝檢核（近似） -->
          <div class="kpi-subcard">
            <div class="kpi-subtitle">厚度 & 溝尖/車溝檢核（近似）</div>
            <div class="kpis">
              <div class="kpi">
                <div class="t">Δ（幾何近似）</div>
                <div id="k_delta" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">中心厚估</div>
                <div id="k_center" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">邊緣厚（薄側）</div>
                <div id="k_edge" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">不含溝尖/車溝邊厚（薄側）</div>
                <div id="k_tip" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">車溝/溝尖安全線</div>
                <div id="k_halfSafety" class="v"></div>
              </div>
              <div class="kpi">
                <div class="t">結果</div>
                <div id="k_result" class="v"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>


<script>
(function(){
  const $ = (id)=>document.getElementById(id);
  const ids = ["lensType","D","n","centerT","edgeT","blankDia","ED","A","B","DBL","PD","allowance","grooveDepth","minTip","rimType"];
  ids.forEach(id=>$(id).addEventListener('input', update));
  $("lensType").addEventListener('change', ()=>{
    const t = $("lensType").value;
    document.querySelector('[data-for="minus"]').style.display = (t==='minus')?'' : 'none';
    document.querySelector('[data-for="plus"]').style.display  = (t==='plus') ?'' : 'none';
    update();
  });

  function clamp(v,min,max){ v=parseFloat(v); if(isNaN(v)) return min; return Math.min(Math.max(v,min),max); }

  function calc(){
    const lensType = $("lensType").value; // minus/plus
    const D  = parseFloat($("D").value);
    const n  = parseFloat($("n").value);
    const centerT = clamp($("centerT").value,1.0,3.0);
    const edgeT   = clamp($("edgeT").value,0.2,3.0);
    const blankDia= clamp($("blankDia").value,50,80);


    const ED = clamp($("ED").value,20,80);
    const A  = clamp($("A").value,20,80);
    const B  = clamp($("B").value,20,80);
    const DBL= clamp($("DBL").value,10,40);
    const PD = clamp($("PD").value,40,80);
    const allowance = clamp($("allowance").value,0,4);

    const grooveDepth = clamp($("grooveDepth").value,0.3,0.9);
    const minTip = clamp($("minTip").value,0.8,2);
    const rimType = $("rimType").value; // full/groove

    const framePD = A + DBL;
    const dec = Math.abs(framePD - PD)/2; // 單眼偏心

    // 水平方向：以框寬 A/2 為基準
    const halfA = A / 2;
    const rL = Math.max(0, halfA - dec); // 左邊實際到光學中心距離
    const rR = halfA + dec;              // 右邊實際到光學中心距離

    // 斜邊 ED：用來算最大半徑與鏡坯需求
    const cutR = ED/2;                  // 視覺上的裁型「等效圓半徑」
    const rMax = cutR + dec;           // 最遠那一點（對角線 + 偏心）

    // 鏡坯需求半徑、片徑（沿用原本概念）
    const hReq = rMax + allowance;
    const minBlank = 2 * hReq;
    const blankOK  = (blankDia/2) >= hReq;

    const absD  = Math.abs(D);
    const denom = 2000 * (n - 1) || 1;
    const sag   = r => (r * r * absD) / denom;

    const rThin   = Math.max(rL, rR);   // 水平薄側 / 最大半徑
    const blankR  = blankDia / 2;       // 鏡坯半徑
    const rDesign = Math.max(rThin, blankR);

    // Δ：以 rThin 為參考半徑，中心與該半徑的厚度差
    const rRef  = rThin;
    const delta = sag(rRef);            // 對近視/遠視都一樣是 sag(rRef)

    function tMinus(r){
      return centerT + sag(r);          // 近視：中心薄、邊緣厚
    }

    function tPlus(r){
      // 遠視：設計讓 rDesign 處厚度 = edgeT，鏡坯越大 → 中心越厚
      const center = edgeT + sag(rDesign);
      const rr     = Math.min(r, rDesign);
      return Math.max(0, center - sag(rr));
    }

    let tL, tR, estCenter, estEdgeMin;
    if (lensType === 'minus') {
      estCenter = centerT;
      tL = tMinus(rL);
      tR = tMinus(rR);
    } else {
      estCenter = tPlus(0);   // 中心厚估
      tL = tPlus(rL);
      tR = tPlus(rR);
    }
    estEdgeMin = Math.min(tL, tR);      // 左右最薄側邊厚

    const tipRemain = estEdgeMin - grooveDepth; // 薄側尖端剩餘厚度

    // 車溝框安全（建議 ≥1.0 或使用者設定）
    const need   = Math.max(1.0, minTip);
    const halfOK = tipRemain >= need;

    return {lensType,D,n,centerT,edgeT,blankDia,ED,A,B,DBL,PD,allowance,grooveDepth,minTip,rimType,
      framePD,dec,cutR,hReq,blankOK,delta,estCenter,estEdgeMin,tipRemain,halfOK,minBlank,rL,rR,rMax,need};
  }

  function drawTop(res){
    const svg = $("topView");
    const W=svg.viewBox.baseVal.width||340,H=svg.viewBox.baseVal.height||340; svg.setAttribute('viewBox',`0 0 ${W} ${H}`);
    svg.innerHTML='';
    const cx=W/2, cy=H/2;
    const blankR = Math.min(W,H)*0.42;
    const rBlankReal = res.blankDia / 2; 
    const scale = blankR / rBlankReal;    
    // 框橢圓（boxing system：A×B）
    const rxFrame = (res.A / 2) * scale;
    const ryFrame = (res.B / 2) * scale;
    const dx = (res.dec) * scale;
    // 框形狀：橢圓
    ellipse(svg, cx + dx, cy, rxFrame, ryFrame, 'none', '#4b5563', 2);
    // ED 等效圓（虛線）
    const rED = (res.ED / 2) * scale;
    circle(svg, cx + dx, cy, rED, 'none', '#6b7280', 1, '4 4');

    const rCut = (res.cutR / rBlankReal) * blankR; // 裁型半徑

    // 鏡坯外圈（不足時紅色）
    circle(svg, cx, cy, blankR, 'none', res.blankOK ? '#cbd5e1' : '#ef4444', 2);

    // 裁型圈（以框中心相對鏡坯中心之偏心顯示）
    circle(svg,cx+dx,cy,rCut,'none','#374151',2);

    // 溝槽達標（薄側）
    const edgeColor = res.tipRemain >= res.need
      ? 'rgba(34,197,94,0.4)'    
      : 'rgba(239,68,68,0.4)';  
    circle(svg, cx + dx, cy, rCut + 8, 'none', edgeColor, 8);

    // 標註
    text(svg,cx,cy-blankR-8,`鏡坯片徑 ${res.blankDia.toFixed(0)} mm`,'#99B3C2');
    text(svg,cx+dx,cy-rCut+32,`裁型直徑 ≈ ${ (res.cutR*2).toFixed(1) } mm`,'#839681','middle');
  }

  function drawSection(res){
    const svg=$("sectionView");
    const W=svg.viewBox.baseVal.width||340,H=svg.viewBox.baseVal.height||340; svg.setAttribute('viewBox',`0 0 ${W} ${H}`);
    svg.innerHTML='';
    const cx=W/2, baseY=H*0.75;

    // 橫向比例：以最大半徑 rR 對應到視圖寬度 120px
    const scaleX = 120 / Math.max(res.rR, res.cutR);
    // 厚度比例：僅視覺化用（1mm→8px）
    const scaleT = 8;

    // 中央基準線
    line(svg,cx-140,baseY,cx+140,baseY,'#e5e7eb',1);

    // 左右邊緣位置（相對鏡片中心）
    const xL = cx - res.rL*scaleX+20; const xR = cx + res.rR*scaleX-40;

    const tL = thicknessAt(res,'L');
    const tR = thicknessAt(res,'R');

    // 繪製截面（矩形示意局部厚度）
    rect(svg, xL-6, baseY - tL*scaleT, 12, tL*scaleT, '#93c5fd');
    rect(svg, xR-6, baseY - tR*scaleT, 12, tR*scaleT, '#93c5fd');

    // 車溝寬
    rect(svg, xL-6, baseY - Math.max(0,tL-res.grooveDepth)*scaleT, 12, res.grooveDepth*scaleT, 'rgba(239,68,68,.6)');
    rect(svg, xR-6, baseY - Math.max(0,tR-res.grooveDepth)*scaleT, 12, res.grooveDepth*scaleT, 'rgba(239,68,68,.6)');

    // 標註
    text(svg, xL, baseY+14, `左 r=${res.rL.toFixed(1)}mm\n邊厚=${tL.toFixed(2)}mm`, '#A9BED6', 'middle');
    text(svg, xR, baseY+14, `右 r=${res.rR.toFixed(1)}mm\n邊厚=${tR.toFixed(2)}mm`, '#A9BED6', 'middle');
    text(svg, cx, baseY+52, `溝尖寬/車溝寬 ${res.grooveDepth.toFixed(1)}mm；薄側剩餘 ${(res.estEdgeMin-res.grooveDepth).toFixed(2)}mm`, '#4FABB8','middle');
  }


  function thicknessAtRadius(res, r){
    const n    = Number(res.n) || 0;
    const D    = Number(res.D) || 0;
    const absD = Math.abs(D);
    const denom = 2000 * (n - 1) || 1;
    const sag   = radius => (radius * radius * absD) / denom;

    if (res.lensType === 'minus') {
      // 近視：中心薄、邊緣厚
      return Number(res.centerT) + sag(r);
    } else {
      // 遠視：設計「薄側邊緣厚度 edgeT」，
      //       鏡坯越大 → 中心越厚，邊緣不會比 edgeT 更薄
      const edgeT  = Number(res.edgeT) || 0;
      const rThin  = Math.max(res.rL, res.rR);          // 薄側半徑（框）
      const blankR = res.blankDia ? res.blankDia / 2 : rThin;  // 鏡坯半徑
      const rDesign = Math.max(rThin, blankR);          // 設計半徑

      const center = edgeT + sag(rDesign);              // rDesign 處厚度 = edgeT
      const rr     = Math.min(r, rDesign);              // 超過就當在 rDesign
      return Math.max(0, center - sag(rr));
    }
  }

  function thicknessAt(res, side){
    const r = (side === 'L') ? res.rL : res.rR;
    return thicknessAtRadius(res, r);
  }

  function ellipse(svg, cx, cy, rx, ry, fill, stroke, sw, dash){
    const el = document.createElementNS('http://www.w3.org/2000/svg','ellipse');
    el.setAttribute('cx',cx);
    el.setAttribute('cy',cy);
    el.setAttribute('rx',rx);
    el.setAttribute('ry',ry);
    el.setAttribute('fill',fill);
    el.setAttribute('stroke',stroke);
    el.setAttribute('stroke-width',sw);
    if(dash) el.setAttribute('stroke-dasharray',dash);
    svg.appendChild(el);
  }

let _L3D = null;

function init3D(){
  if (_L3D || !window.THREE) return;
  const wrap = document.getElementById('threeWrap');
  if (!wrap) return;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0a1322);

  const camera = new THREE.PerspectiveCamera(35, wrap.clientWidth / wrap.clientHeight, 0.1, 1000);
  camera.position.set(0, 25, 85);

  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(wrap.clientWidth, wrap.clientHeight);
  wrap.innerHTML = '';
  wrap.appendChild(renderer.domElement);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  // lights
  const key = new THREE.DirectionalLight(0xffffff, 0.9); key.position.set(1,2,3);
  const fil = new THREE.DirectionalLight(0x88ccff, 0.6); fil.position.set(-2,1,0);
  const amb = new THREE.AmbientLight(0x334455, 0.6);
  scene.add(key, fil, amb);

  // subtle grid
  const grid = new THREE.GridHelper(200, 20, 0x1f3045, 0x182435);
  grid.position.y = -0.01; scene.add(grid);

  _L3D = {wrap, scene, camera, renderer, controls,
        mesh:null, ring:null, edge:null, slice:null, rim:null};

  window.addEventListener('resize', ()=>{
    if(!_L3D) return;
    const {wrap, camera, renderer} = _L3D;
    camera.aspect = wrap.clientWidth / wrap.clientHeight; 
    camera.updateProjectionMatrix();
    renderer.setSize(wrap.clientWidth, wrap.clientHeight);
  });

  (function loop(){ if(!_L3D) return; requestAnimationFrame(loop); _L3D.controls.update(); _L3D.renderer.render(_L3D.scene, _L3D.camera); })();
}

    // 厚度模型
  // 依厚度與度數建立「平凸 / 平凹」實心鏡片
function buildLensLatheGeometry(res){
  // ---- 基本參數 ----
  const n     = Number(res.n) || 0;
  const D     = Number(res.D) || 0;
  const absD  = Math.abs(D);
  const denom = 2000 * (n - 1) || 1;        
  const sag   = r => (r * r * absD) / denom;

  const rL    = Number(res.rL)    || 0;           // 左側框半徑
  const rR    = Number(res.rR)    || 0;           // 右側框半徑
  const cutR  = Number(res.cutR)  || ((Number(res.ED) || 0) / 2);
  const blankR= Number(res.blankDia) ? Number(res.blankDia) / 2 : cutR;

  // 鏡片實際邊緣半徑：取鏡坯 / 裁型 / 框中較大者
  const rEdgeReal = Math.max(blankR, cutR, rL, rR);
  if (!isFinite(rEdgeReal) || rEdgeReal <= 0){
    return null;
  }

  // ---- 厚度函式 thicknessAt(r)：mm 單位 ----
  function thicknessAt(r){
    if (res.lensType === 'minus'){
      // 近視：中心薄、邊緣厚
      const centerT = Number(res.centerT) || 0;   // 中央最薄厚度
      return centerT + sag(r);                    // 越外圈越厚
    } else {
      // 遠視：設定「薄側邊緣厚度 edgeT」
      // 鏡坯越大 → 中心要跟著變厚，邊緣不能比 edgeT 更薄
      const edgeT = Number(res.edgeT) || 0;

      const rThin   = Math.max(rL, rR);           // 框中真正「薄側」半徑
      const rDesign = Math.max(rThin, blankR);    // 設計半徑：外圈用到的較大者

      const center  = edgeT + sag(rDesign);       // 讓 rDesign 處厚度剛好 = edgeT
      const rr      = Math.min(r, rDesign);       // 超出去就當 rDesign
      return Math.max(0, center - sag(rr));       // 中央厚、邊緣不小於 edgeT
    }
  }

  // ---- 3D 尺度：把 mm 轉成 three.js 座標 ----
  const sR = 0.6;   // 半徑縮放
  const sT = 0.8;   // 厚度縮放（要跟 update3D 裡 sT 預設一致）

  const profile = [];
  const STEPS   = 64;

  if (res.lensType === 'minus'){
    // 負透鏡：前表平 (y=0)，後表凹到負方向

    // 1) 前表面：從中心 → 邊緣，都是平面 y=0
    for (let i = 0; i <= STEPS; i++){
      const u = i / STEPS;
      const r = rEdgeReal * u;
      const x = r * sR;
      const y = 0;
      profile.push(new THREE.Vector2(x, y));
    }

    // 2) 後表面：從邊緣 → 中心，依 thicknessAt(r) 畫出凹面
    for (let i = STEPS; i >= 0; i--){
      const u = i / STEPS;
      const r = rEdgeReal * u;
      const x = r * sR;
      const t = thicknessAt(r);          // mm
      const y = -t * sT;                 // 往下凹
      profile.push(new THREE.Vector2(x, y));
    }

  } else {
    // 正透鏡：後表平 (y=0)，前表凸到正方向

    // 1) 前表面：從中心 → 邊緣，凸面 y = +thicknessAt(r)
    for (let i = 0; i <= STEPS; i++){
      const u = i / STEPS;
      const r = rEdgeReal * u;
      const x = r * sR;
      const t = thicknessAt(r);          // mm
      const y = t * sT;                  // 往上凸
      profile.push(new THREE.Vector2(x, y));
    }

    // 2) 後表面：從邊緣 → 中心，平面 y=0
    for (let i = STEPS; i >= 0; i--){
      const u = i / STEPS;
      const r = rEdgeReal * u;
      const x = r * sR;
      const y = 0;
      profile.push(new THREE.Vector2(x, y));
    }
  }

  // ---- 生成 Lathe 幾何 ----
  const geom = new THREE.LatheGeometry(profile, 96);
  geom.computeVertexNormals();

  // 給 update3D 用的參考資訊
  geom.userData.rEdgeReal = rEdgeReal;
  geom.userData.sR        = sR;
  geom.userData.sT        = sT;
  geom.userData.rScale    = sR;
  geom.userData.tScale    = sT;

  return geom;
}

function update3D(res){
  if (!window.THREE) return;
  init3D();
  if (!_L3D) return;

  const scene = _L3D.scene;

  // ---------- 清除舊物件 ----------
  ["mesh","edge","ring","rim","slice"].forEach(key => {
    const obj = _L3D[key];
    if (!obj) { _L3D[key] = null; return; }

    if (Array.isArray(obj)) {
      obj.forEach(o => {
        if (!o) return;
        scene.remove(o);
        if (o.geometry) o.geometry.dispose();
        if (o.material) o.material.dispose();
      });
    } else {
      scene.remove(obj);
      if (obj.geometry) obj.geometry.dispose();
      if (obj.material) obj.material.dispose();
    }
    _L3D[key] = null;
  });

  // ---------- 建鏡片幾何 ----------
  const g = buildLensLatheGeometry(res);
  if (!g) return;

  const rEdgeReal =
    g.userData.rEdgeReal ||
    (Number(res.blankDia) ? Number(res.blankDia)/2
                          : Math.max(
                              Number(res.rL) || 0,
                              Number(res.rR) || 0,
                              Number(res.cutR) || 0,
                              (Number(res.ED) || 0)/2
                            ));

  const sR = g.userData.sR || g.userData.rScale || 0.6;
  const sT = g.userData.sT || g.userData.tScale || 0.8;

  // ---------- 統一厚度函式 thicknessAt(r) ----------
  const nVal   = Number(res.n) || 0;
  const DVal   = Number(res.D) || 0;
  const absD   = Math.abs(DVal);
  const denom  = 2000 * (nVal - 1) || 1;
  const sag    = r => (r * r * absD) / denom;

  function thicknessAt(r){
    if (res.lensType === "minus"){
      // 近視：中心薄、邊厚
      const centerT = Number(res.centerT) || 0;
      return centerT + sag(r);
    } else {
      // 遠視：設定薄側 edgeT，鏡坯越大 → 中心越厚，邊緣不會比 edgeT 更薄
      const edgeT = Number(res.edgeT) || 0;
      const rThin  = Math.max(Number(res.rL) || 0, Number(res.rR) || 0);    // 框薄側
      const blankR = Number(res.blankDia) ? Number(res.blankDia)/2 : rThin;  // 鏡坯半徑
      const rDesign = Math.max(rThin, blankR);                               // 設計半徑

      const center = edgeT + sag(rDesign);      // 讓 rDesign 處剛好 = edgeT
      const rr     = Math.min(r, rDesign);      // 超過就當 rDesign 處
      return Math.max(0, center - sag(rr));
    }
  }

  // ---------- 1. 鏡片本體 + 外輪廓 ----------
  const lensMat = new THREE.MeshPhysicalMaterial({
    color: 0xaad9ff,
    roughness: 0.25,
    metalness: 0.0,
    transmission: 0.4,
    transparent: true,
    opacity: 0.18,
    side: THREE.DoubleSide
  });
  const mesh = new THREE.Mesh(g, lensMat);
  mesh.position.y = 6;
  mesh.renderOrder = 0;
  scene.add(mesh);
  _L3D.mesh = mesh;

  const edgeGeo = new THREE.EdgesGeometry(g);
  const edgeMat = new THREE.LineBasicMaterial({
    color: 0xaad9ff,
    transparent: true,
    opacity: 0.15
  });
  const edgeLines = new THREE.LineSegments(edgeGeo, edgeMat);
  edgeLines.position.copy(mesh.position);
  edgeLines.renderOrder = 0;
  scene.add(edgeLines);
  _L3D.edge = edgeLines;

  // ---------- 2. 側邊圓柱牆（近視保持舊效果，遠視用邊緣厚度） ----------
  if (rEdgeReal > 0){
    let hVis = 0;
    let centerYOffset = 0;

    if (res.lensType === "minus"){
      // 近視：直接用幾何 bounding box 高度
      g.computeBoundingBox();
      const bb = g.boundingBox;
      if (bb){
        hVis = bb.max.y - bb.min.y;
        centerYOffset = (bb.max.y + bb.min.y) / 2;
      }
    } else {
      // 遠視：用「邊緣厚度」決定圓柱高度
      const tEdge = thicknessAt(rEdgeReal);   // mm
      const tVis  = tEdge * sT;
      hVis = tVis;
      centerYOffset = tVis / 2;               // 後表平在 y=0，前表在 +tVis
    }

    if (hVis > 0.0001){
      const rWorld = rEdgeReal * sR * 1.003;
      const rimGeo = new THREE.CylinderGeometry(
        rWorld, rWorld, hVis, 64, 1, true
      );
      const rimMat = new THREE.MeshBasicMaterial({
        color: 0xaad9ff,    
        transparent: true,
        opacity: 0.1,       
        side: THREE.DoubleSide,
        depthTest: true,   
        depthWrite: true
      });
      const rim = new THREE.Mesh(rimGeo, rimMat);
      rim.position.y = mesh.position.y + centerYOffset;
      rim.renderOrder = 0;
      scene.add(rim);
      _L3D.rim = rim;
    }
  }

  // ---------- 3. 裁型圈（高亮顯示） ----------
  const cutRReal = Number(res.cutR) || (Number(res.ED) || 0)/2;
  const decReal  = Math.abs(Number(res.dec) || 0);
  const ringInside = (decReal + cutRReal) <= rEdgeReal + 1e-6;

  if (cutRReal > 0){
    const ringRadius = cutRReal * sR;
    const ringGeo = new THREE.TorusGeometry(ringRadius, 0.6, 16, 160);
    const ringMat = new THREE.MeshBasicMaterial({
      color: 0x22c55e,
      transparent: true,
      opacity: 0.3,
      depthTest: false,
      depthWrite: false
    });
    const ring = new THREE.Mesh(ringGeo, ringMat);
    ring.rotation.x = Math.PI/2;
    ring.position.y = mesh.position.y;
    ring.position.x = decReal * sR;
    ring.renderOrder = 9;   // 在鏡片 / rim 之上，但低於切面
    scene.add(ring);
    _L3D.ring = ring;
  }

  // ---------- 4. 十字子午線「窗簾」厚度切面 ----------
  function buildCurtain(sMinReal, sMaxReal, mode){
    if (sMaxReal <= sMinReal) return null;

    const NX = 64;
    const top = [];
    const bottom = [];

    for (let i = 0; i <= NX; i++){
      const tt = i / NX;
      const sReal = sMinReal + (sMaxReal - sMinReal) * tt;

      let xReal, zReal;
      if (mode === "x"){
        // 沿偏心方向：x = dec + s, z = 0
        xReal = decReal + sReal;
        zReal = 0;
      } else {
        // 垂直方向：x = dec, z = s
        xReal = decReal;
        zReal = sReal;
      }

      const rReal = Math.sqrt(xReal*xReal + zReal*zReal);
      const thick = thicknessAt(rReal);   // mm
      const tVis  = thick * sT;           // 視覺高度

      let yTopLocal, yBotLocal;
      if (res.lensType === "minus"){
        // 近視：前表平 y=0，後表往下凹
        yTopLocal = 0;
        yBotLocal = -tVis;
      } else {
        // 遠視：後表平 y=0，前表往上凸
        yBotLocal = 0;
        yTopLocal = tVis;
      }

      const xWorld = xReal * sR;
      const zWorld = zReal * sR;

      top.push(   new THREE.Vector3(xWorld, yTopLocal,  zWorld));
      bottom.push(new THREE.Vector3(xWorld, yBotLocal, zWorld));
    }

    const verts = [];
    for (let i = 0; i < NX; i++){
      const t1 = top[i],   t2 = top[i+1];
      const b1 = bottom[i],b2 = bottom[i+1];

      // 三角形 1
      verts.push(
        t1.x, t1.y, t1.z,
        b1.x, b1.y, b1.z,
        t2.x, t2.y, t2.z
      );
      // 三角形 2
      verts.push(
        b1.x, b1.y, b1.z,
        b2.x, b2.y, b2.z,
        t2.x, t2.y, t2.z
      );
    }

    const sliceGeo = new THREE.BufferGeometry();
    sliceGeo.setAttribute(
      "position",
      new THREE.Float32BufferAttribute(verts, 3)
    );
    sliceGeo.computeVertexNormals();

    const sliceMat = new THREE.MeshBasicMaterial({
      color: ringInside ? 0x22c55e : 0xef4444, // 綠：鏡坯足夠；紅：鏡坯不足
      transparent: true,
      opacity: 0.55,
      side: THREE.DoubleSide,
      depthTest: false,   // 一定畫在最上面
      depthWrite: false
    });

    const slice = new THREE.Mesh(sliceGeo, sliceMat);
    slice.position.y = mesh.position.y;
    slice.renderOrder = 10;
    scene.add(slice);
    return slice;
  }

  const slices = [];

  // 4-1 沿偏心方向的子午線
  const xMinReal = Math.max(-rEdgeReal, decReal - cutRReal);
  const xMaxReal = Math.min( rEdgeReal, decReal + cutRReal);
  if (xMaxReal > xMinReal){
    const sMinX = xMinReal - decReal;
    const sMaxX = xMaxReal - decReal;
    const sliceX = buildCurtain(sMinX, sMaxX, "x");
    if (sliceX) slices.push(sliceX);
  }

  // 4-2 與偏心方向垂直的子午線
  const zLimitLens = Math.sqrt(Math.max(0, rEdgeReal*rEdgeReal - decReal*decReal));
  const zLimit = Math.min(cutRReal, zLimitLens);
  if (zLimit > 0){
    const sliceZ = buildCurtain(-zLimit, zLimit, "z");
    if (sliceZ) slices.push(sliceZ);
  }

  _L3D.slice = slices;
}

  // 繪圖小工具
  function circle(svg,cx,cy,r,fill,stroke,sw, dash){
    const el=document.createElementNS('http://www.w3.org/2000/svg','circle');
    el.setAttribute('cx',cx);el.setAttribute('cy',cy);el.setAttribute('r',r);
    el.setAttribute('fill',fill);el.setAttribute('stroke',stroke);el.setAttribute('stroke-width',sw);
    if(dash) el.setAttribute('stroke-dasharray',dash);
    svg.appendChild(el);
  }
  function line(svg,x1,y1,x2,y2,stroke,sw){
    const el=document.createElementNS('http://www.w3.org/2000/svg','line');
    el.setAttribute('x1',x1);el.setAttribute('y1',y1);el.setAttribute('x2',x2);el.setAttribute('y2',y2);
    el.setAttribute('stroke',stroke);el.setAttribute('stroke-width',sw);svg.appendChild(el);
  }
  function rect(svg,x,y,w,h,fill){
    const el=document.createElementNS('http://www.w3.org/2000/svg','rect');
    el.setAttribute('x',x);el.setAttribute('y',y);el.setAttribute('width',w);el.setAttribute('height',h);el.setAttribute('fill',fill);svg.appendChild(el);
  }
  function text(svg, x, y, str, fill, anchor, lineHeight = 14) {
    const el = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    el.setAttribute('x', x);
    el.setAttribute('y', y);
    el.setAttribute('fill', fill || '#111');
    if (anchor) el.setAttribute('text-anchor', anchor);
    el.style.fontSize = '12px';

    const parts = String(str).split(/\n|\(換行\)/g);
    parts.forEach((ln, i) => {
      const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
      tspan.setAttribute('x', x);
      tspan.setAttribute('dy', i === 0 ? '0' : String(lineHeight));
      tspan.textContent = ln;
      el.appendChild(tspan);
    });
    svg.appendChild(el);
  }

  function update(){
    const res = calc();

    // 顯示度數（+/-）
    $("d_display").textContent = '目前：' + ((res.D>0?'+':'') + (res.D||0).toFixed(2) + ' D');

    // KPI
    $("k_framePD").textContent = res.framePD.toFixed(1)+" mm";
    $("k_dec").textContent     = res.dec.toFixed(2)+" mm";
    $("k_cutDia").textContent  = (res.cutR*2).toFixed(1)+" mm";
    $("k_reqR").textContent    = res.hReq.toFixed(1)+" mm";
    $("k_minBlank").textContent= res.minBlank.toFixed(1)+" mm";
    $("k_minBlank").className  = 'v' + (res.blankOK?'':' danger');
    $("k_blankOK").textContent = (res.blankOK?"✅ 足夠":"❌ 不足");

    $("k_delta").textContent   = res.delta.toFixed(2)+" mm";
    $("k_center").textContent  = res.estCenter.toFixed(2)+" mm";
    $("k_edge").textContent    = res.estEdgeMin.toFixed(2)+" mm";
    $("k_tip").textContent     = (res.estEdgeMin - res.grooveDepth).toFixed(2)+" mm";

    $("k_halfSafety").textContent = (res.tipRemain>=res.need?`✅ ≥ ${res.need} mm`:`⚠️ < ${res.need} mm`);

    const rimOK = $("rimType").value==='groove' ? res.halfOK : (res.estEdgeMin - res.grooveDepth >= res.minTip);
    $("k_result").textContent = rimOK?"✅ 可行 (近似)":"❌ 風險：厚度可能不足";

    drawTop(res); drawSection(res);update3D(res);
  }

  update();init3D();
})();
</script>
</body>
</html>


